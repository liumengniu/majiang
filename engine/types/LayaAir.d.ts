/**
 * <code>Laya</code> 是全局对象的引用入口集。
 * Laya类引用了一些常用的全局对象，比如Laya.stage：舞台，Laya.timer：时间管理器，Laya.loader：加载管理器，使用时注意大小写。
 */
declare class Laya {
    /** 舞台对象的引用。*/
    static stage: Laya.Stage;
    /**@private 系统时钟管理器，引擎内部使用*/
    static systemTimer: Laya.Timer;
    /**@private 组件的物理时钟管理器*/
    static physicsTimer: Laya.Timer;
    /**游戏主时针，同时也是管理场景，动画，缓动等效果时钟，通过控制本时针缩放，达到快进慢播效果*/
    static timer: Laya.Timer;
    /** 加载管理器的引用。*/
    static loader: Laya.Loader;
    /**@private Render 类的引用。*/
    static render: Laya.Render;
    private static _inited;
    private static _initCallbacks;
    private static _beforeInitCallbacks;
    private static _afterInitCallbacks;
    /**
     * 初始化引擎。使用引擎需要先初始化引擎。
     */
    static init(stageConfig?: Laya.IStageConfig): Promise<void>;
    /**
     * 初始化引擎。使用引擎需要先初始化引擎。
     * @param	width 初始化的游戏窗口宽度，又称设计宽度。
     * @param	height 初始化的游戏窗口高度，又称设计高度。
     */
    static init(width: number, height: number): Promise<void>;
    static initRender2D(stageConfig: Laya.IStageConfig): void;
    /**
     * 表示是否捕获全局错误并弹出提示。默认为false。
     * 适用于移动设备等不方便调试的时候，设置为true后，如有未知错误，可以弹窗抛出详细错误堆栈。
     */
    static alertGlobalError(value: boolean): void;
    /**
     * 开启DebugPanel
     * @param	debugJsPath laya.debugtool.js文件路径
     */
    static enableDebugPanel(debugJsPath?: string): void;
    private static isNativeRender_enable;
    /**@private */
    private static enableNative;
    /**
     * 引擎各个模块，例如物理，寻路等，如果有初始化逻辑可以在这里注册初始化函数。开发者一般不直接使用。
     * @param callback 模块的初始化函数
     */
    static addInitCallback(callback: () => void | Promise<void>): void;
    /**
     * 在引擎初始化前执行自定义逻辑。此时Stage尚未创建，因为可以修改stageConfig实现动态舞台配置。
     * @param callback
     */
    static addBeforeInitCallback(callback: (stageConfig: Laya.IStageConfig) => void | Promise<void>): void;
    /**
     * 在引擎初始化后执行自定义逻辑
     * @param callback
     */
    static addAfterInitCallback(callback: () => void | Promise<void>): void;
}
declare var addInitCallback: typeof Laya.addInitCallback;
declare var addBeforeInitCallback: typeof Laya.addBeforeInitCallback;
declare var addAfterInitCallback: typeof Laya.addAfterInitCallback;
/**
 * <code>Laya3D</code> 类用于初始化3D设置。
 */
declare class Laya3D {
    /**物理创建管理器 */
    static _PhysicsCreateUtil: Laya.IPhysicsCreateUtil;
    /**
     * 设置物理创建管理器
     */
    static set PhysicsCreateUtil(value: Laya.IPhysicsCreateUtil);
    static get PhysicsCreateUtil(): Laya.IPhysicsCreateUtil;
    /**
     * 是否启用物理。
     * @param 是否启用物理。
     */
    static get enablePhysics(): any;
}
declare module Laya {
    /**
     *  Config 用于配置一些全局参数。如需更改，请在初始化引擎之前设置。
     */
    class Config {
        /**
        * 画布设置是否抗锯齿，只对2D(WebGL)有效,3D抗锯齿在camera或RT上面控制。
        */
        static isAntialias: boolean;
        /**
         * 是否使用webgl2
         */
        static useWebGL2: boolean;
        static FPS: number;
        /**
         * 是否使用视网膜模式，在iOS上面可能会创建更大的RT，来达到更佳的效果
         */
        static useRetinalCanvas: boolean;
        /**
         * 2D动画 Animation 的默认播放时间间隔，单位为毫秒。
         */
        static animationInterval: number;
        /**
           * 当使用webGL渲染2d的时候，每次创建vb是否直接分配足够64k个顶点的缓存。这样可以提高效率。
           */
        static webGL2D_MeshAllocMaxMem: boolean;
        static defaultFontSize: number;
        static defaultFont: string;
        /**
         * 设置画布是否透明，只对2D(WebGL)、3D有效。
         */
        static isAlpha: boolean;
        /**
         * 设置画布是否包含深度
         */
        static isDepth: boolean;
        /**
         * 表明在一个系统性能低的环境是否创建该上下文的boolean值
         */
        static isfailIfMajorPerformanceCaveat: boolean;
        static powerPreference: WebGLPowerPreference;
        /**
         * 设置画布是否预乘，只对2D(WebGL)、3D有效。
         */
        static premultipliedAlpha: boolean;
        /**
         * 设置画布的是否开启模板缓冲，只对2D(WebGL)、3D有效。
         */
        static isStencil: boolean;
        /**
         * 是否保留渲染缓冲区。
         */
        static preserveDrawingBuffer: boolean;
        /**
         * 是否打印Webgl指令，同时定位webgl报错
         */
        static printWebglOrder: boolean;
        /**在IOS下，一些字体会找不到，引擎提供了字体映射功能，比如默认会把 "黑体" 映射为 "黑体-简"，更多映射，可以自己添加*/
        static fontFamilyMap: any;
        /**tempConfig Fixed number of frames */
        static fixedFrames: boolean;
        static destroyResourceImmediatelyDefault: boolean;
    }
    /**
     * <code>Config3D</code> 类用于创建3D初始化配置。
     */
    class Config3D {
        /**
         * 控制是否动态合并
         */
        static enableDynamicBatch: boolean;
        /**
         * 是否静态合并
         */
        static enableStaticBatch: boolean;
        /**
         * 是否开启UniformBuffer
         */
        static enableUniformBufferObject: boolean;
        /**
         * 设置3DRT分辨率倍数
         */
        static pixelRatio: number;
        /**
         *  设置自定义分辨率
         */
        static customResolution: boolean;
        /**
         *  设置最大RendertexturePool缓存的值
         */
        static defaultCacheRTMemory: number;
        /**
         * 默认物理功能初始化内存，单位为M。
         */
        static defaultPhysicsMemory: number;
        /**
         *  是否开启多光源,如果场景不需要多光源，关闭后可提升性能。
         */
        static enableMultiLight: boolean;
        /**
         * 最大光源数量。
         */
        static maxLightCount: number;
        /**
        * X、Y、Z轴的光照集群数量,Z值会影响Cluster接受区域光(点光、聚光)影响的数量,Math.floor(2048 / lightClusterCount.z - 1) * 4 为每个Cluster的最大平均接受区域光数量,如果每个Cluster所接受光源影响的平均数量大于该值，则较远的Cluster会忽略其中多余的光照影响。
        */
        static lightClusterCount: Vector3;
        /**
         * 最大形变数量
         */
        static maxMorphTargetCount: number;
        /**
        * 设置分辨率大小（并不是实际渲染分辨率）
        * @param width
        * @param height
        */
        static setResolution(width: number, height: number): void;
        /**BVHRenderConfig */
        /**是否使用BVH裁剪 */
        static useBVHCull: boolean;
        /**一个BVH节点最大的cell数，超过这个数会分离 */
        static BVH_max_SpatialCount: number;
        /**最大BVH节点的大小 */
        static BVH_limit_size: number;
        /**最小cellbuild数，如果小于这个数，不会BVH构建 */
        static BVH_Min_Build_nums: number;
    }
    type FEnumDescriptor = {
        name: string;
        value: any;
        extend?: FEnumDescriptor;
        [index: string]: any;
    }[] | any[] | Object | string;
    type FPropertyType = string | Function | Object | [
        FPropertyType
    ] | [
        "Record",
        FPropertyType
    ];
    interface FPropertyDescriptor {
        /** 属性名称。一般不需要设定。 */
        name: string;
        /**
         * 属性类型。
         * 基础类型有：number,string,boolean,any，注意是使用字符串，不是类型。
         * 复合类型有：数组，使用类似["number"]这样的方式表达；字典，使用类似["Record", "number"]这样的方式表达，第一个元素固定为Record，第二个元素为实际类型。
         * 其他对象类型可以直接使用类名，但要注意该类必须有使用regClass装饰器。也支持枚举类型。枚举类型不需要regClass。
         * 如果不提供type，表示只用于ui样式，没有实际对应数据，和不会序列化
         */
        type: FPropertyType;
        /** 标题。如果不提供，则使用name。 */
        caption: string;
        /** 提示文字 */
        tips: string;
        /** 属性栏目。为多个属性设置相同的值，可以将它们显示在同一个Inspector栏目内。 */
        catalog: string;
        catalogCaption: string;
        catalogOrder: number;
        /**
         * 编辑这个属性的控件。内置有：number,string,boolean,color,vec2,vec3,vec4,asset
         *
         *      number : 数字输入。
         *      string : 字符串输入。默认为单行输入，如果是多行，需要激活multiline选项。
         *      boolean : 布尔值输入，用于单选框或多选框。
         *      color : 一个颜色框+调色盘+拾色器
         *      vec2 : XY输入的组合
         *      vec3 : XYZ输入的组合
         *      vec4 : XYZW输入的组合
         *      asset : 选择资源
         *
         * 一般来说，不需要设置这个选项，编辑器会自动根据属性类型选择适合的控件，但在某些情况下可以需要强制指定。
         * 例如，如果数据类型是Vector4，但其实它表达的是颜色，用默认编辑Vector4的控件不适合，需要在这里设置为“color”。
         *
         * 显式设置inspector为null，则不会为属性构造inspector。这与hidden设置为true不同。hidden为true是创建但不可见，
         * inspector为null的话则是完全不创建。
         */
        inspector: string;
        /** 隐藏控制:true隐藏，false显示。常用于关联属性的情况。
         * 1. 可以用表达式，通过将条件表达式放到字符串里，获得布尔类型的运算结果，例如"!data.a && !data.b"，表示属性a和属性b均为空时，条件成立（true），隐藏这个属性。
         * 2. 这里的data为当前组件的对象数据，data.a与data.b属性字段的a与b就是指当前组件中的a与b属性值，通过这种方法取到组件对象数据中的属性值，用于条件判断，作用于当前属性是否隐藏。
         */
        hidden: boolean | string;
        /** 只读控制。
         * 1. 可以用表达式，通过将条件表达式放到字符串里，获得布尔类型的运算结果，例如"!data.a && !data.b"，表示属性a和属性b均为空时，条件成立（true），该属性只读。
         * 2. 这里的data为当前组件的对象数据，data.a与data.b属性字段的a与b就是指当前组件中的a与b属性值，通过这种方法取到组件对象数据中的属性值，用于条件判断，作用于当前属性是否隐藏。
         */
        readonly: boolean | string;
        /** 数据检查机制。
         * 1. 将包括表达式的字符串传入，用于判断检查是否符合表达式的条件。符合条件，需要返回报错信息。
         * 2. 使用示例为："if(value == data.a) return '不能与a的值相同'"
         * 其中的value为当前用户在该属性输入的值，data为当前组件的对象数据，data.a是当前组件中的a属性值
         */
        validator: string;
        /** 是否允许数据为空值。
         * 可以用表达式，返回true或者false的结果。
         */
        required: boolean | string;
        /** 是否序列化 */
        serializable: boolean;
        /** 属性在不参与序列化时，如果它的数据可能受其他可序列化的属性影响，在这里填写其他属性名称。这通常用于判断预制体属性是否覆盖。*/
        affectBy: string;
        /** 默认值。这个值只在面板中使用，它指从界面上创建对象时赋予属性的初始值。*/
        init: any;
        /** 是否多行文本输入 */
        multiline: boolean;
        /** 是否密码输入 */
        password: boolean;
        /** 如果true或者缺省，文本输入每次输入都提交；否则只有在失焦时才提交 */
        submitOnTyping: boolean;
        /** 如果是文本类型，是输入文本的提示信息；如果是布尔类型，是多选框的标题。 */
        prompt: string;
        /** 定义枚举 */
        enumSource: FEnumDescriptor;
        /** 当数据源为空时，隐藏这个属性 */
        hideIfEnumSourceEmpty: boolean;
        /** 是否反转布尔值。例如当属性值为true时，多选框显示为不勾选。 */
        reverseBool: boolean;
        /** 是否允许null值。默认为true。*/
        nullable: boolean;
        /** 数字的最小值 */
        min: number;
        /** 数字的最大值 */
        max: number;
        /** 数值范围，等同于一次性设置min和max。 */
        range: [
            number,
            number
        ];
        /** 拖动方式改变数值时，每次数值改变的幅度。 */
        step: number;
        /** 小数点后的位数 */
        fractionDigits: number;
        /** 显示为百分比 */
        percentage: boolean;
        /** 对数组类型属性适用。表示数组是固定长度，不允许修改。*/
        fixedLength: boolean;
        /** 对数组类型属性适用。如果不提供，则表示数组允许所有操作，如果提供，则只允许列出的操作。*/
        arrayActions: Array<"append" | "insert" | "delete" | "move">;
        /** 对数组类型属性适用。这里可以定义数组元素的属性 */
        elementProps: Partial<FPropertyDescriptor>;
        /** 对颜色类型属性适用。表示是否提供透明度a值的修改。 */
        showAlpha: boolean;
        /** 对颜色类型属性适用。它与default值不同的是，当default是null时，可以用defaultColor定义一个非null时的默认值。*/
        defaultColor: any;
        /** 对颜色类型属性适用。允许显示一个checkbox决定颜色是否为null。 */
        colorNullable: boolean;
        /** 对对象类型属性适用。如果为true，隐藏对象的标题，同时对象下的属性的显示缩进会减少一级。*/
        hideHeader: boolean;
        /** 对对象类型属性适用。对象创建时可以下拉选择一个类型。如果显示设置为null，则禁止菜单。默认是显示一个创建基类的菜单。*/
        createObjectMenu: Array<string>;
        /** 对对象类型属性适用。表示这个属性类型有类似结构体的行为特性，即总是作为一个整体使用。
         * 例如，obj对象的某个属性b的值是a1，a1是T类型的实例，且T类型的structLike为true，那么当a1的属性改变时，编辑器将同时调用obj.b = a1。
         * 默认为false。
         */
        structLike: boolean;
        /** 说明此属性是引用一个资源 */
        isAsset: boolean;
        /** 对资源类型的属性适用。多个资源类型用逗号分隔，例如“Image,Audio"。*/
        assetTypeFilter: string;
        /** 如果属性类型是string，并且进行资源选择时，这个选项决定属性值是资源原始路径还是res://uuid这样的格式。如果是true，则是资源原始路径。默认false。*/
        useAssetPath: boolean;
        /** 对资源类型的属性适用。选择资源时是否允许选择内部资源 */
        allowInternalAssets: boolean;
        /** 对资源类型的属性适用。可以设置一个自定义的过滤器。过滤器需要先通过EditorEnv.assetMgr.customAssetFilters注册。 */
        customAssetFilter: string;
        /** 对类型是Node或者Component的属性适用。如果不为null，当在实际运行环境里执行反序列化时，引用对象不再实例化，而是将它的序列化数据原样保存到指定的属性中。*/
        toTemplate: string;
        /** 显示位置。语法：before xxx/after xxx/first/last。 */
        position: string;
        /** 表示属性是私有属性。私有属性不会显示在Inspector里，但会序列化保存。 */
        "private": boolean;
        /** 增加缩进，单位是层级，不是像素。 */
        addIndent: number;
        /** 表示属性是否允许多选情况下编辑。默认true。 */
        allowMultipleObjects: boolean;
        /** 表示属性不显示在派生类的属性表中 */
        hideInDeriveType: boolean;
        /** 属性改变时额外调用对象的一个函数，这里是函数名称。
         * 函数原型是func(key?:string)。其中key在改变成员内部属性时会传递。
         * 例如改变数据某个元素的内部属性，则key是这个元素的索引。
         */
        onChange: string;
        /** 额外的选项 */
        options: Record<string, any>;
    }
    interface FTypeDescriptor {
        /** 标题。如果不提供，则使用name。 */
        caption: string;
        /**帮助文档url地址 */
        help: string;
        /** 添加到组件菜单。 */
        menu: string;
        /** 图标。*/
        icon: string;
        /** 是否资源类型 */
        isAsset: boolean;
        /** 对资源类型的属性适用。多个资源类型用逗号分隔，例如“Image,Audio"。可用值参考editor/public/IAssetInfo.ts。 */
        assetTypeFilter: string;
        /** 表示这个类型有类似结构体的行为特性，即总是作为一个整体使用。
         * 例如，obj对象的某个属性b的值是a1，a1是T类型的实例，且T类型的structLike为true，那么当a1的属性改变时，编辑器将同时调用obj.b = a1。
         * 默认为false。
         */
        structLike: boolean;
        /** 属性列表 */
        properties: Array<Partial<FPropertyDescriptor>>;
        /** 编辑这个类实例的控件 */
        inspector: string;
        /** 对Component使用，表示这个组件允许挂载的节点类型。默认null */
        worldType: "2d" | "3d" | null;
        /** 对Component使用，如果为true，并且定义了menu属性，则这个组件还会显示在层级面板的新建对象菜单上。 */
        inHierarchyMenu: boolean;
        /** 额外的选项 */
        options: Record<string, any>;
    }
    /**
     * 注册一个类型，注册后才能被序列化系统自动保存和载入。
     */
    function regClass(assetId?: string): any;
    /**
     * 设置类型的额外信息。
     * @param info 类型的额外信息
     */
    function classInfo(info?: Partial<FTypeDescriptor>): any;
    /**
     * 设置组件可以在编辑器环境中执行完整声明周期。
     */
    function runInEditor(constructor: Function): void;
    /**
     * 使用这个装饰器，可以使属性显示在编辑器属性设置面板上，并且能序列化保存。
     * @param info 属性的类型，如: Number,"number",[Number],["Record", Number]等。或传递对象描述详细信息，例如{ type: "string", multiline: true }。
     */
    function property(info: FPropertyType | Partial<FPropertyDescriptor>): any;
    /**开始播放时调度。
     * @eventType Event.PLAYED
     * */
    /**暂停时调度。
     * @eventType Event.PAUSED
     * */
    /**完成一次循环时调度。
     * @eventType Event.COMPLETE
     * */
    /**停止时调度。
     * @eventType Event.STOPPED
     * */
    /**
     * <code>AnimationPlayer</code> 类用于动画播放器。
     */
    class AnimationPlayer extends EventDispatcher {
        /**是否缓存*/
        isCache: boolean;
        /** 播放速率*/
        playbackRate: number;
        /** 停止时是否归零*/
        returnToZeroStopped: boolean;
        /**
         * 获取动画数据模板
         * @param	value 动画数据模板
         */
        get templet(): AnimationTemplet;
        /**
         * 设置动画数据模板,注意：修改此值会有计算开销。
         * @param	value 动画数据模板
         */
        set templet(value: AnimationTemplet);
        /**
         * 动画播放的起始时间位置。
         * @return	 起始时间位置。
         */
        get playStart(): number;
        /**
         * 动画播放的结束时间位置。
         * @return	 结束时间位置。
         */
        get playEnd(): number;
        /**
         * 获取动画播放一次的总时间
         * @return	 动画播放一次的总时间
         */
        get playDuration(): number;
        /**
         * 获取动画播放的总总时间
         * @return	 动画播放的总时间
         */
        get overallDuration(): number;
        /**
         * 获取当前动画索引
         * @return	value 当前动画索引
         */
        get currentAnimationClipIndex(): number;
        /**
         * 获取当前帧数
         * @return	 当前帧数
         */
        get currentKeyframeIndex(): number;
        /**
         *  获取当前精确时间，不包括重播时间
         * @return	value 当前时间
         */
        get currentPlayTime(): number;
        /**
         *  获取当前帧时间，不包括重播时间
         * @return	value 当前时间
         */
        get currentFrameTime(): number;
        /**
         *  获取缓存播放速率。*
         * @return	 缓存播放速率。
         */
        get cachePlayRate(): number;
        /**
         *  设置缓存播放速率,默认值为1.0,注意：修改此值会有计算开销。*
         * @return	value 缓存播放速率。
         */
        set cachePlayRate(value: number);
        /**
         *  获取默认帧率*
         * @return	value 默认帧率
         */
        get cacheFrameRate(): number;
        /**
         *  设置默认帧率,每秒60帧,注意：修改此值会有计算开销。*
         * @return	value 缓存帧率
         */
        set cacheFrameRate(value: number);
        /**
         * 设置当前播放位置
         * @param	value 当前时间
         */
        set currentTime(value: number);
        /**
         * 获取当前是否暂停
         * @return	是否暂停
         */
        get paused(): boolean;
        /**
         * 设置是否暂停
         * @param	value 是否暂停
         */
        set paused(value: boolean);
        /**
         * 获取缓存帧率间隔时间
         * @return	缓存帧率间隔时间
         */
        get cacheFrameRateInterval(): number;
        /**
         * 获取当前播放状态
         * @return	当前播放状态
         */
        get state(): number;
        /**
         * 获取是否已销毁。
         * @return 是否已销毁。
         */
        get destroyed(): boolean;
        /**
         * 创建一个 <code>AnimationPlayer</code> 实例。
         */
        constructor();
        /**
         * @private
         */
        private _setPlayParams;
        /**
         * 动画停止了对应的参数。目前都是设置时间为最后
         * @private
         */
        private _setPlayParamsWhenStop;
        /**
         * 播放动画。
         * @param	index 动画索引。
         * @param	playbackRate 播放速率。
         * @param	duration 播放时长（0为1次,Number.MAX_VALUE为循环播放）。
         * @param	playStart 播放的起始时间位置。
         * @param	playEnd 播放的结束时间位置。（0为动画一次循环的最长结束时间位置）。
         */
        play(index?: number, playbackRate?: number, overallDuration?: number, playStart?: number, playEnd?: number): void;
        /**
         * 播放动画。
         * @param	index 动画索引。
         * @param	playbackRate 播放速率。
         * @param	duration 播放时长（0为1次,Number.MAX_VALUE为循环播放）。
         * @param	playStartFrame 播放的原始起始帧率位置。
         * @param	playEndFrame 播放的原始结束帧率位置。（0为动画一次循环的最长结束时间位置）。
         */
        playByFrame(index?: number, playbackRate?: number, overallDuration?: number, playStartFrame?: number, playEndFrame?: number, fpsIn3DBuilder?: number): void;
        /**
         * 停止播放当前动画
         * 如果不是立即停止就等待动画播放完成后再停止
         * @param	immediate 是否立即停止
         */
        stop(immediate?: boolean): void;
        /**
         * @private
         */
        destroy(): void;
    }
    /**
     * <code>AnimationTemplet</code> 类用于动画模板资源。
     */
    class AnimationTemplet extends Resource {
        /**插值函数 */
        static interpolation: any[];
        /**
         * @private
         */
        private static _LinearInterpolation_0;
        /**
         * @private
         */
        private static _QuaternionInterpolation_1;
        /**
         * @private
         */
        private static _AngleInterpolation_2;
        /**
         * @private
         */
        private static _RadiansInterpolation_3;
        /**
         * @private
         */
        private static _Matrix4x4Interpolation_4;
        /**
         * @private
         */
        private static _NoInterpolation_5;
        /**
         * @private
         */
        private static _BezierInterpolation_6;
        /**
         * @private
         */
        private static _BezierInterpolation_7;
        /**@private */
        protected unfixedCurrentFrameIndexes: Uint32Array;
        /**@private */
        protected unfixedCurrentTimes: Float32Array;
        /**@private */
        protected unfixedKeyframes: KeyFramesContent[];
        /**@private */
        protected unfixedLastAniIndex: number;
        /**@private */
        private _boneCurKeyFrm;
        constructor();
        /**
         * 获取动画数量
         */
        getAnimationCount(): number;
        /**
         * 通过索引获取动画
         * @param aniIndex
         */
        getAnimation(aniIndex: number): any;
        /**
         * 获取动画时长
         * @param aniIndex
         */
        getAniDuration(aniIndex: number): number;
        /**获取动画nodes信息 */
        getNodes(aniIndex: number): any;
        /**获取动画骨骼信息 */
        getNodeIndexWithName(aniIndex: number, name: string): number;
        /**获取nodes长度 */
        getNodeCount(aniIndex: number): number;
        /**获取keyframes长度 */
        getTotalkeyframesLength(aniIndex: number): number;
        /**获取附加数据 */
        getPublicExtData(): ArrayBuffer;
        /**获取动画信息数据 */
        getAnimationDataWithCache(key: any, cacheDatas: any, aniIndex: number, frameIndex: number): Float32Array;
        /**设置动画信息数据 */
        setAnimationDataWithCache(key: any, cacheDatas: any[], aniIndex: number, frameIndex: number, data: any): void;
        /**
         * 计算当前时间应该对应关键帧的哪一帧
         * @param	nodeframes	当前骨骼的关键帧数据
         * @param	nodeid		骨骼id，因为要使用和更新 _boneCurKeyFrm
         * @param	tm
         * @return
         * 问题
         * 	最后一帧有问题，例如倒数第二帧时间是0.033ms,则后两帧非常靠近，当实际给最后一帧的时候，根据帧数计算出的时间实际上落在倒数第二帧
         *  	使用与AnimationPlayer一致的累积时间就行
         */
        getNodeKeyFrame(nodeframes: KeyFramesContent[], nodeid: number, tm: number): number;
        /**
         * 获取原始数据
         * @param	aniIndex
         * @param	originalData
         * @param	nodesFrameIndices
         * @param	frameIndex
         * @param	playCurTime
         */
        getOriginalData(aniIndex: number, originalData: Float32Array, nodesFrameIndices: any[], frameIndex: number, playCurTime: number): void;
        /**获取nodes信息 */
        getNodesCurrentFrameIndex(aniIndex: number, playCurTime: number): Uint32Array;
        /**获取原始数据 */
        getOriginalDataUnfixedRate(aniIndex: number, originalData: Float32Array, playCurTime: number): void;
    }
    /**
     * @private
     */
    class Bone {
        static ShowBones: any;
        name: string;
        root: Bone;
        parentBone: Bone;
        length: number;
        transform: Transform;
        resultTransform: Transform;
        resultMatrix: Matrix;
        inheritScale: boolean;
        inheritRotation: boolean;
        rotation: number;
        resultRotation: number;
        d: number;
        constructor();
        setTempMatrix(matrix: Matrix): void;
        update(pMatrix?: Matrix | null): void;
        updateChild(): void;
        setRotation(rd: number): void;
        updateDraw(x: number, y: number): void;
        addChild(bone: Bone): void;
        findBone(boneName: string): Bone | null;
        localToWorld(local: number[]): void;
    }
    class BoneSlot {
        /** 插槽名称 */
        name: string;
        /** 插槽绑定的骨骼名称 */
        parent: string;
        /** 插糟显示数据数据的名称 */
        attachmentName: string;
        /** 原始数据的索引 */
        srcDisplayIndex: number;
        /** 判断对象是否是原对象 */
        type: string;
        /** 模板的指针 */
        templet: Templet;
        /** 当前插槽对应的数据 */
        currSlotData: SlotData;
        /** 当前插槽显示的纹理 */
        currTexture: Texture | null;
        /** 显示对象对应的数据 */
        currDisplayData: SkinSlotDisplayData | null;
        /** 显示皮肤的索引 */
        displayIndex: number;
        /** @private */
        originalIndex: number;
        /** @private 变形动画数据 */
        deformData: any[];
        /**
         * 设置要显示的插槽数据
         * @param	slotData
         * @param	disIndex
         * @param	freshIndex 是否重置纹理
         */
        showSlotData(slotData: SlotData, freshIndex?: boolean): void;
        /**
         * 通过名字显示指定对象
         * @param	name
         */
        showDisplayByName(name: string): void;
        /**
         * 替换贴图名
         * @param	tarName 要替换的贴图名
         * @param	newName 替换后的贴图名
         */
        replaceDisplayByName(tarName: string, newName: string): void;
        /**
         * 替换贴图索引
         * @param	tarIndex 要替换的索引
         * @param	newIndex 替换后的索引
         */
        replaceDisplayByIndex(tarIndex: number, newIndex: number): void;
        /**
         * 指定显示对象
         * @param	index
         */
        showDisplayByIndex(index: number): void;
        /**
         * 替换皮肤
         * @param	_texture
         */
        replaceSkin(_texture: Texture): void;
        /**
         * 保存父矩阵的索引
         * @param	parentMatrix
         */
        setParentMatrix(parentMatrix: Matrix): void;
        private _mVerticleArr;
        private static _tempMatrix;
        static createSkinMesh(): any;
        private static isSameArr;
        private getSaveVerticle;
        static isSameMatrix(mtA: Matrix, mtB: Matrix): boolean;
        private _preGraphicMatrix;
        private static useSameMatrixAndVerticle;
        private getSaveMatrix;
        /**
         * 把纹理画到Graphics上
         * @param	graphics
         * @param	noUseSave   不使用共享的矩阵对象 _tempResultMatrix，只有实时计算的时候才设置为true
         */
        draw(graphics: GraphicsAni, boneMatrixArray: any[], noUseSave?: boolean, alpha?: number): void;
        /**
         * 显示蒙皮动画
         * @param	boneMatrixArray 当前帧的骨骼矩阵
         */
        private skinMesh;
        /**
         * 画骨骼的起始点，方便调试
         * @param	graphics
         */
        drawBonePoint(graphics: Graphics): void;
        /**
         * 得到显示对象的矩阵
         * @return
         */
        private getDisplayMatrix;
        /**
         * 得到插糟的矩阵
         * @return
         */
        getMatrix(): Matrix;
        /**
         * 用原始数据拷贝出一个
         * @return
         */
        copy(): BoneSlot;
    }
    /**
     * 网格数据
     */
    class MeshData {
        /**
         * 纹理
         */
        texture: Texture;
        /**
         * uv数据
         */
        uvs: Float32Array;
        /**
         * 顶点数据
         */
        vertices: Float32Array;
        /**
         * 顶点索引
         */
        indexes: Uint16Array;
        /**
         * uv变换矩阵
         */
        uvTransform: Matrix;
        /**
         * 是否有uv变化矩阵
         */
        useUvTransform: boolean;
        /**
         * 扩展像素,用来去除黑边
         */
        canvasPadding: number;
        /**
         * 计算mesh的Bounds
         * @return
         *
         */
        getBounds(): Rectangle;
    }
    /**
     * <code>Laya<code>
     */
    class SkinMeshForGraphic extends MeshData {
        /**
         * 创建SkinGraphic Mesh数据
         */
        constructor();
        /**
         * 矩阵
         */
        transform: Matrix | null;
        /**
         * 创建Texture MeshData
         * @param texture 纹理
         * @param ps 索引数据
         * @param verticles 顶点数据
         * @param uvs uv数据
         */
        init2(texture: Texture, ps: any[], verticles: any[], uvs: any[]): void;
    }
    /**
     * 事件数据
     */
    class EventData {
        /**事件名称 */
        name: string;
        /**整数数据 */
        intValue: number;
        /**单精度浮点数数据 */
        floatValue: number;
        /**字符串数据 */
        stringValue: string;
        /**多媒体数据 */
        audioValue: string;
        /**事件数据 */
        time: number;
        constructor();
    }
    /**动画开始播放调度
     * @eventType Event.PLAYED
     * */
    /**动画停止播放调度
     * @eventType Event.STOPPED
     * */
    /**动画暂停播放调度
     * @eventType Event.PAUSED
     * */
    /**自定义事件。
     * @eventType Event.LABEL
     */
    /**
     * 骨骼动画由<code>Templet</code>，<code>AnimationPlayer</code>，<code>Skeleton</code>三部分组成。
     */
    class Skeleton extends Sprite {
        protected _source: string;
        private _animationName;
        private _loop;
        /**
         * 创建一个Skeleton对象
    
         * @param	aniMode	动画模式，0不支持换装，1、2支持换装
         */
        constructor(aniMode?: number);
        /**
        * @private
        * 得到帧索引
        */
        get index(): number;
        /**
         * @private
         * 设置帧索引
         */
        set index(value: number);
        /**
         * 得到总帧数据
         */
        get total(): number;
        /**
         * 得到播放器的引用
         */
        get player(): AnimationPlayer;
        /**
         * 皮肤名字
         */
        get skinName(): string;
        set skinName(value: string);
        /**
         * 动画名字
         */
        get animationName(): string;
        set animationName(value: string);
        /**
         * 是否循环
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * 得到动画模板的引用
         * @return templet.
         */
        get templet(): Templet;
        set templet(value: Templet);
        /**
         * 得到动画地址
         * @return templet.
         */
        get source(): string;
        /**
         * 设置动画地址
         */
        set source(value: string);
        /**
         * 动画类型
         * <table>
         * 	<tr><th>模式</th><th>描述</th></tr>
         * 	<tr>
         * 		<td>0</td> <td>使用模板缓冲的数据，模板缓冲的数据，不允许修改（内存开销小，计算开销小，不支持换装）</td>
         * 	</tr>
         * 	<tr>
         * 		<td>1</td> <td>使用动画自己的缓冲区，每个动画都会有自己的缓冲区，相当耗费内存	（内存开销大，计算开销小，支持换装）</td>
         * 	</tr>
         * 	<tr>
         * 		<td>2</td> <td>使用动态方式，去实时去画（内存开销小，计算开销大，支持换装,不建议使用）</td>
         * </tr>
         * </table>
         */
        get aniMode(): number;
        set aniMode(value: number);
        /**
         * 初始化动画
         * @param	templet		模板
         */
        protected init(templet: Templet): void;
        /**
         * 通过加载直接创建动画
         * @param	path		要加载的动画文件路径
         * @param	complete	加载完成的回调函数
         */
        load(path: string, complete?: Handler): void;
        private _checkIsAllParsed;
        /*******************************************定义接口*************************************************/
        /**
         * 得到当前动画的数量
         * @return 当前动画的数量
         */
        getAnimNum(): number;
        /**
         * 得到指定动画的名字
         * @param	index	动画的索引
         */
        getAniNameByIndex(index: number): string;
        /**
         * 通过名字得到插槽的引用
         * @param	name	动画的名字
         * @return 插槽的引用
         */
        getSlotByName(name: string): BoneSlot;
        /**
         * 通过名字显示一套皮肤
         * @param	name	皮肤的名字
         * @param	freshSlotIndex	是否将插槽纹理重置到初始化状态
         */
        showSkinByName(name: string, freshSlotIndex?: boolean): void;
        /**
         * 通过索引显示一套皮肤
         * @param	skinIndex	皮肤索引
         * @param	freshSlotIndex	是否将插槽纹理重置到初始化状态
         */
        showSkinByIndex(skinIndex: number, freshSlotIndex?: boolean): void;
        /**
         * 设置某插槽的皮肤
         * @param	slotName	插槽名称
         * @param	index	插糟皮肤的索引
         */
        showSlotSkinByIndex(slotName: string, index: number): void;
        /**
         * 设置某插槽的皮肤
         * @param	slotName	插槽名称
         * @param	name	皮肤名称
         */
        showSlotSkinByName(slotName: string, name: string): void;
        /**
         * 替换插槽贴图名
         * @param	slotName 插槽名称
         * @param	oldName 要替换的贴图名
         * @param	newName 替换后的贴图名
         */
        replaceSlotSkinName(slotName: string, oldName: string, newName: string): void;
        /**
         * 替换插槽的贴图索引
         * @param	slotName 插槽名称
         * @param	oldIndex 要替换的索引
         * @param	newIndex 替换后的索引
         */
        replaceSlotSkinByIndex(slotName: string, oldIndex: number, newIndex: number): void;
        /**
         * 设置自定义皮肤
         * @param	name		插糟的名字
         * @param	texture		自定义的纹理
         */
        setSlotSkin(slotName: string, texture: Texture): void;
        /**
         * 播放动画
         *
         * @param	nameOrIndex	动画名字或者索引
         * @param	loop		是否循环播放
         * @param	force		false,如果要播的动画跟上一个相同就不生效,true,强制生效
         * @param	start		起始时间
         * @param	end			结束时间
         * @param	freshSkin	是否刷新皮肤数据
         * @param	playAudio	是否播放音频
         */
        play(nameOrIndex: any, loop: boolean, force?: boolean, start?: number, end?: number, freshSkin?: boolean, playAudio?: boolean): void;
        /**
         * 停止动画
         */
        stop(): void;
        /**
         * 设置动画播放速率
         * @param	value	1为标准速率
         */
        playbackRate(value: number): void;
        /**
         * 暂停动画的播放
         */
        paused(): void;
        /**
         * 恢复动画的播放
         */
        resume(): void;
        /**
         * 销毁当前动画
         * @override
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * 插槽显示数据
     */
    class SkinSlotDisplayData {
        /**名称 */
        name: string;
        /**附件名称 */
        attachmentName: string;
        /**类型 */
        type: number;
        /**变换 */
        transform: Transform;
        /**宽度 */
        width: number;
        /**高度 */
        height: number;
        /**纹理 */
        texture: Texture;
        /**骨骼数据 */
        bones: any[];
        /**uv数据 */
        uvs: any[];
        /**权重 */
        weights: any[];
        /**三角面数据 */
        triangles: any[];
        /**顶点数据 */
        vertices: any[];
        /**长度数据 */
        lengths: any[];
        /**版本号 */
        verLen: number;
        createTexture(currTexture: Texture): Texture;
        destory(): void;
    }
    class SlotData {
        name: string;
        displayArr: any[];
        /**
         * 通过附件名称获取位置
         * @param name
         */
        getDisplayByName(name: string): number;
    }
    /**
     * 动画模板类
     */
    class Templet extends AnimationTemplet {
        rate: number;
        /** 存放原始骨骼信息 */
        srcBoneMatrixArr: any[];
        /** IK数据 */
        ikArr: any[];
        /** transform数据 */
        tfArr: any[];
        /** path数据 */
        pathArr: any[];
        /** 存放插槽数据的字典 */
        boneSlotDic: any;
        /** 绑定插槽数据的字典 */
        bindBoneBoneSlotDic: any;
        /** 存放插糟数据的数组 */
        boneSlotArray: any[];
        /** 皮肤数据 */
        skinDataArray: any[];
        /** 皮肤的字典数据 */
        skinDic: any;
        /** 存放纹理数据 */
        subTextureDic: Record<string, Texture>;
        /** 是否解析失败 */
        isParseFail: boolean;
        /** 反转矩阵，有些骨骼动画要反转才能显示 */
        yReverseMatrix: Matrix;
        /** 渲染顺序动画数据 */
        drawOrderAniArr: any[];
        /** 事件动画数据 */
        eventAniArr: any[];
        /** @private 索引对应的名称 */
        attachmentNames: any[];
        /** 顶点动画数据 */
        deformAniArr: any[];
        /** 实际显示对象列表，用于销毁用 */
        skinSlotDisplayDataArr: SkinSlotDisplayData[];
        aniSectionDic: any;
        /**@private */
        tMatrixDataLen: number;
        mRootBone: Bone;
        mBoneArr: Bone[];
        /**
         * 创建动画
         * 0,使用模板缓冲的数据，模板缓冲的数据，不允许修改					（内存开销小，计算开销小，不支持换装）
         * 1,使用动画自己的缓冲区，每个动画都会有自己的缓冲区，相当耗费内存	（内存开销大，计算开销小，支持换装）
         * 2,使用动态方式，去实时去画										（内存开销小，计算开销大，支持换装,不建议使用）
         * @param	aniMode 0	动画模式，0:不支持换装,1,2支持换装
         * @return
         */
        buildArmature(aniMode?: number): Skeleton;
        _parse(texture: Texture, createURL: string, skeletonData: ArrayBuffer): void;
        /**
         * 得到指定的纹理
         * @param	name	纹理的名字
         * @return
         */
        getTexture(name: string): Texture;
        /**
         * @private
         * 显示指定的皮肤
         * @param	boneSlotDic	插糟字典的引用
         * @param	skinIndex	皮肤的索引
         * @param	freshDisplayIndex	是否重置插槽纹理
         */
        showSkinByIndex(boneSlotDic: any, skinIndex: number, freshDisplayIndex?: boolean): boolean;
        /**
         * 通过皮肤名字得到皮肤索引
         * @param	skinName 皮肤名称
         * @return
         */
        getSkinIndexByName(skinName: string): number;
        /**
         * @private
         * 得到缓冲数据
         * @param	aniIndex	动画索引
         * @param	frameIndex	帧索引
         * @return
         */
        getGrahicsDataWithCache(aniIndex: number, frameIndex: number): Graphics;
        /**
         * @private
         * 保存缓冲grahpics
         * @param	aniIndex	动画索引
         * @param	frameIndex	帧索引
         * @param	graphics	要保存的数据
         */
        setGrahicsDataWithCache(aniIndex: number, frameIndex: number, graphics: Graphics): void;
        deleteAniData(aniIndex: number): void;
        protected _disposeResource(): void;
        /***********************************下面为一些儿访问接口*****************************************/
        /**
         * 通过索引得动画名称
         * @param	index
         * @return
         */
        getAniNameByIndex(index: number): string;
    }
    class Transform {
        /**水平方向旋转角度 */
        skX: number;
        /**垂直方向旋转角度 */
        skY: number;
        /**水平方向缩放 */
        scX: number;
        /**垂直方向缩放 */
        scY: number;
        /**水平方向偏移 */
        x: number;
        /**垂直方向偏移 */
        y: number;
        /**水平方向倾斜角度 */
        skewX: number;
        /**垂直方向倾斜角度 */
        skewY: number;
        private mMatrix;
        /**
         * 初始化数据
         * @param data
         */
        initData(data: any): void;
        /**
         * 获取当前矩阵
         */
        getMatrix(): Matrix;
        /**
         * 获取倾斜矩阵
         * @param m
         * @param x
         * @param y
         */
        skew(m: Matrix, x: number, y: number): Matrix;
    }
    /**
     * Graphic动画
     */
    class GraphicsAni extends Graphics {
        /**
         * @private
         * 画自定义蒙皮动画
         * @param	skin
         */
        drawSkin(skinA: SkinMeshForGraphic, alpha: number): void;
        private static _caches;
        /**
         * 获取一个GraphicsAni
         * @returns
         */
        static create(): GraphicsAni;
        /**
         * 回收清理GraphicAni
         * @param graphics
         */
        static recycle(graphics: GraphicsAni): void;
    }
    /**
     * 关键帧
     */
    class KeyFramesContent {
        /**开始时间 */
        startTime: number;
        /**持续时间 */
        duration: number;
        /**私有插值方式 */
        interpolationData: any[];
        /**数据 */
        data: Float32Array;
        /**数据变化量 */
        dData: Float32Array;
        /**下一次的数据 */
        nextData: Float32Array;
    }
    /**
     * 动画播放完毕后调度。
     * @eventType Event.COMPLETE
     */
    /**
     * 播放到某标签后调度。
     * @eventType Event.LABEL
     */
    /**
     * 加载完成后调度。
     * @eventType Event.LOADED
     */
    /**
     * 进入帧后调度。
     * @eventType Event.FRAME
     */
    /**
     * <p> <code>MovieClip</code> 用于播放经过工具处理后的 swf 动画。</p>
     */
    class MovieClip extends Sprite {
        /**资源根目录。*/
        basePath: string;
        private _source;
        /** 播放间隔(单位：毫秒)。*/
        interval: number;
        /**是否循环播放 */
        loop: boolean;
        /**
         * 创建一个 <code>MovieClip</code> 实例。
         * @param parentMovieClip 父MovieClip,自己创建时不需要传该参数
         */
        constructor(parentMovieClip?: MovieClip);
        /**
         * <p>销毁此对象。以及销毁引用的Texture</p>
         * @param	destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
         * @override
         */
        destroy(destroyChild?: boolean): void;
        /**@private 更新时间轴*/
        updates(): void;
        /**当前播放索引。*/
        get index(): number;
        set index(value: number);
        /**
         * 增加一个标签到index帧上，播放到此index后会派发label事件
         * @param	label	标签名称
         * @param	index	索引位置
         */
        addLabel(label: string, index: number): void;
        /**
         * 删除某个标签
         * @param	label 标签名字，如果label为空，则删除所有Label
         */
        removeLabel(label: string): void;
        /**
         * 帧总数。
         */
        get count(): number;
        /**
         * 是否在播放中
         */
        get playing(): boolean;
        /**
         * 停止播放动画。
         */
        stop(): void;
        /**
         * 跳到某帧并停止播放动画。
         * @param frame 要跳到的帧
         */
        gotoAndStop(index: number): void;
        /**
         * 播放动画。
         * @param	index 帧索引。
         */
        play(index?: number, loop?: boolean): void;
        get source(): string;
        /**
         * 资源地址。
         */
        set source(value: string);
        /**
         * 加载资源。
         * @param	url swf 资源地址。
         * @param   atlas  是否使用图集资源
         * @param   atlasPath  图集路径，默认使用与swf同名的图集
         */
        load(url: string, atlas?: boolean, atlasPath?: string): void;
        /**
         * 从开始索引播放到结束索引，结束之后出发complete回调
         * @param	start	开始索引
         * @param	end		结束索引
         * @param	complete	结束回调
         */
        playTo(start: number, end: number, complete?: Handler): void;
    }
    /**
     * 动画条件类型
     */
    enum AniConditionType {
        /**
         * 大于
         */
        Greater = 0,
        /**
         * 小于
         */
        Less = 1,
        /**
         * 等于
         */
        Equals = 2,
        /**
         * 不等于
         */
        NotEqual = 3
    }
    /**
     * 2D动画类型
     */
    class Animation2DCondition {
        /**
         * id编号
         */
        id: number;
        /**
         * 动画条件
         */
        type: AniConditionType;
        /**
         * 检测值
         */
        checkValue: any;
    }
    /**
     * <code>Animation2DEvent</code> 类用于实现动画事件。
     */
    class Animation2DEvent {
        /** 事件触发时间。*/
        time: number;
        /** 事件触发名称。*/
        eventName: string;
        /** 事件触发参数。*/
        params: any[];
        /**
         * 创建一个 <code>Animation2DEvent</code> 实例。
         */
        constructor();
    }
    class Animation2DParm {
        name: string;
        type: AniParmType;
        value: boolean | number;
    }
    class AnimationClip2D extends Resource {
        /**
         * @param data
         * @returns
         */
        static _parse(data: ArrayBuffer): AnimationClip2D;
        /**
         * 动画补帧函数
         */
        static tween: {
            Linear: (t: number, b: number, c: number, d: number) => number;
            Quad_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Quad_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Quad_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            Cubic_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Cubic_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Cubic_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            Quart_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Quart_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Quart_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            Quint_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Quint_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Quint_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            Sine_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Sine_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Sine_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            Expo_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Expo_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Expo_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            Circ_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Circ_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Circ_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            Elastic_EaseIn: (t: number, b: number, c: number, d: number, a: number, p: number) => number;
            Elastic_EaseOut: (t: number, b: number, c: number, d: number, a: number, p: number) => number;
            Elastic_EaseInOut: (t: number, b: number, c: number, d: number, a: number, p: number) => number;
            Back_EaseIn: (t: number, b: number, c: number, d: number, s?: number) => number;
            Back_EaseOut: (t: number, b: number, c: number, d: number, s?: number) => number;
            Back_EaseInOut: (t: number, b: number, c: number, d: number, s?: number) => number;
            Bounce_EaseIn: (t: number, b: number, c: number, d: number) => number;
            Bounce_EaseOut: (t: number, b: number, c: number, d: number) => number;
            Bounce_EaseInOut: (t: number, b: number, c: number, d: number) => number;
            hermiteInterpolate: (outTangent: number, inTangent: number, startValue: number, endValue: number, t: number, dur: number) => number;
        };
        /**
         * 是否循环
         */
        islooping: boolean;
        /**
         * 实例化一个2D动画clip类
         */
        constructor();
        /**
         * 动画时长
         * @returns
         */
        duration(): number;
        /**
         * hermite插值算法
         * @param frameValue 上一帧值
         * @param frametime 上一帧事件
         * @param frameOutWeight 上一帧权重
         * @param frameOutTangent 上一帧切线
         * @param nextframeValue 下一帧值
         * @param nextframetime 下一帧时间
         * @param nextframeInweight 下一帧权重
         * @param nextframeIntangent 下一帧切线
         * @param time 时间
         * @returns
         */
        hermiteCurveSplineWeight(frameValue: number, frametime: number, frameOutWeight: number, frameOutTangent: number, nextframeValue: number, nextframetime: number, nextframeInweight: number, nextframeIntangent: number, time: number): number;
        /**
         * 添加动画事件。
         * @param event 动画事件
         */
        addEvent(event: Animation2DEvent): void;
    }
    /**
     * <code>AnimationClip2DParse01</code>
     * AnimationClip资源解析
     */
    class AnimationClip2DParse01 {
    }
    /**
     * <code>Animator2D<code/>2D动画组件
     */
    class Animator2D extends Component {
        /**
         * 实例化2D动画组件
         */
        constructor();
        /**
         * 2D动画控制器
         */
        set controller(val: AnimatorController2D);
        get controller(): AnimatorController2D;
        /**
         * 动画参数
         */
        set parameters(val: Record<string, Animation2DParm>);
        get parameters(): Record<string, Animation2DParm>;
        /**
         * 播放速度
         */
        set speed(num: number);
        get speed(): number;
        /**
         * 是否正在播放中
         */
        get isPlaying(): boolean;
        /**
         * 赋值Node数据
         * @param stateInfo 动画状态
         * @param additive 是否为addtive
         * @param weight state权重
         * @param isFirstLayer 是否是第一层
         */
        private _setClipDatasToNode;
        gotoAndStopByFrame(name: string, layerIndex: number, frame: number): void;
        gotoAndStop(name: string, layerIndex: number, normalizedTime: number): void;
        /**
         * 播放动画
         * @param name 动画名称
         * @param layerIndex 层索引
         * @param normalizedTime 归一化时间
         * @returns
         */
        play(name?: string, layerIndex?: number, normalizedTime?: number): void;
        /**
         * 停止播放动画
         */
        stop(): void;
        /**
         * 帧循环
         * @returns
         */
        onUpdate(): void;
        /**
         * 添加控制器层。
         */
        addControllerLayer(controllderLayer: AnimatorControllerLayer2D): void;
        /**
         * 在当前动画状态和目标动画状态之间进行融合过渡播放。
         * @param	name 目标动画状态。
         * @param	transitionDuration 过渡时间,该值为当前动画状态的归一化时间，值在0.0~1.0之间。
         * @param	layerIndex 层索引。
         * @param	normalizedTime 归一化的播放起始时间。
         */
        crossFade(name: string, transitionDuration: number, layerIndex?: number, normalizedTime?: number): boolean;
        /**
         * 默认状态机
         * @param layerIndex
         * @returns
         */
        getDefaultState(layerIndex?: number): AnimatorState2D;
        /**
         * 设置参数Trigger值
         * @param name 名字
         */
        setParamsTrigger(name: string): void;
        /**
         * 设置参数Number值
         * @param name 名字
         * @param value 值
         */
        setParamsNumber(name: string, value: number): void;
        /**
         * 设置参数Bool值
         * @param name 名字
         * @param value 值
         */
        setParamsBool(name: string, value: boolean): void;
        /**
         * 得到参数值
         * @param name 名字
         * @returns
         */
        getParamsvalue(name: number): number | boolean;
    }
    /**
     * <code>2D动画控制器<code/>
     */
    class AnimatorController2D extends Resource {
        /**
         * 实例化2D动画控制器
         * @param data
         */
        constructor(data: any);
        private _getAnimatorTransition2D;
    }
    class AnimatorControllerLayer2D implements IClone {
        /**混合模式_覆盖。 */
        static BLENDINGMODE_OVERRIDE: number;
        /**混合模式_叠加。 */
        static BLENDINGMODE_ADDTIVE: number;
        /**
         * 层的名字
         */
        name: string;
        /**
         * 是否开始时播放
         */
        playOnWake: boolean;
        /**
         * 默认权重
         */
        defaultWeight: number;
        /**
         * 混合模式
         */
        blendingMode: number;
        /**
         * 是否开启
         */
        enable: boolean;
        /**
         * 实例化一个2D动画控制器
         * @param name
         */
        constructor(name: string);
        /**
         * 设置状态机
         */
        set states(states: ReadonlyArray<AnimatorState2D>);
        get states(): ReadonlyArray<AnimatorState2D>;
        /**
         * 默认状态名称
         */
        set defaultStateName(str: string);
        get defaultStateName(): string;
        /**
         * 默认动画状态机。
         */
        get defaultState(): AnimatorState2D;
        set defaultState(value: AnimatorState2D);
        /**
         * 移除Clip
         * @param clipStateInfos
         * @param index
         * @param state
         */
        private _removeClip;
        /**
        * 获取当前的播放状态。
        * @return 动画播放状态。
        */
        getCurrentPlayState(): AnimatorPlayState2D;
        /**
         * 状态机名称
         * @param str
         * @returns
         */
        getStateByName(str: string): AnimatorState2D;
        /**
         * 添加动画状态。
         * @param	state 动画状态。
         * @param   layerIndex 层索引。
         */
        addState(state: AnimatorState2D): void;
        /**
         * 移除动画状态。
         * @param	state 动画状态。
         * @param   layerIndex 层索引。
         */
        removeState(state: AnimatorState2D): void;
        /**
             * 克隆。
             * @return	 克隆副本。
             */
        clone(): AnimatorControllerLayer2D;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 销毁
         */
        destroy(): void;
    }
    interface TypeAnimatorControllerData {
        layerW: number;
        controllerLayers: TypeAnimatorLayer[];
        cullingMode?: number;
        enable?: boolean;
        animatorParams?: TypeAnimatorParams[];
    }
    interface TypeAnimatorParams {
        id: number;
        name: string;
        type: AniParmType;
        val: number | boolean;
    }
    interface TypeAnimatorLayer {
        defaultStateName?: string;
        name: string;
        blendingMode: number;
        states: TypeAnimatorState[];
        playOnWake: boolean;
        defaultWeight: number;
        avatarMask?: any;
        stageX?: number;
        stageY?: number;
        stageScale?: number;
    }
    enum AniParmType {
        Float = 0,
        Bool = 1,
        Trigger = 2
    }
    /**
     * 动画状态条件类型
     */
    enum AniStateConditionType {
        Number = 0,
        Bool = 1,
        Trigger = 2
    }
    interface TypeAnimatorState {
        x: number;
        y: number;
        /**-1代表enter，-2代表exit，-3代表anyState */
        id: string;
        name: string;
        speed?: number;
        clipStart?: number;
        clipEnd?: number;
        loop?: number;
        yoyo?: boolean;
        soloTransitions?: TypeAnimatorTransition[];
        clip?: {
            _$uuid: string;
        };
        scripts?: string[];
        states?: TypeAnimatorState[];
        defaultStateName?: string;
        stageX?: number;
        stageY?: number;
        stageScale?: number;
    }
    interface TypeAnimatorTransition {
        id: string;
        name?: string;
        mute?: boolean;
        solo?: boolean;
        exitTime?: number;
        transduration?: number;
        transstartoffset?: number;
        exitByTime?: boolean;
        conditions?: TypeAnimatorConditions[];
    }
    interface TypeAnimatorConditions {
        id?: number;
        type?: AniStateConditionNumberCompressType;
        checkValue?: number | boolean;
        name?: string;
    }
    enum AniStateConditionNumberCompressType {
        Less = 0,
        Greater = 1
    }
    class AnimatorControllerParse {
        static parse(data: TypeAnimatorControllerData): {
            ret: TypeAnimatorControllerData;
            clipsID: string[];
        };
        private static checkStates;
        private static checkNext;
        private static checkConditions;
        private static checkDefault;
        private static getStateByID;
    }
    class AnimatorPlayState2D {
        _finish: boolean;
        /**播放总时间，不受speed为负数的影响 */
        _playAllTime: number;
        /**是为正向播放 */
        _frontPlay: boolean;
        /**
         * 当前动画的持续时间，以秒为单位。
         */
        get duration(): number;
        /**
         * 动画状态机。
         */
        get animatorState(): AnimatorState2D;
        /**
         * 创建一个 <code>AnimatorPlayState</code> 实例。
         */
        constructor();
    }
    /**
     * <code>Animator</code> 类用于创建动画组件。
     */
    class AnimatorState2D extends EventDispatcher implements IClone {
        /**play on awake start offset*/
        cycleOffset: number;
        /**
         * 名称
         */
        name: string;
        /**
         * 动画播放速度
         */
        speed: number;
        /**
         * 动作播放起始时间。
         */
        clipStart: number;
        /**
         * 动作播放结束时间。
         */
        clipEnd: number;
        /**
         *  动画循环次数，-1或者小于-1为使用clip的循环状态，1为播放一次，2为播放2次，0为无限循环
         */
        loop: number;
        /**
         * 是否为一次正播放，一次倒播放模式
         */
        yoyo: boolean;
        /**
         * 动作。
         */
        get clip(): AnimationClip2D | null;
        set clip(value: AnimationClip2D | null);
        /**
         * 添加脚本。
         * @param	type  组件类型。
         * @return 脚本。
         */
        addScript(type: typeof AnimatorState2DScript): AnimatorState2DScript;
        /**
         * 获取脚本。
         * @param	type  组件类型。
         * @return 脚本。
         */
        getScript(type: typeof AnimatorState2DScript): AnimatorState2DScript | null;
        /**
         * 获取脚本集合。
         * @param	type  组件类型。
         * @return 脚本集合。
         */
        getScripts(type: typeof AnimatorState2DScript): AnimatorState2DScript[] | null;
        /**
         * 克隆
         * @returns
         */
        clone(): AnimatorState2D;
        /**
         * 拷贝到目标
         * @param destObject 目标节点
         */
        cloneTo(destObject: any): void;
        /**
         * 删除
         */
        destroy(): void;
    }
    /**
     * <code>AnimatorStateScript</code> 类用于动画状态脚本的父类,该类为抽象类,不允许实例。
     */
    class AnimatorState2DScript {
        /**
         * 创建一个新的 <code>AnimatorStateScript</code> 实例。
         */
        constructor();
        /**
         * 动画状态开始时执行。
         */
        onStateEnter(): void;
        /**
         * 动画状态运行中
         * @param normalizeTime 0-1动画播放状态
         */
        onStateUpdate(normalizeTime: number): void;
        /**
         * 动画状态退出时执行。
         */
        onStateExit(): void;
        /**
         * 动画设置了循环的话，每次循环结束时执行
         */
        onStateLoop(): void;
    }
    class AnimatorStateCondition {
        /**
         * 通过名称获得唯一ID。
         * @param name Shader属性名称。
         * @return 唯一ID。
         */
        static conditionNameToID(name: string): number;
        /**
         * 通过ID获得唯一名称。
         * @param id
         * @returns
         */
        static conditionIDToName(id: number): string;
        /**
         * @intenral
         */
        private _name;
        /**
         * 状态机过渡条件
         */
        constructor(name?: string);
        /**
         * 唯一ID
         */
        get id(): number;
        /**
         * 名称
         */
        get name(): string;
        set name(value: string);
        /**
         * 条件类型
         */
        get type(): AniStateConditionType;
        /**
         * 检查状态是否触发
         * @param value
         * @returns
         */
        checkState(value: number | boolean): boolean;
    }
    class AnimatorStateNumberCondition extends AnimatorStateCondition {
        /**
         * 创建number比较条件类
         * @param name
         */
        constructor(name: string);
        /**
         * number值
         */
        get numberValue(): number;
        set numberValue(value: number);
        /**
         * 判断类型
         */
        get compareFlag(): AniStateConditionNumberCompressType;
        set compareFlag(value: AniStateConditionNumberCompressType);
        /**
         * 检查状态是否触发
         * @param value
         * @returns
         */
        checkState(value: number): boolean;
    }
    class AnimatorStateBoolCondition extends AnimatorStateCondition {
        /**
         * 创建bool比较条件类
         * @param name
         */
        constructor(name: string);
        /**
         * 判断类型
         */
        get compareFlag(): boolean;
        set compareFlag(value: boolean);
        /**
         * 检查状态是否触发
         * @param value
         * @returns
         */
        checkState(value: boolean): boolean;
    }
    class AnimatorStateTriggerCondition extends AnimatorStateCondition {
        /**
         * 创建trigger比较条件类
         * @param name
         */
        constructor(name: string);
        /**
         * 检查状态是否触发,tigger 如果是true,就算条件达成
         * @param value
         * @returns
         */
        checkState(value: boolean): boolean;
    }
    class AnimatorTransition2D {
        mute: boolean;
        exitTime: number;
        exitByTime: boolean;
        transstartoffset: number;
        transduration: number;
        conditions: AnimatorStateCondition[];
        destState: AnimatorState2D;
        /**
         * 创建一个新的Animatortransition2D
         */
        constructor();
        /**
         * 增加一个条件
         * @param condition
         */
        addCondition(condition: AnimatorStateCondition): void;
        /**
         * 删除一个条件
         * @param condition
         */
        removeCondition(condition: AnimatorStateCondition): void;
        /**
        * 是否启用过渡
        * @param normalizeTime
        * @param paramsMap
        */
        check(normalizeTime: number, paramsMap: Record<string, Animation2DParm>, isReplay: boolean): boolean;
    }
    /**
     * 动画更新模式
     */
    enum AnimatorUpdateMode {
        /**正常更新。*/
        Normal = 0,
        /**低频率更新 */
        LowFrame = 1,
        /**不更新 */
        UnScaleTime = 2
    }
    /**
     * <code>Component</code> 类用于创建组件的基类。
     */
    class Component {
        /** @private */
        _id: number;
        /**@private */
        private _hideFlags;
        /**@private */
        private _enableState;
        /**
         * 获取所属Node节点。
         */
        owner: Node;
        /**
         * 是否单例，即同一个节点只能添加此类型的脚本一次
         */
        _singleton?: boolean;
        /**
         * 是否可以在IDE环境中运行
         */
        runInEditor: boolean;
        scriptPath: string;
        _extra: IComponentExtra;
        get hideFlags(): number;
        set hideFlags(value: number);
        /**
         * 创建一个新的 <code>Component</code> 实例。
         */
        constructor();
        hasHideFlag(flag: number): boolean;
        /**
         * 唯一标识ID。
         */
        get id(): number;
        /**
         * 是否启用组件。
         */
        get enabled(): boolean;
        set enabled(value: boolean);
        get awaked(): boolean;
        /**
         * 是否已经销毁 。
         */
        get destroyed(): boolean;
        _setOwner(node: Node): void;
        protected setupScript(): void;
        /**
         * 销毁组件
         */
        destroy(): void;
        /**
         * 被添加到节点后调用，和Awake不同的是即使节点未激活onAdded也会调用。
         */
        onAdded(): void;
        /**
         * 重置组件参数到默认值，如果实现了这个函数，则组件会被重置并且自动回收到对象池，方便下次复用
         * 如果没有重置，则不进行回收复用
    
         */
        onReset?(): void;
        /**
         * 组件被激活后执行，此时所有节点和组件均已创建完毕，次方法只执行一次
         */
        onAwake(): void;
        /**
         * 组件被启用后执行，比如节点被添加到舞台后
         */
        onEnable(): void;
        /**
         * 第一次执行update之前执行，只会执行一次
         */
        onStart?(): void;
        /**
         * 每帧更新时执行，尽量不要在这里写大循环逻辑或者使用getComponent方法
         */
        onUpdate?(): void;
        /**
         * 每帧更新时执行，在update之后执行，尽量不要在这里写大循环逻辑或者使用getComponent方法
         */
        onLateUpdate?(): void;
        /**
         * 渲染之前执行
         */
        onPreRender?(): void;
        /**
         * 渲染之后执行
         */
        onPostRender?(): void;
        /**
         * 组件被禁用时执行，比如从节点从舞台移除后
         */
        onDisable(): void;
        /**
         * 手动调用节点销毁时执行
         */
        onDestroy(): void;
    }
    interface IComponentExtra {
    }
    class ComponentDriver {
        private _onUpdates;
        private _onLateUpdates;
        private _onPreRenders;
        private _onPostRenders;
        private _toStarts;
        readonly _toDestroys: Set<Component>;
        /**
         *
         * @param err 错误
         */
        onError(err: any): void;
    }
    interface TypeAniKey {
        /**第几帧 */
        f: number;
        val: number | string | boolean;
        /**目前用于2D动画，用于记录动画补间的类型，比如(Linear|Quad_EaseIn)... */
        tweenType?: string;
        /**扩展，如果有一些其它数据需要加入到关键帧中可以写在这里 */
        extend?: any;
        /**tween的信息 */
        tweenInfo?: TypeTweenInfo;
    }
    interface TypeTweenInfo {
        outTangent?: number;
        outWeight?: number;
        inTangent?: number;
        inWeight?: number;
        inWeightLock?: boolean;
        outWeightLock?: boolean;
        broken?: boolean;
    }
    class Keyframe2D implements IClone {
        static defaultWeight: number;
        /**时间。*/
        time: number;
        /**帧里面的具体数据 */
        data: TypeAniKey;
        clone(): Keyframe2D;
        cloneTo(destObject: any): void;
    }
    class KeyframeNode2D {
        _ownerPath: string[];
        _propertys: string[];
        fullPath: string;
        nodePath: string;
        _indexInList: number;
        _keyFrames: Keyframe2D[];
        /**
        * 帧个数。
        */
        get keyFramesCount(): number;
        _setOwnerPathCount(value: number): void;
        _setOwnerPathByIndex(index: number, value: string): void;
        _setPropertyCount(value: number): void;
        _setPropertyByIndex(index: number, value: string): void;
        _setKeyframeCount(value: number): void;
        _joinOwnerPath(sep: string): string;
        _joinProperty(sep: string): string;
        /**
        * 通过索引获取帧。
        * @param index 索引。
        */
        getKeyframeByIndex(index: number): Keyframe2D;
        /**
        * 精灵路径个数。
        */
        get ownerPathCount(): number;
        /**
         * 属性路径个数。
         */
        get propertyCount(): number;
        /**
         * 通过索引获取精灵路径。
         * @param index 索引。
         */
        getOwnerPathByIndex(index: number): string;
        /**
         * 通过索引获取属性路径。
         * @param index 索引。
         */
        getPropertyByIndex(index: number): string;
    }
    class KeyframeNodeList2D {
        private _nodes;
        /**
        *	节点个数。
        */
        get count(): number;
        set count(value: number);
        /**
         * 通过索引获取节点。
         * @param	index 索引。
         * @return 节点。
         */
        getNodeByIndex(index: number): KeyframeNode2D;
        /**
         * 通过索引设置节点。
         * @param	index 索引。
         * @param 节点。
         */
        setNodeByIndex(index: number, node: KeyframeNode2D): void;
    }
    /**
     * <code>Script</code> 类用于创建脚本的父类，该类为抽象类，不允许实例。
     */
    class Script extends Component {
        owner: Sprite | Sprite3D;
        protected setupScript(): void;
        /**
         * 3D物理触发器事件与2D物理碰撞事件，开始碰撞时执行
         */
        onTriggerEnter?(other: PhysicsColliderComponent | ColliderBase, self?: ColliderBase, contact?: any): void;
        /**
         * 3D物理触发器事件与2D物理碰撞事件，持续碰撞时执行
         */
        onTriggerStay?(other: PhysicsColliderComponent | ColliderBase, self?: ColliderBase, contact?: any): void;
        /**
         * 3D物理触发器事件与2D物理碰撞事件，结束碰撞时执行
         */
        onTriggerExit?(other: PhysicsColliderComponent | ColliderBase, self?: ColliderBase, contact?: any): void;
        /**
         * 3D物理碰撞器事件（不适用2D），开始碰撞时执行
         */
        onCollisionEnter?(collision: Collision): void;
        /**
         * 3D物理碰撞器事件（不适用2D），持续碰撞时执行
         */
        onCollisionStay?(collision: Collision): void;
        /**
         *3D物理碰撞器事件（不适用2D），结束碰撞时执行
         */
        onCollisionExit?(collision: Collision): void;
        /**
         * 关节破坏时执行此方法
         */
        onJointBreak?(): void;
        /**
         * 鼠标按下时执行
         */
        onMouseDown?(evt: Event): void;
        /**
         * 鼠标抬起时执行
         */
        onMouseUp?(evt: Event): void;
        /**
         * 鼠标右键或中键按下时执行
         */
        onRightMouseDown?(evt: Event): void;
        /**
         * 鼠标右键或中键抬起时执行
         */
        onRightMouseUp?(evt: Event): void;
        /**
         * 鼠标在节点上移动时执行
         */
        onMouseMove?(evt: Event): void;
        /**
         * 鼠标进入节点时执行
         */
        onMouseOver?(evt: Event): void;
        /**
         * 鼠标离开节点时执行
         */
        onMouseOut?(evt: Event): void;
        /**
         * 鼠标按住一个物体后，拖拽时执行
         */
        onMouseDrag?(evt: Event): void;
        /**
         * 鼠标按住一个物体，拖拽一定距离，释放鼠标按键后执行
         */
        onMouseDragEnd?(evt: Event): void;
        /**
         * 鼠标点击时执行
         */
        onMouseClick?(evt: Event): void;
        /**
         * 鼠标双击时执行
         */
        onMouseDoubleClick?(evt: Event): void;
        /**
         * 鼠标右键点击时执行
         */
        onMouseRightClick?(evt: Event): void;
        /**
         * 键盘按下时执行
         */
        onKeyDown?(evt: Event): void;
        /**
         * 键盘产生一个字符时执行
         */
        onKeyPress?(evt: Event): void;
        /**
         * 键盘抬起时执行
         */
        onKeyUp?(evt: Event): void;
    }
    /**
     * 相对布局插件
     */
    class Widget extends Component {
        /**一个已初始化的 <code>Widget</code> 实例。*/
        static EMPTY: Widget;
        private _top;
        private _bottom;
        private _left;
        private _right;
        private _centerX;
        private _centerY;
        constructor();
        onReset(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        protected _onAdded(): void;
        /**
         * 父容器的 <code>Event.RESIZE</code> 事件侦听处理函数。
         */
        protected _onParentResize(): void;
        /**
         * <p>重置对象的 <code>X</code> 轴（水平方向）布局。</p>
         * @private
         */
        resetLayoutX(): boolean;
        /**
         * <p>重置对象的 <code>Y</code> 轴（垂直方向）布局。</p>
         * @private
         */
        resetLayoutY(): boolean;
        /**
         * 重新计算布局
         */
        resetLayout(): void;
        /**表示距顶边的距离（以像素为单位）。*/
        get top(): number;
        set top(value: number);
        /**表示距底边的距离（以像素为单位）。*/
        get bottom(): number;
        set bottom(value: number);
        /**表示距左边的距离（以像素为单位）。*/
        get left(): number;
        set left(value: number);
        /**表示距右边的距离（以像素为单位）。*/
        get right(): number;
        set right(value: number);
        /**表示距水平方向中心轴的距离（以像素为单位）。*/
        get centerX(): number;
        set centerX(value: number);
        /**表示距垂直方向中心轴的距离（以像素为单位）。*/
        get centerY(): number;
        set centerY(value: number);
    }
    /**
     * @private
     * 静态常量集合
     */
    class Const {
        static ENUM_TEXTALIGN_DEFAULT: number;
        static ENUM_TEXTALIGN_CENTER: number;
        static ENUM_TEXTALIGN_RIGHT: number;
        static BYTES_PE: number;
        static BYTES_PIDX: number;
        static MAX_CLIP_SIZE: number;
    }
    /**
     * 节点标志
     */
    class NodeFlags {
        static NOT_ACTIVE: number;
        static ACTIVE_INHIERARCHY: number;
        static AWAKED: number;
        static NOT_READY: number;
        static DISPLAY: number;
        static HAS_ZORDER: number;
        static HAS_MOUSE: number;
        static DISPLAYED_INSTAGE: number;
        static DRAWCALL_OPTIMIZE: number;
        static PROCESS_COLLISIONS: number;
        static PROCESS_TRIGGERS: number;
        static HAS_SCRIPT: number;
        static ESCAPE_DRAWING_TO_TEXTURE: number;
        static DISABLE_INNER_CLIPPING: number;
        static DISABLE_OUTER_CLIPPING: number;
        static DISABLE_VISIBILITY: number;
        static EDITING_NODE: number;
        static HIDE_BY_EDITOR: number;
        static LOCK_BY_EDITOR: number;
    }
    class HideFlags {
        static HideInHierarchy: number;
        static HideInInspector: number;
        static DontSave: number;
        static HideAndDontSave: number;
    }
    /**
     * <code>AnimationClip</code> 类用于动画片段资源。
     */
    class AnimationClip extends Resource {
        /**
         * @inheritDoc
         */
        static _parse(data: any): AnimationClip;
        /**
         * 加载动画片段。
         * @param url 动画片段地址。
         * @param complete  完成回掉。load
         */
        static load(url: string, complete: Handler): void;
        /**是否循环。*/
        islooping: boolean;
        /**
         * 动画持续时间
         * @returns 返回动画持续时间
         */
        duration(): number;
        /**
         * 创建一个 <code>AnimationClip</code> 实例。
         */
        constructor();
        /**
         * 是否是Weight模式
         * @param weightMode
         * @param nextweightMode
         * @returns true 此段动画插值使用埃尔米特插值
         */
        private _weightModeHermite;
        private _hermiteInterpolateVector4;
        private _hermiteInterpolateVector2;
        private _hermiteCurveSplineWeight;
        private _curveInterpolate;
        private _evaluateFrameNodeVector3DatasRealTime;
        private _evaluateFrameNodeVector2DatasRealTime;
        private _evaluateFrameNodeVector4DatasRealTime;
        private _evaluateFrameNodeQuaternionDatasRealTime;
        private _binarySearchEventIndex;
        /**
         * 添加动画事件。
         * @param event 动画事件
         */
        addEvent(event: AnimationEvent): void;
        /**
         * @inheritDoc
         * @override
         */
        protected _disposeResource(): void;
    }
    /**
     * <code>AnimationEvent</code> 类用于实现动画事件。
     */
    class AnimationEvent {
        /** 事件触发时间。*/
        time: number;
        /** 事件触发名称。*/
        eventName: string;
        /** 事件触发参数。*/
        params: any[];
        /**
         * 创建一个 <code>AnimationEvent</code> 实例。
         */
        constructor();
    }
    /**
     * <code>AnimatorStateScript</code> 类用于动画状态脚本的父类,该类为抽象类,不允许实例。
     */
    class AnimatorStateScript {
        /**
         * 创建一个新的 <code>AnimatorStateScript</code> 实例。
         */
        constructor();
        /**
         * 动画状态开始时执行。
         */
        onStateEnter(): void;
        /**
         * 动画状态运行中
         * @param normalizeTime 0-1动画播放状态
         */
        onStateUpdate(normalizeTime: number): void;
        /**
         * 动画状态退出时执行。
         */
        onStateExit(): void;
        /**
         * 动画设置了循环的话，每次循环结束时执行
         */
        onStateLoop(): void;
    }
    /**
     *<code>KeyframeNode</code> 类用于动画帧。
     */
    class KeyframeNode {
        private _ownerPath;
        private _propertys;
        /**
         * 精灵路径个数。
         */
        get ownerPathCount(): number;
        /**
         * 属性路径个数。
         */
        get propertyCount(): number;
        /**
         * 帧个数。
         */
        get keyFramesCount(): number;
        /**
         * 通过索引获取精灵路径。
         * @param index 索引。
         */
        getOwnerPathByIndex(index: number): string;
        /**
         * 通过索引获取属性路径。
         * @param index 索引。
         */
        getPropertyByIndex(index: number): string;
        /**
         * 通过索引获取帧。
         * @param index 索引。
         */
        getKeyframeByIndex(index: number): Keyframe;
    }
    /**
     * <code>KeyframeNodeList</code> 类用于创建KeyframeNode节点队列。
     */
    class KeyframeNodeList {
        /**
         *	节点个数。
         */
        get count(): number;
        set count(value: number);
        /**
         * 创建一个 <code>KeyframeNodeList</code> 实例。
         */
        constructor();
        /**
         * 通过索引获取节点。
         * @param	index 索引。
         * @return 节点。
         */
        getNodeByIndex(index: number): KeyframeNode;
        /**
         * 通过索引设置节点。
         * @param	index 索引。
         * @param 节点。
         */
        setNodeByIndex(index: number, node: KeyframeNode): void;
    }
    type AnimatorParams = {
        [key: number]: number | boolean;
    };
    /**
     * <code>Animator</code> 类用于创建动画组件。
     */
    class Animator extends Component {
        /** 裁剪模式_始终播放动画。*/
        static CULLINGMODE_ALWAYSANIMATE: number;
        /** 裁剪模式_不可见时完全不播放动画。*/
        static CULLINGMODE_CULLCOMPLETELY: number;
        /**	裁剪模式*/
        cullingMode: number;
        _controller: AnimatorController;
        set controller(val: AnimatorController);
        get controller(): AnimatorController;
        /**
         * 动画的播放速度,1.0为正常播放速度。
         */
        get speed(): number;
        set speed(value: number);
        /**
         * 设置更新模式
         */
        set updateMode(value: AnimatorUpdateMode);
        /**
         * 低更新模式
         */
        set lowUpdateDelty(value: number);
        get controllerLayerCount(): number;
        /**
         * 状态机参数map
         */
        set animatorParams(values: AnimatorParams);
        get animatorParams(): AnimatorParams;
        /**
         * 动画完成是否停止更新
         */
        set sleep(value: boolean);
        get sleep(): boolean;
        /**
         * 创建一个 <code>Animation</code> 实例。
         */
        constructor();
        /**
         * 启用过渡
         * @param layerindex
         * @param transition
         * @returns
         */
        private _applyTransition;
        private _applyVec2;
        private _applyVec3;
        private _applyVec4;
        private _applyColor;
        /**
         * 赋值Node数据
         * @param stateInfo 动画状态
         * @param additive 是否为addtive
         * @param weight state权重
         * @param isFirstLayer 是否是第一层
         */
        private _setClipDatasToNode;
        protected _onEnable(): void;
        protected _onDestroy(): void;
        private _applyUpdateMode;
        /**
         * 获取默认动画状态。
         * @param	layerIndex 层索引。
         * @return 默认动画状态。
         */
        getDefaultState(layerIndex?: number): AnimatorState;
        /**
         * 添加动画状态。
         * @param	state 动画状态。
         * @param   layerIndex 层索引。
         */
        addState(state: AnimatorState, layerIndex?: number): void;
        /**
         * 移除动画状态。
         * @param	state 动画状态。
         * @param   layerIndex 层索引。
         */
        removeState(state: AnimatorState, layerIndex?: number): void;
        /**
         * 添加控制器层。
         */
        addControllerLayer(controllderLayer: AnimatorControllerLayer): void;
        /**
         * 获取控制器层。
         */
        getControllerLayer(layerInex?: number): AnimatorControllerLayer;
        /**
         * 播放动画。
         * @param	name 如果为null则播放默认动画，否则按名字播放动画片段。
         * @param	layerIndex 层索引。
         * @param	normalizedTime 归一化的播放起始时间。
         */
        play(name?: string | null, layerIndex?: number, normalizedTime?: number): void;
        /**
         * 在当前动画状态和目标动画状态之间进行融合过渡播放。
         * @param	name 目标动画状态。
         * @param	transitionDuration 过渡时间,该值为当前动画状态的归一化时间，值在0.0~1.0之间。
         * @param	layerIndex 层索引。
         * @param	normalizedTime 归一化的播放起始时间。
         */
        crossFade(name: string, transitionDuration: number, layerIndex?: number, normalizedTime?: number): void;
        /**
         * set params value
         * @param name
         */
        setParamsTrigger(name: number): void;
        setParamsTrigger(name: string): void;
        /**
         * set params value
         * @param name
         */
        setParamsNumber(name: number, value: number): void;
        setParamsNumber(name: string, value: number): void;
        /**
         * set params value
         * @param name
         */
        setParamsBool(name: number, value: boolean): void;
        setParamsBool(name: string, value: boolean): void;
        /**
         * get params value
         * @param name
         */
        getParamsvalue(name: number): number | boolean;
        getParamsvalue(name: string): number | boolean;
        /**
         * @deprecated 请使用animator.getControllerLayer(layerIndex).getCurrentPlayState()替换。use animator.getControllerLayer(layerIndex).getCurrentPlayState() instead
         * 获取当前的播放状态。
         * @param   layerIndex 层索引。
         * @return  动画播放状态。
         */
        getCurrentAnimatorPlayState(layerInex?: number): AnimatorPlayState;
    }
    class AnimatorController extends Resource {
        data: TypeAnimatorControllerData;
        clipsID: string[];
        constructor(data: any);
        private getLayers;
        updateTo(a: Animator): void;
        private createState;
        private setExitTransition;
        private setTransitions;
        private getState;
        private addConditions;
    }
    /**
     * <code>AnimatorControllerLayer</code> 类用于创建动画控制器层。
     */
    class AnimatorControllerLayer implements IClone {
        /**混合模式_覆盖。 */
        static BLENDINGMODE_OVERRIDE: number;
        /**混合模式_叠加。 */
        static BLENDINGMODE_ADDTIVE: number;
        /** 层的名称。*/
        name: string;
        /** 混合模式。*/
        blendingMode: number;
        /** 默认权重。*/
        defaultWeight: number;
        /**	激活时是否自动播放。*/
        playOnWake: boolean;
        /** 是否开启 */
        enable: boolean;
        /**
         * 默认动画状态机。
         */
        get defaultState(): AnimatorState;
        set defaultState(value: AnimatorState);
        /**
         * 骨骼遮罩
         */
        get avatarMask(): AvatarMask;
        set avatarMask(value: AvatarMask);
        private _defaultStateNameCatch;
        /**
         * 创建一个 <code>AnimatorControllerLayer</code> 实例。
         * @param 动画层名称
         */
        constructor(name: string);
        _getReferenceCount(): number;
        _addReference(count?: number): void;
        _removeReference(count?: number): void;
        _clearReference(): void;
        /**
         * 获取当前的播放状态。
         * @return 动画播放状态。
         */
        getCurrentPlayState(): AnimatorPlayState;
        /**
         * 获取动画状态。
         * @return 动画状态。
         */
        getAnimatorState(name: string): AnimatorState | null;
        /**
         * 添加动画状态。
         * @param	state 动画状态。
         * @param   layerIndex 层索引。
         */
        addState(state: AnimatorState): void;
        /**
         * 移除动画状态。
         * @param	state 动画状态。
         * @param   layerIndex 层索引。
         */
        removeState(state: AnimatorState): void;
        /**
         * 销毁。
         */
        destroy(): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>AnimatorPlayState</code> 类用于创建动画播放状态信息。
     */
    class AnimatorPlayState {
        /**
         * 当前动画State
         */
        get currentState(): AnimatorState | null;
        set currentState(value: AnimatorState | null);
        /**
         * 播放状态的归一化时间,整数为循环次数，小数为单次播放时间。
         */
        get normalizedTime(): number;
        /**
         * 当前动画的持续时间，以秒为单位。
         */
        get duration(): number;
        /**
         * 动画状态机。
         */
        get animatorState(): AnimatorState;
        /**
         * 创建一个 <code>AnimatorPlayState</code> 实例。
         */
        constructor();
    }
    class AnimatorResource {
        static getAnimatorResource(sprite: Sprite3D, propertyKey: string): Component;
    }
    /**
     * <code>AnimatorState</code> 类用于创建动作状态。
     */
    class AnimatorState extends EventDispatcher implements IClone {
        /**
         * 动画事件 开始时调用
         */
        static EVENT_OnStateEnter: string;
        /**
         * 动画事件 更新时调用
         */
        static EVENT_OnStateUpdate: string;
        /**
        * 动画事件 循环完成时调用
        */
        static EVENT_OnStateLoop: string;
        /**
         * 动画事件 离开时调用
         */
        static EVENT_OnStateExit: string;
        /**是否循环播放,为0时则使用_clip.islooping，1为循环，2为不循环 */
        _isLooping: 0 | 1 | 2;
        curTransition: AnimatorTransition;
        /**名称。*/
        name: string;
        /**动画播放速度,1.0为正常播放速度。*/
        speed: number;
        /**动作播放起始时间。*/
        clipStart: number;
        /**动作播放结束时间。*/
        clipEnd: number;
        /**play on awake start offset*/
        cycleOffset: number;
        /**
         * 动作。
         */
        get clip(): AnimationClip | null;
        set clip(value: AnimationClip | null);
        get islooping(): boolean;
        /**
         * IDE
         */
        get transitions(): AnimatorTransition[];
        set transitions(value: AnimatorTransition[]);
        /**
         * IDE
         */
        get soloTransitions(): AnimatorTransition[];
        set soloTransitions(value: AnimatorTransition[]);
        /**
         * 创建一个 <code>AnimatorState</code> 实例。
         */
        constructor();
        /**
         * 添加脚本。
         * @param	type  组件类型。
         * @return 脚本。
         *
         */
        addScript(type: typeof AnimatorStateScript): AnimatorStateScript;
        /**
         * 获取脚本。
         * @param	type  组件类型。
         * @return 脚本。
         *
         */
        getScript(type: typeof AnimatorStateScript): AnimatorStateScript | null;
        /**
         * 获取脚本集合。
         * @param	type  组件类型。
         * @return 脚本集合。
         */
        getScripts(type: typeof AnimatorStateScript): AnimatorStateScript[] | null;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    class AnimatorTransition {
        /**
         * 创建一个新的Animatortransition
         */
        constructor();
        /**
         * 设置过渡名字
         */
        get name(): string;
        set name(value: string);
        /**
         * 禁用
         */
        get mute(): boolean;
        set mute(value: boolean);
        /**
         * 目标状态
         */
        get destState(): AnimatorState;
        set destState(value: AnimatorState);
        /**
         * 设置condition数组
         * IDE
         */
        get conditions(): AnimatorStateCondition[];
        set conditions(value: AnimatorStateCondition[]);
        /**
         * 时间触发
         */
        get exitByTime(): boolean;
        set exitByTime(value: boolean);
        /**
         * 过度归一化时间（相对于目标State）
         */
        set transduration(value: number);
        get transduration(): number;
        /**
        * 目标State播放时间偏移（归一化时间）
        */
        set transstartoffset(value: number);
        get transstartoffset(): number;
        /**
        * 触发时间（归一化时间）
        */
        set exitTime(value: number);
        get exitTime(): number;
        /**
         * 增加一个条件
         * @param condition
         */
        addCondition(condition: AnimatorStateCondition): void;
        /**
         * 删除一个条件
         * @param condition
         */
        removeCondition(condition: AnimatorStateCondition): void;
        /**
         * 是否启用过渡
         * @param normalizeTime
         * @param paramsMap
         */
        check(normalizeTime: number, paramsMap: {
            [key: number]: number | boolean;
        }): boolean;
    }
    /**
     * 用来描述动画层遮罩
     */
    class AvatarMask {
        /**
         * 创建一个<code>AvatarMask</code>实例
         */
        constructor(data?: any);
        /**
         * 查找节点路径遮罩
         * @param path
         * @returns
         */
        getTransformActive(path: string): boolean;
        /**
         * 设置
         * @param path
         * @param value
         */
        setTransformActive(path: string, value: boolean): void;
        /**
         * 获得遮罩信息
         * @returns
         */
        getAllTranfromPath(): Record<string, boolean>;
        /**
       * 克隆。
       * @return	 克隆副本。
       */
        clone(): any;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
    }
    enum KeyFrameValueType {
        None = -1,
        Float = 0,
        Position = 1,
        Rotation = 2,
        Scale = 3,
        RotationEuler = 4,
        Vector2 = 5,
        Vector3 = 6,
        Vector4 = 7,
        Color = 8
    }
    class HLOD extends Component {
        constructor();
        /**
         * IDE
         */
        get bounds(): Bounds;
        set bounds(value: Bounds);
        /**
         * IDE
         */
        get lodResource(): HLODResourceGroup[];
        set lodResource(value: HLODResourceGroup[]);
        /**
         * lod裁剪过滤
         */
        set lodCullRateArray(value: number[]);
        get lodCullRateArray(): number[];
        private _applyLODResource;
        private _releaseGroupRender;
        onUpdate(): void;
        applyResource(resource: HLODResourceGroup): void;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        _cloneTo(dest: HLOD): void;
    }
    class HLODBatchMesh extends GeometryElement {
        /**
         * instance HLODBatchMesh
         */
        constructor();
        /**
         * 合批后的mesh
         * @param mesh
         * @param bounds
         */
        set batchMesh(mesh: Mesh);
        get batchMesh(): Mesh;
        /**
         * 合批子mesh信息
         */
        set batchSubMeshInfo(value: HLODBatchSubMesh[]);
        get batchSubMeshInfo(): HLODBatchSubMesh[];
        get drawSubMeshs(): HLODBatchSubMesh[];
        /**
         * 销毁
         */
        destroy(): void;
    }
    class HLODRender extends BaseRender {
        constructor();
        /**
         * set HLOD element
         */
        get curHLODRS(): HLODElement;
        set curHLODRS(value: HLODElement);
        /**
         * 根据LOD资源生成渲染节点
         * @param source
         * @returns
         */
        private _createRenderelementByHLODElement;
        /**
         * change Render Mesh
         */
        private _changeMesh;
        /**
         * re caculate BoundBox
         */
        _calculateBoundingBox(): void;
        /**
         * update data
         * @param context
         * @param transform
         */
        _renderUpdate(context: RenderContext3D, transform: Transform3D): void;
        _needRender(boundFrustum: BoundFrustum, context: RenderContext3D): boolean;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        _cloneTo(dest: HLODRender): void;
    }
    /**
     * HLOD的设置
     */
    class HLODConfig {
        releaseCallTime: number;
        releaseTime: number;
    }
    /**
     * HLODBatch resource
     */
    class HLODBatchSubMesh {
        bounds: Bounds;
        drawPramas: Vector2;
    }
    /**
     * HLODElement 一组HLODRenderElement资源
     */
    class HLODElement {
        /**batch mesh */
        HLODMesh: HLODBatchMesh;
        /**material */
        private _material;
        get material(): Material;
        set material(value: Material);
        /**lightmap */
        private _lightmap;
        get lightmap(): Lightmap;
        set lightmap(value: Lightmap);
        /**
         * 释放资源
         * lightmap direct destroy
         */
        release(): void;
    }
    /**
     * HLOD Resource
     * Load/release
     */
    class HLODResourceGroup {
        url: string;
        updateMark: number;
        resources: HLODElement[];
        loaded: boolean;
        /**
         * loaded
         * @param callFun
         * @param hlod
         */
        load(callFun: Function, hlod: any): void;
        /**
         * 释放HLODGourp资源
         */
        release(): void;
    }
    /**
     * 此类描述Lod数据
     */
    class LODInfo {
        /**
         * 实例化一个LODInfo
         * @param mincullRate
         */
        constructor(mincullRate: number);
        /**
         * 设置最小通过率
         */
        set mincullRate(value: number);
        get mincullRate(): number;
        /**
         * 设置LODInfo的节点信息
         */
        set renders(value: Sprite3D[]);
        get renders(): Sprite3D[];
        /**
         * 在lodInfo中增加渲染节点
         * @param node
         */
        addNode(node: Sprite3D): void;
        /**
         * 删除某个lod节点
         * @param node
         */
        removeNode(node: Sprite3D): void;
        /**
         * 释放所有的渲染节点cull标记
         */
        removeAllRender(): void;
    }
    /**
     * <code>SpotLight</code> 类用于构建LOD组件
     */
    class LODGroup extends Component implements IBoundsCell {
        /**
         * 是否需要重新计算_lodBoundsRadius，和_bounds
         * 在LOD值里面位置有相对改动的时候是需要重新计算的
         */
        private _needcaculateBounds;
        /**
         * lodGroup所有的渲染节点的包围盒计算
         */
        private _bounds;
        /**
         * size
         */
        private _size;
        /**
         * 包围盒中心位置
         */
        private _lodPosition;
        /**
         * lod等级数量
         */
        private _lodCount;
        /**
         * lod等级信息
         */
        private _lods;
        /**
         * 显示节点
         */
        private _visialIndex;
        /**
         * lod节点比例
         */
        private _nowRate;
        /**
         * 实例化一个LODGroup
         */
        constructor();
        shadowCullPass(): boolean;
        /**
        * get LODInfo 数组
        * @returns
        */
        get lods(): LODInfo[];
        /**
         * 设置 LODInfo 数组
         * @param data
         */
        set lods(data: LODInfo[]);
        get nowRate(): number;
        /**
         * 获得LOD包围盒
         */
        get bounds(): Bounds;
        /**
         * 设置显示隐藏组
         * @param rate
         * @returns
         */
        private _applyVisibleRate;
        /**
         * 设置某一级LOD显示
         * @param index
         */
        private _setLODvisible;
        /**
         * 设置某一级LOD不显示
         * @param index
         */
        private _setLODinvisible;
    }
    /**
     * <code>PostProcess</code> 类用于创建后期处理组件。
     */
    class PostProcess {
        /**
         * 重新计算CameraFlag
         */
        private recaculateCameraFlag;
        /**
         * 创建一个 <code>PostProcess</code> 实例。
         */
        constructor();
        /**
         * 开启属性
         */
        get enable(): boolean;
        set enable(value: boolean);
        /**
         * IDEmain
         * 设置后期Effect数组
         */
        set effects(value: PostProcessEffect[]);
        get effects(): PostProcessEffect[];
        /**
         * 根据后期处理的需要,设置值
         */
        get cameraDepthTextureMode(): DepthTextureMode;
        /**
         * 添加后期处理效果。
         */
        addEffect(effect: PostProcessEffect): void;
        /**
         * 根据类型获得后期处理实例
         * @param classReg
         * @returns
         */
        getEffect(classReg: any): any;
        /**
         * 移除后期处理效果。
         */
        removeEffect(effect: PostProcessEffect): void;
        /**
         * 清理所有后期处理
         */
        clearEffect(): void;
    }
    /**
     * 保持对2.0的兼容。新脚本支持使用Script即可。
     */
    var Script3D: typeof Script;
    type Script3D = Script;
    class StaticBatchMesh {
        static create(info: StaticMeshMergeInfo): StaticBatchMesh;
        bounds: Bounds;
        constructor();
        setBuffer(vertex: VertexBuffer3D, index: IndexBuffer3D): void;
        destroy(): void;
    }
    class StaticBatchMeshRender extends BaseRender {
        static create(info: StaticMeshMergeInfo): StaticBatchMeshRender;
        private _staticMesh;
        get staticMesh(): StaticBatchMesh;
        private _mergeInfo;
        get mergeInfo(): StaticMeshMergeInfo;
        set mergeInfo(value: StaticMeshMergeInfo);
        _singleton: boolean;
        private constructor();
        _calculateBoundingBox(): void;
        _renderUpdate(context: RenderContext3D, transform: Transform3D): void;
        _getMeshDefine(mesh: StaticBatchMesh, out: Array<ShaderDefine>): void;
        _needRender(boundFrustum: BoundFrustum, context: RenderContext3D): boolean;
        onEnable(): void;
        onDisable(): void;
        onDestroy(): void;
        _cloneTo(dest: StaticBatchMeshRender): void;
    }
    class StaticBatchSubInfo {
        indexStart: number;
        indexCount: number;
        meshBounds: Bounds;
        needRender: boolean;
        constructor();
    }
    class StaticBatchSubMesh extends GeometryElement {
        subInfos: StaticBatchSubInfo[];
        indexByteCount: number;
        constructor();
        addSubMesh(indexCount: number, indexStart: number, bounds: Bounds): void;
        _getType(): number;
        _updateRenderParams(state: RenderContext3D): void;
        _prepareRender(state: RenderContext3D): boolean;
        destroy(): void;
    }
    class StaticMeshMergeInfo {
        static create(render: MeshRenderer): StaticMeshMergeInfo;
        /**
         * receiveShadow接受阴影
         */
        receiveShadow: boolean;
        /**
         * 光照贴图索引
         */
        lightmapIndex: number;
        /**
         * 顶点描述
         */
        vertexDec: VertexDeclaration;
        private _renders;
        get renders(): MeshRenderer[];
        vertexCount: number;
        indexCount: number;
        private constructor();
        match(render: MeshRenderer): boolean;
        addElement(render: MeshRenderer): void;
        destroy(): void;
    }
    /**
     * 类用来描述合批的渲染节点
     */
    class BatchRender extends BaseRender {
        protected _lodCount: number;
        protected _lodRateArray: number[];
        protected _batchList: SingletonList<BaseRender>;
        protected _batchbit: RenderBitFlag;
        protected _RenderBitFlag: RenderBitFlag;
        protected _lodInstanceRenderElement: {
            [key: number]: InstanceRenderElement[];
        };
        protected _lodsize: number;
        private _cacheLod;
        /**
         * 创建一个 <code>BatchRender</code> 实例。
         */
        constructor();
        /**
         * 是否根据lod来合批
         */
        get checkLOD(): boolean;
        set checkLOD(value: boolean);
        /**
         * lod裁剪过滤
         */
        set lodCullRateArray(value: number[]);
        get lodCullRateArray(): number[];
        /**
         * Overrid it
         *  是否满足batch条件
         */
        protected _canBatch(render: BaseRender): boolean;
        protected _onEnable(): void;
        protected _onDisable(): void;
        /**
         * 根据lod的改变
         */
        protected _changeLOD(lod: number): void;
        onPreRender(): void;
        /**
         * @param render
         */
        _batchOneRender(render: BaseRender): boolean;
        /**
         * @param render
         */
        _removeOneRender(render: BaseRender): void;
        /**
         * @param render
         */
        _updateOneRender(render: BaseRender): void;
        /**
         * 合批队列传入
         * @param renderNodes
         */
        addList(renderNode: BaseRender[]): void;
        /**
         * 根据_batchList合批
         */
        reBatch(): void;
        /**
         * Restoring the Batch Render State
         */
        _restorRenderNode(): void;
        _clear(): void;
    }
    /**
     * 类用来描述一个可合并渲染节点的体积
     */
    class StaticBatchVolume extends Volume {
        /**
         * 合批是否考虑LOD
         */
        get checkLOD(): boolean;
        set checkLOD(value: boolean);
        /**
         * 开启静态Instance实例合批
         */
        get enableStaticInstanceBatchRender(): boolean;
        set enableStaticInstanceBatchRender(value: boolean);
        /**
         * 开启静态顶点合批
         */
        get enableMergeBatchRender(): boolean;
        set enableMergeBatchRender(value: boolean);
        /**
         * 开启自定义合批
         */
        get enableCustomBatchRender(): boolean;
        set enableCustomBatchRender(value: boolean);
        /**
         * 设置自定义的合批方案BatchRender
         */
        set customBatchRenders(value: BatchRender[]);
        get customBatchRenders(): BatchRender[];
        /**
         * 创建一个<code>BatchVolume</code>实例
         */
        constructor();
        /**
         * Restoring the Batch Render State
         */
        private _restorRenderNode;
        /**
         * add one RenderNode
         * @param renderNode
         * @returns
         */
        private __addRenderNodeToBatch;
        /**
         * remove one RenderNode
         * @param renderNode
         */
        private __removeRenderNodeFromBatch;
        /**
         * @inheritDoc
         * @override
         */
        protected _onEnable(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected _onDisable(): void;
        /**
         * 重新合批,将清理前面状态
         * 必要时需要手动调用,根据Volume里面的值,进行合批
         */
        reBatch(): void;
    }
    /**
     * <code>StaticInstanceBatchRender</code> 类用于创建动作状态。
     */
    class StaticInstanceBatchRender extends BatchRender {
        /**@interal */
        private _insElementMarksArray;
        /**@interal batch rule:Batch min count*/
        private _instanceBatchminNums;
        /**@interal cache udpate element*/
        private _updateChangeElement;
        /**
         * 创建一个 <code>StaticInstanceBatchRender</code> 实例。
         */
        constructor();
        /**
         * 判断这个Render是否支持InstanceBatch
         * @param render
         * @returns
         */
        private _isRenderNodeAllCanInstanceBatch;
        /**
         * 计算Instance合并数量
         * @param render
         */
        private _sumInstanceBatch;
        /**
         * batch one element
         * @param element
         * @param render
         * @returns
         */
        private _batchOneElement;
        /**
         * remove one element
         * @param element
         * @param render
         * @returns
         */
        private _removeOneElement;
        /**
         * update one element
         * @param element
         * @param render
         * @returns
         */
        private _updateOneElement;
        /**
         * create instanceElement
         * @param element
         * @param render
         * @param batchMark
         * @returns
         */
        private _createInstanceElement;
        /**
         * 是否满足batch条件
         * @override
         * @param render
         * @returns
         */
        protected _canBatch(render: BaseRender): boolean;
        /**
         * destroy
         */
        protected _onDestroy(): void;
        /**
        * 合批队列传入
        * @param renderNodes
        */
        addList(renderNodes: BaseRender[]): void;
        /**
         * 根据_batchList合批
         */
        reBatch(): void;
    }
    class StatiVertexMergeBatchRender extends BatchRender {
        _addList(renderNodes: BaseRender[]): void;
    }
    /**
     * <code>VolumeManager</code> 类用于管理体积组件
     */
    interface IVolumeManager {
    }
    /**
     * 反射探针模式
     */
    enum ReflectionProbeMode {
        /**烘培模式 */
        off = 0,
        /**实时简单采样模式 还未支持*/
        simple = 1
    }
    /**
     * <code>ReflectionProbe</code> 类用于实现反射探针组件
     * @miner
     */
    class ReflectionProbe extends Volume {
        static reflectionCount: number;
        /**获取一个全局唯一ID。*/
        static getID(): number;
        static TEMPVECTOR3: Vector3;
        /** 默认解码数据 */
        static defaultTextureHDRDecodeValues: Vector4;
        /** 盒子反射是否开启 */
        private _boxProjection;
        /** 包围盒 */
        protected _bounds: Bounds;
        /** 探针重要度 */
        protected _importance: number;
        /**漫反射顔色 */
        private _ambientColor;
        /**漫反射SH */
        private _ambientSH;
        /**漫反射强度 */
        private _ambientIntensity;
        /**ibl反射 */
        private _iblTex;
        /**ibl是否压缩 */
        private _iblTexRGBD;
        /**反射强度 */
        private _reflectionIntensity;
        /** 是否是场景探针 */
        _isScene: boolean;
        /**修改了值，需要更新shader，需要和updateMask对应 */
        _updateMark: number;
        constructor();
        /**
         * 是否开启正交反射。
         */
        get boxProjection(): boolean;
        set boxProjection(value: boolean);
        /**
         * 设置反射探针的重要度
         */
        get importance(): number;
        set importance(value: number);
        /**
         * 设置环境漫反射的强度
         */
        get ambientIntensity(): number;
        set ambientIntensity(value: number);
        /**
         * 设置反射探针强度
         */
        get reflectionIntensity(): number;
        set reflectionIntensity(value: number);
        /**
         * 获得反射探针的包围盒
         */
        get bounds(): Bounds;
        /**
         * 包围盒 max
         */
        set boundsMax(value: Vector3);
        get boundsMax(): Vector3;
        /**
         * 包围盒 min
         */
        set boundsMin(value: Vector3);
        get boundsMin(): Vector3;
        /**
         * probe 位置
         */
        get probePosition(): Vector3;
        /**
         * 漫反射颜色
         */
        get ambientColor(): Color;
        set ambientColor(value: Color);
        /**
         * 漫反射颜色 sh
         */
        get ambientSH(): Float32Array;
        set ambientSH(value: Float32Array);
        /**
        * 环境光模式。
        * 如果值为AmbientMode.SolidColor一般使用ambientColor作为环境光源，如果值为如果值为AmbientMode.SphericalHarmonics一般使用ambientSphericalHarmonics作为环境光源。
        */
        get ambientMode(): AmbientMode;
        set ambientMode(value: AmbientMode);
        /**
         * Image base Light
         */
        get iblTex(): TextureCube;
        set iblTex(value: TextureCube);
        /**
         * Image base Light Compress by RGBD
         */
        get iblTexRGBD(): boolean;
        set iblTexRGBD(value: boolean);
        applyReflectionShaderData(shaderData: ShaderData): void;
        /**
        * @inheritDoc
        * @override
        */
        protected _onEnable(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected _onDisable(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected _onDestroy(): void;
        /**
         * @deprecated
         *  反射探针图片 */
        private _reflectionTexture;
        /**
         * @deprecated
         *  反射参数
         */
        private _reflectionHDRParams;
        /**
         * @deprecated 反射探针解码格式
         */
        private _reflectionDecodeFormat;
        /**
         * @deprecated
         * 设置反射贴图
         */
        get reflectionTexture(): TextureCube;
        set reflectionTexture(value: TextureCube);
        /**
        * @deprecated
        */
        get customReflection(): TextureCube;
        set customReflection(value: TextureCube);
        /**
         * @deprecated
         * 反射参数
         */
        get reflectionHDRParams(): Vector4;
        /**
         * 反射立方体纹理解码格式。
         * @deprecated
         */
        get reflectionDecodingFormat(): TextureDecodeFormat;
        set reflectionDecodingFormat(value: TextureDecodeFormat);
        /**
        * @deprecated
        * 球谐环境光,修改后必须重新赋值。
        * use scene.ambientSH
        */
        get ambientSphericalHarmonics(): SphericalHarmonicsL2;
        /**
         * @deprecated
         * use scene.ambientSH
         */
        set ambientSphericalHarmonics(value: SphericalHarmonicsL2);
        /**
       * @deprecated
       * 设置 天空， 地平线， 地面 环境光颜色
       */
        setGradientAmbient(skyColor: Vector3, equatorColor: Vector3, groundColor: Vector3): void;
    }
    /**
     *<code>ReflectionProbeManager</code> 类用于反射探针管理
     */
    class ReflectionProbeManager implements IVolumeManager {
        /**
         * 实例化一个反射探针管理类
         */
        constructor();
        /**
         * Scene Reflection
         */
        set sceneReflectionProbe(value: ReflectionProbe);
        get sceneReflectionProbe(): ReflectionProbe;
        /**
         * 更新baseRender的反射探针
         * @param baseRender
         */
        _updateRenderObject(baseRender: BaseRender): void;
    }
    enum volumeIntersectType {
        /**包含 */
        contain = 0,
        /**相交 */
        intersect = 1,
        /**不相交*/
        Disjoint = 2
    }
    /**
     * 物体于Volume的相交属性
     */
    class volumeIntersectInfo {
        type: volumeIntersectType;
        /**相交比例 */
        intersectRate: number;
    }
    class Volume extends Component {
        /** 包围盒 */
        protected _bounds: Bounds;
        /**cache number of around Volume */
        protected _aroundVolumeCacheNum: number;
        /** around Volume */
        protected _aroundVolume: Volume[];
        /** volume manager */
        protected _volumeManager: VolumeManager;
        /** volume intersect Comonent */
        protected _type: number;
        /** 重要性 */
        protected _importance: number;
        /**
         * 创建一个<code>Volume</code>实例
         */
        constructor();
        /**
         * volume Type
         */
        get type(): number;
        get boundsMax(): Vector3;
        /**
         * primitive包围盒max
         */
        set boundsMax(value: Vector3);
        /**
         * primitiveBoxMax
         */
        set boundsMin(value: Vector3);
        get boundsMin(): Vector3;
        get probePosition(): Vector3;
        get importance(): number;
        set importance(value: number);
        /**
         * @inheritDoc
         * @override
         */
        protected _onEnable(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected _onDisable(): void;
        /**
         * 当一个渲染节点进入体积
         * @param renderNode
         */
        _addRenderNode?(renderNode: BaseRender): void;
        /**
         * 当一个渲染节点移除体积
         * @param renderNode
         */
        _removeRenderNode?(renderNode: BaseRender): void;
        /**
         * 当一个渲染节点在体积中移动
         * @param renderNode
         */
        _motionInVolume?(renderNode: BaseRender): void;
        /**
         * Volume change
         */
        _VolumeChange(): void;
        _reCaculateBoundBox(): void;
    }
    /**
     * <code>VolumeManager</code> 类用于管理体积组件
     */
    class VolumeManager implements IVolumeManager {
        static ReflectionProbeVolumeType: number;
        static VolumetricGIType: number;
        /** 有些Volume需要特殊的管理能力 */
        _regVolumeManager: {
            [key: number]: IVolumeManager;
        };
        _volumetricGIManager: VolumetricGIManager;
        constructor();
        /**
         * get reflection manager
         */
        get reflectionProbeManager(): ReflectionProbeManager;
        get volumetricGIManager(): VolumetricGIManager;
        /**
         * add volume
         * @param volume
         */
        add(volume: Volume): void;
        /**
         * remove volume
         * @param volume
         */
        remove(volume: Volume): void;
        /**
         * add motion obj to handle list
         * @param renderObj
         */
        addMotionObject(renderObj: BaseRender): void;
        removeMotionObject(renderObj: BaseRender): void;
        /**
         * update one RenderNode Volume info
         * @param baseRender
         */
        _updateRenderObject(baseRender: BaseRender): void;
        /**
         * 重新更新所有Volume的信息
         */
        reCaculateAllRenderObjects(baseRenders: SingletonList<BaseRender>): void;
        needreCaculateAllRenderObjects(): boolean;
    }
    class VolumetricGI extends Volume {
        static volumetricCount: number;
        /**获取一个全局唯一ID。*/
        static getID(): number;
        /**密度 */
        private _intensity;
        /**
         * <code>实例化一个体积光照探针<code>
         */
        constructor();
        /**
        * @inheritDoc
        * @override
        */
        protected _onEnable(): void;
        /**
         * light probe texture
         */
        get irradiance(): Texture2D;
        set irradiance(value: Texture2D);
        /**
         * distance texture
         */
        get distance(): Texture2D;
        set distance(value: Texture2D);
        /**
         * normal bias
         */
        get normalBias(): number;
        set normalBias(value: number);
        /**
         * view bias
         */
        get viewBias(): number;
        set viewBias(value: number);
        /**
         * irradiance Texture one probe texel number
         */
        get irradianceTexel(): number;
        /**
         * distance Texture one probe texel number
         */
        get distanceTexel(): number;
        /**
         * 设置反射探针强度
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * 设置反射数量
         */
        get probeCounts(): Vector3;
        set probeCounts(value: Vector3);
        /**
         * 设置反射探针间隔
         */
        get probeStep(): Vector3;
        set probeStep(value: Vector3);
        /**
         * @interanl
         * upload volumetric GI data
         * @param shaderData
         */
        applyVolumetricGI(shaderData: ShaderData): void;
        /**
         * @interanl
         */
        _onDestroy(): void;
    }
    class VolumetricGIManager implements IVolumeManager {
        _needUpdateAllRender: boolean;
        private _GIVolumes;
        constructor();
        removeVolumetricGI(renderer: BaseRender): void;
        add(volume: VolumetricGI): void;
        remove(volume: VolumetricGI): void;
        _updateRenderObject(renderer: BaseRender): void;
        handleMotionlist(motionObjects: SingletonList<BaseRender>): void;
        reCaculateAllRenderObjects(renders: SingletonList<BaseRender>): void;
        destroy(): void;
    }
    /**
     * <code>BaseCamera</code> 类用于创建摄像机的父类。
     */
    class BaseCamera extends Sprite3D {
        /**渲染模式,延迟光照渲染，暂未开放。*/
        static RENDERINGTYPE_DEFERREDLIGHTING: string;
        /**渲染模式,前向渲染。*/
        static RENDERINGTYPE_FORWARDRENDERING: string;
        /**
         * Camera Init
         */
        static __init__(): void;
        /** 近裁剪面。*/
        protected _nearPlane: number;
        /** 远裁剪面。*/
        protected _farPlane: number;
        /**渲染引擎 */
        protected _renderEngine: IRenderEngine;
        /** 视野。*/
        private _fieldOfView;
        /** 正交投影的垂直尺寸。*/
        private _orthographicVerticalSize;
        /** skyRender */
        private _skyRenderer;
        /** 前向量*/
        _forward: Vector3;
        /** up向量 */
        _up: Vector3;
        /** 是否正交 */
        protected _orthographic: boolean;
        /**摄像机的清除颜色,默认颜色为CornflowerBlue。*/
        private _clearColor;
        get clearColor(): Color;
        set clearColor(value: Color);
        /** 可视层位标记遮罩值,支持混合 例:cullingMask=Math.pow(2,0)|Math.pow(2,1)为第0层和第1层可见。*/
        private _cullingMask;
        /** 渲染时是否用遮挡剔除。 */
        useOcclusionCulling: boolean;
        /**
         * 天空渲染器。
         */
        get skyRenderer(): SkyRenderer;
        /**
         * 视野。
         */
        get fieldOfView(): number;
        set fieldOfView(value: number);
        /**
       * 最大本地距离
       */
        get maxlocalYDistance(): number;
        /**
         * 近裁面。
         */
        get nearPlane(): number;
        set nearPlane(value: number);
        /**
         * 远裁面。
         */
        get farPlane(): number;
        set farPlane(vaule: number);
        /**
         * 是否正交投影矩阵。
         */
        get orthographic(): boolean;
        set orthographic(vaule: boolean);
        /**
         * 正交投影垂直矩阵尺寸。
         */
        get orthographicVerticalSize(): number;
        set orthographicVerticalSize(vaule: number);
        get cullingMask(): number;
        set cullingMask(value: number);
        /**
         * 渲染顺序
         */
        get renderingOrder(): number;
        set renderingOrder(value: number);
        /**
         * 创建一个 <code>BaseCamera</code> 实例。
         * @param	fieldOfView 视野。
         * @param	nearPlane 近裁面。
         * @param	farPlane 远裁面。
         */
        constructor(nearPlane?: number, farPlane?: number);
        private _caculateMaxLocalYRange;
        /**
         * 增加可视图层,layer值为0到31层。
         * @param layer 图层。
         */
        addLayer(layer: number): void;
        /**
         * 移除可视图层,layer值为0到31层。
         * @param layer 图层。
         */
        removeLayer(layer: number): void;
        /**
         * 增加所有图层。
         */
        addAllLayers(): void;
        /**
         * 移除所有图层。
         */
        removeAllLayers(): void;
        /**
         * 重算计算投影矩阵
         */
        resetProjectionMatrix(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected _onActive(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected _onInActive(): void;
        /**
         * 删除相机
         * @inheritDoc
         * @override
         * @param 是否删除节点
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * 相机清除标记。
     */
    enum CameraClearFlags {
        /**固定颜色。*/
        SolidColor = 0,
        /**天空。*/
        Sky = 1,
        /**仅深度。*/
        DepthOnly = 2,
        /**不清除。*/
        Nothing = 3,
        /**只清理颜色 */
        ColorOnly = 4
    }
    /**
     * 相机事件标记
     */
    enum CameraEventFlags {
        /**在渲染非透明物体之前。*/
        BeforeForwardOpaque = 0,
        /**在渲染天空盒之前。*/
        BeforeSkyBox = 2,
        /**在渲染透明物体之前。*/
        BeforeTransparent = 4,
        /**在后期处理之前。*/
        BeforeImageEffect = 6,
        /**所有渲染之后。*/
        AfterEveryThing = 8
    }
    /**
     * <code>Camera</code> 类用于创建摄像机。
     */
    class Camera extends BaseCamera {
        static _contextScissorPortCatch: Vector4;
        static set _updateMark(value: number);
        static get _updateMark(): number;
        /**
         * 根据相机、scene信息获得scene中某一位置的渲染结果
         * @param camera 相机
         * @param scene 需要渲染的场景
         * @param shader 着色器
         * @param replacementTag 替换标记。
         */
        static drawRenderTextureByScene(camera: Camera, scene: Scene3D, renderTexture: RenderTexture, shader?: Shader3D, replaceFlag?: string): RenderTexture;
        /**
         * get PixelTexture
         * @param texture
         * @returns
         */
        static getTexturePixel(texture: Texture2D): ArrayBufferView;
        /**
         * 根据场景中的位置
         * @param position
         * @param scene
         * @param renderCubeSize
         * @param format
         * @returns bake front left right up down
         */
        static drawTextureCubePixelByScene(camera: Camera, scene: Scene3D, renderCubeSize: number, format: TextureFormat, cullingMask: number): ArrayBufferView[];
        static drawTextureCubeByScene(camera: Camera, position: Vector3, scene: Scene3D, renderCubeSize: number, format: TextureFormat, cullingMask?: number): TextureCube;
        /**深度贴图模式 */
        protected _depthTextureFormat: RenderTargetFormat;
        /** 深度贴图*/
        private _depthTexture;
        /** 深度法线贴图*/
        private _depthNormalsTexture;
        /** 非透明物体贴图 */
        private _opaqueTexture;
        /** 是否开启非透明物体通道 */
        private _opaquePass;
        private _cameraEventCommandBuffer;
        /**是否允许渲染。*/
        enableRender: boolean;
        /**清除标记。*/
        clearFlag: CameraClearFlags;
        /**是否缓存上一帧的Depth纹理 */
        _cacheDepth: boolean;
        /**cache 上一帧纹理 */
        _cacheDepthTexture: RenderTexture;
        /**
         * 横纵比。
         */
        get aspectRatio(): number;
        set aspectRatio(value: number);
        /**
         * 获取屏幕像素坐标的视口。
         */
        get viewport(): Viewport;
        set viewport(value: Viewport);
        get clientWidth(): number;
        get clientHeight(): number;
        /**
         * 多重采样抗锯齿
         */
        set msaa(value: boolean);
        get msaa(): boolean;
        /**
         * 空间抗锯齿
         */
        set fxaa(value: boolean);
        get fxaa(): boolean;
        /**
         * 裁剪空间的视口。
         */
        get normalizedViewport(): Viewport;
        set normalizedViewport(value: Viewport);
        /**
         * 获取视图矩阵。
         */
        get viewMatrix(): Matrix4x4;
        /**
         * 投影矩阵。
         */
        get projectionMatrix(): Matrix4x4;
        set projectionMatrix(value: Matrix4x4);
        /**
         * 获取视图投影矩阵。
         */
        get projectionViewMatrix(): Matrix4x4;
        /**
         * 获取摄像机视锥。
         */
        get boundFrustum(): BoundFrustum;
        /**
         * 自定义渲染场景的渲染目标。
         */
        get renderTarget(): RenderTexture;
        set renderTarget(value: RenderTexture);
        /**
         * 后期处理。
         */
        get postProcess(): PostProcess;
        set postProcess(value: PostProcess);
        /**
         * 是否开启HDR。
         * 开启后对性能有一定影响。
         */
        get enableHDR(): boolean;
        set enableHDR(value: boolean);
        /**
         * 是否使用正在渲染的RenderTexture为CommandBuffer服务，设置为true
         * 一般和CommandBuffer一起使用
         */
        get enableBuiltInRenderTexture(): boolean;
        set enableBuiltInRenderTexture(value: boolean);
        /**
         * 深度贴图模式
         */
        get depthTextureMode(): DepthTextureMode;
        set depthTextureMode(value: DepthTextureMode);
        /**
         * 设置OpaquePass模式
         */
        set opaquePass(value: boolean);
        get opaquePass(): boolean;
        /**
         * 深度贴图格式
         */
        get depthTextureFormat(): RenderTargetFormat;
        set depthTextureFormat(value: RenderTargetFormat);
        /**
         * 设置是否使用内置的深度贴图(TODO:如果开启,只可在后期使用深度贴图，不可在渲染流程中使用)
         */
        set enableBlitDepth(value: boolean);
        get enableBlitDepth(): boolean;
        get canblitDepth(): boolean;
        /**
         * 创建一个 <code>Camera</code> 实例。
         * @param	aspectRatio 横纵比。
         * @param	nearPlane 近裁面。
         * @param	farPlane 远裁面。
         */
        constructor(aspectRatio?: number, nearPlane?: number, farPlane?: number);
        /**
         *	通过蒙版值获取蒙版是否显示。
         * 	@param  layer 层。
         * 	@return 是否显示。
         */
        _isLayerVisible(layer: number): boolean;
        clone(): Camera;
        /**
         * 渲染结果是否是Gamma
         * @param rt
         */
        _needRenderGamma(rt: RenderTargetFormat): boolean;
        /**
         * update Camera Render
         * @param context
         */
        _updateCameraRenderData(context: RenderContext3D): void;
        /**
         * 调用渲染命令流
         * @param event
         * @param renderTarget
         * @param context
         */
        _applyCommandBuffer(event: number, context: RenderContext3D): void;
        recoverRenderContext3D(context: RenderContext3D, renderTexture: RenderTexture): void;
        set depthTexture(value: BaseTexture);
        set depthNormalTexture(value: RenderTexture);
        _createOpaqueTexture(currentTarget: RenderTexture, renderContext: RenderContext3D): void;
        /**
         * @override
         * @param shader 着色器
         * @param replacementTag 替换标记。
         */
        render(shader?: Shader3D, replacementTag?: string): void;
        /**
         * 计算从屏幕空间生成的射线。
         * @param point 屏幕空间的位置位置。
         * @param out  输出射线。
         */
        viewportPointToRay(point: Vector2, out: Ray): void;
        /**
         * 计算从裁切空间生成的射线。
         * @param point 裁切空间的位置。
         * @param out  输出射线。
         */
        normalizedViewportPointToRay(point: Vector2, out: Ray): void;
        /**
         * 将一个点从世界空间转换到视口空间。
         * @param position 世界空间的坐标。
         * @param out  x、y、z为视口空间坐标,w为相对于摄像机的z轴坐标。
         */
        worldToViewportPoint(position: Vector3, out: Vector4): void;
        /**
         * 将一个点从世界空间转换到归一化视口空间。
         * @param position 世界空间的坐标。
         * @param out  x、y、z为归一化视口空间坐标,w为相对于摄像机的z轴坐标。
         */
        worldToNormalizedViewportPoint(position: Vector3, out: Vector4): void;
        /**
         * 转换2D屏幕坐标系统到3D正交投影下的坐标系统，注:只有正交模型下有效。
         * @param   source 源坐标。
         * @param   out 输出坐标。
         * @return 是否转换成功。
         */
        convertScreenCoordToOrthographicCoord(source: Vector3, out: Vector3): boolean;
        /**
         * @inheritDoc
         * @override
         */
        destroy(destroyChild?: boolean): void;
        /**
         * 增加camera渲染节点渲染缓存
         * @param event 相机事件标志
         * @param commandBuffer 渲染命令流
         */
        addCommandBuffer(event: CameraEventFlags, commandBuffer: CommandBuffer): void;
        /**
         * 移除camera渲染节点渲染缓存
         * @param event 相机事件标志
         * @param commandBuffer 渲染命令流
         */
        removeCommandBuffer(event: CameraEventFlags, commandBuffer: CommandBuffer): void;
        /**
         * 移除camera相机节点的所有渲染缓存
         * @param event 相机事件标志
         */
        removeCommandBuffers(event: CameraEventFlags): void;
    }
    /**
         * <code>FloatKeyFrame</code> 类用于创建浮点关键帧实例。
         */
    class FloatKeyframe extends Keyframe {
        /**内切线 */
        inTangent: number;
        /**外切线 */
        outTangent: number;
        /**帧数据 */
        value: number;
        /**内权重 */
        inWeight: number;
        /**外权重 */
        outWeight: number;
        /**权重模式 */
        weightedMode: number;
        /**
         * 创建一个 <code>FloatKeyFrame</code> 实例。
         */
        constructor();
        /**
         * 克隆数据
         * @inheritDoc
         * @override
         */
        cloneTo(destObject: any): void;
        clone(): FloatKeyframe;
    }
    /**
     * <code>GeometryElement</code> 类用于实现几何体元素,该类为抽象类。
     */
    class GeometryElement {
        protected _owner: any;
        static _typeCounter: number;
        _geometryElementOBj: IRenderGeometryElement;
        /**
         * VAO OBJ
         */
        set bufferState(value: BufferState);
        get bufferState(): BufferState;
        /**
         * mesh topology type
         */
        set mode(value: MeshTopology);
        get mode(): MeshTopology;
        /**
         * draw Type
         */
        set drawType(value: number);
        get drawType(): number;
        setDrawArrayParams(first: number, count: number): void;
        setDrawElemenParams(count: number, offset: number): void;
        set instanceCount(value: number);
        get instanceCount(): number;
        set indexFormat(value: IndexFormat);
        get indexFormat(): IndexFormat;
        /**
         * 获取是否销毁。
         * @return 是否销毁。
         */
        get destroyed(): boolean;
        /**
         * 创建一个 <code>GeometryElement</code> 实例。
         */
        constructor(mode: MeshTopology, drawType: DrawType);
        /**
         * 获取几何体类型。
         */
        _getType(): number;
        /**
         * 销毁。
         */
        destroy(): void;
        clearRenderParams(): void;
    }
    /**
     * <code>Gradient</code> 类用于创建颜色渐变。
     */
    class Gradient implements IClone {
        private _mode;
        private _maxColorRGBKeysCount;
        private _maxColorAlphaKeysCount;
        private _colorRGBKeysCount;
        private _colorAlphaKeysCount;
        /**
         * 获取颜色数据。
         * @return  颜色数据。
         */
        get rgbElements(): Float32Array;
        /**
         * 获取 alpha数据。
         * @return  alpha数据。
         */
        get alphaElements(): Float32Array;
        /**
         * 获取梯度模式。
         * @return  梯度模式。
         */
        get mode(): number;
        /**
         * 设置梯度模式。
         * @param value 梯度模式。
         */
        set mode(value: number);
        /**
         * 获取颜色RGB数量。
         * @return 颜色RGB数量。
         */
        get colorRGBKeysCount(): number;
        /**
         * 获取颜色Alpha数量。
         * @return 颜色Alpha数量。
         */
        get colorAlphaKeysCount(): number;
        /**
         * 获取最大颜色RGB帧数量。
         * @return 最大RGB帧数量。
         */
        get maxColorRGBKeysCount(): number;
        /**
         * 获取最大颜色Alpha帧数量。
         * @return 最大Alpha帧数量。
         */
        get maxColorAlphaKeysCount(): number;
        /**
         * 创建一个 <code>Gradient</code> 实例。
         * @param maxColorRGBKeyCount 最大RGB帧个数。
         * @param maxColorAlphaKeyCount 最大Alpha帧个数。
         */
        constructor(maxColorRGBKeyCount: number, maxColorAlphaKeyCount: number);
        /**
         * 增加颜色RGB帧。
         * @param	key 生命周期，范围为0到1。
         * @param	value RGB值。
         */
        addColorRGB(key: number, value: Color): void;
        /**
         * 增加颜色Alpha帧。
         * @param	key 生命周期，范围为0到1。
         * @param	value Alpha值。
         */
        addColorAlpha(key: number, value: number): void;
        /**
         * 更新颜色RGB帧。
         * @param   index 索引。
         * @param	key 生命周期，范围为0到1。
         * @param	value RGB值。
         */
        updateColorRGB(index: number, key: number, value: Color): void;
        /**
         * 更新颜色Alpha帧。
         * @param   index 索引。
         * @param	key 生命周期，范围为0到1。
         * @param	value Alpha值。
         */
        updateColorAlpha(index: number, key: number, value: number): void;
        /**
         * 通过插值获取RGB颜色。
         * @param  lerpFactor 插值因子。
         * @param  out 颜色结果。
         * @param  开始查找索引。
         * @return 结果索引。
         */
        evaluateColorRGB(lerpFactor: number, out: Color, startSearchIndex?: number, reverseSearch?: boolean): number;
        /**
         * 通过插值获取透明值。
         * @param  lerpFactor 插值因子。
         * @param  out 颜色结果。
         * @param  开始查找索引。
         * @return 结果索引 。
         */
        evaluateColorAlpha(lerpFactor: number, outColor: Color, startSearchIndex?: number, reverseSearch?: boolean): number;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
         * ...
         * @author ...
         */
    class GradientMode {
        /**
         * 找到与请求的评估时间相邻的两个键,并线性插值在他们之间,以获得一种混合的颜色。
         */
        static Blend: number;
        /**
         * 返回一个固定的颜色，通过查找第一个键的时间值大于所请求的评估时间。
         */
        static Fixed: number;
    }
    /**
     * 动画权重模式
     */
    enum WeightedMode {
        None = 0,
        In = 1,
        Out = 2,
        Both = 3
    }
    /**
     * <code>KeyFrame</code> 类用于创建关键帧实例。
     */
    class Keyframe implements IClone {
        static defaultWeight: number;
        /**时间。*/
        time: number;
        /**
         * 创建一个 <code>KeyFrame</code> 实例。
         */
        constructor();
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    enum AreaShape {
        rectangle = 0,
        ellipse = 1
    }
    /**
     * <code>LightSprite</code> 类用于创建灯光的父类。
     */
    class AreaLightCom extends Light {
        /**
         * 创建一个 <code>AreaLightCoponent</code> 实例。
         */
        constructor();
        /**
          * 灯光烘培类型。
          */
        get lightmapBakedType(): LightMode;
        set lightmapBakedType(value: LightMode);
        /**
         * 面光类型
         */
        get shape(): AreaShape;
        set shape(value: AreaShape);
        /**
         * 光照强度
         */
        set power(value: number);
        get power(): number;
        /**
         * 面光大小
         */
        set size(value: Vector2);
        get size(): Vector2;
        /**
         * 面光辐射角度
         */
        set spread(value: number);
        get spread(): number;
        /**
         * 最大反弹数
         */
        set maxBounces(value: number);
        get maxBounces(): number;
    }
    /**
     * @deprecated
     * <code>DirectionLight</code> 类用于创建平行光。
     */
    class DirectionLight extends LightSprite {
        /**
         * 阴影级联数量。
         */
        get shadowCascadesMode(): ShadowCascadesMode;
        set shadowCascadesMode(value: ShadowCascadesMode);
        /**
         * 二级级联阴影分割比例。
         */
        get shadowTwoCascadeSplits(): number;
        set shadowTwoCascadeSplits(value: number);
        /**
         * 四级级联阴影分割比例,X、Y、Z依次为其分割比例,Z必须大于Y,Y必须大于X。
         */
        get shadowFourCascadeSplits(): Vector3;
        set shadowFourCascadeSplits(value: Vector3);
        /**
         * 创建一个 <code>DirectionLight</code> 实例。
         */
        constructor();
    }
    /**
     * <code>DirectionLight</code> 类用于创建平行光。
     */
    class DirectionLightCom extends Light {
        /**
         * 阴影级联数量。
         */
        get shadowCascadesMode(): ShadowCascadesMode;
        set shadowCascadesMode(value: ShadowCascadesMode);
        /**
         * 二级级联阴影分割比例。
         */
        get shadowTwoCascadeSplits(): number;
        set shadowTwoCascadeSplits(value: number);
        /**
         * 四级级联阴影分割比例,X、Y、Z依次为其分割比例,Z必须大于Y,Y必须大于X。
         */
        get shadowFourCascadeSplits(): Vector3;
        set shadowFourCascadeSplits(value: Vector3);
        /**
         * 创建一个 <code>DirectionLight</code> 实例。
         */
        constructor();
    }
    enum LightType {
        Directional = 0,
        Spot = 1,
        Point = 2,
        Area = 3
    }
    enum LightMode {
        mix = 0,
        realTime = 1,
        bakeOnly = 2
    }
    /**
     * <code>LightSprite</code> 类用于创建灯光的父类。
     */
    class Light extends Component {
        /** 灯光颜色。 */
        color: Color;
        /**
         * 灯光强度。
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * 阴影模式。
         */
        get shadowMode(): ShadowMode;
        set shadowMode(value: ShadowMode);
        /**
         * 最大阴影距离。
         */
        get shadowDistance(): number;
        set shadowDistance(value: number);
        /**
         * 阴影贴图分辨率。
         */
        get shadowResolution(): number;
        set shadowResolution(value: number);
        /**
         * 阴影深度偏差。
         */
        get shadowDepthBias(): number;
        set shadowDepthBias(value: number);
        /**
         * 阴影法线偏差。
         */
        get shadowNormalBias(): number;
        set shadowNormalBias(value: number);
        /**
         * 阴影强度。
         */
        get shadowStrength(): number;
        set shadowStrength(value: number);
        /**
         * 阴影视锥的近裁面。
         */
        get shadowNearPlane(): number;
        set shadowNearPlane(value: number);
        /**
         * 灯光烘培类型。
         */
        get lightmapBakedType(): LightMode;
        set lightmapBakedType(value: LightMode);
        get lightWorldMatrix(): Matrix4x4;
        get lightType(): LightType;
        /**
         * 创建一个 <code>LightSprite</code> 实例。
         */
        constructor();
        protected _onEnable(): void;
        protected _onDisable(): void;
        protected _onDestroy(): void;
    }
    /**
     * @deprecated
     * <code>LightSprite</code> 类用于创建灯光的父类。
     */
    class LightSprite extends Sprite3D {
        /**
         * 灯光颜色。
         */
        get color(): Color;
        set color(value: Color);
        get mode(): LightMode;
        set mode(value: LightMode);
        /**
         * 灯光强度。
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * 阴影模式。
         */
        get shadowMode(): ShadowMode;
        set shadowMode(value: ShadowMode);
        /**
         * 最大阴影距离。
         */
        get shadowDistance(): number;
        set shadowDistance(value: number);
        /**
         * 阴影贴图分辨率。
         */
        get shadowResolution(): number;
        set shadowResolution(value: number);
        /**
         * 阴影深度偏差。
         */
        get shadowDepthBias(): number;
        set shadowDepthBias(value: number);
        /**
         * 阴影法线偏差。
         */
        get shadowNormalBias(): number;
        set shadowNormalBias(value: number);
        /**
         * 阴影强度。
         */
        get shadowStrength(): number;
        set shadowStrength(value: number);
        /**
         * 阴影视锥的近裁面。
         */
        get shadowNearPlane(): number;
        set shadowNearPlane(value: number);
        /**
         * 灯光烘培类型。
         */
        get lightmapBakedType(): number;
        set lightmapBakedType(value: number);
        get lightWorldMatrix(): Matrix4x4;
        /**
         * 创建一个 <code>LightSprite</code> 实例。
         */
        constructor();
    }
    /**
     * @deprecated
     * <code>PointLight</code> 类用于创建点光。
     */
    class PointLight extends LightSprite {
        /**
         * 点光的范围。
         * @return 点光的范围。
         */
        get range(): number;
        set range(value: number);
        /**
         * 创建一个 <code>PointLight</code> 实例。
         */
        constructor();
    }
    class PointLightCom extends Light {
        /**
         * 点光的范围。
         * @return 点光的范围。
         */
        get range(): number;
        set range(value: number);
        /**
         * 创建一个 <code>PointLight</code> 实例。
         */
        constructor();
    }
    /**
     * 阴影得级联模式。
     */
    enum ShadowCascadesMode {
        /** 无级联。 */
        NoCascades = 0,
        /** 二级级联。 */
        TwoCascades = 1,
        /** 四级级联。 */
        FourCascades = 2
    }
    /**
     * 阴影模式。
     */
    enum ShadowMode {
        /**不产生阴影。*/
        None = 0,
        /**硬阴影，对性能要求较低。*/
        Hard = 1,
        /**低强度软阴影，对性能要求一般。*/
        SoftLow = 2,
        /**高强度软阴影,对性能要求较高。*/
        SoftHigh = 3
    }
    enum ShadowMapFormat {
        bit16 = 0,
        bit24_8 = 1,
        bit32 = 2
    }
    /**
     * @deprecated
     * <code>SpotLight</code> 类用于创建聚光。
     */
    class SpotLight extends LightSprite {
        /**
          * 聚光灯的锥形角度。
          */
        get spotAngle(): number;
        set spotAngle(value: number);
        /**
         * 聚光的范围。
         */
        get range(): number;
        set range(value: number);
        /**
         * 创建一个 <code>SpotLight</code> 实例。
         */
        constructor();
    }
    /**
     * <code>SpotLight</code> 类用于创建聚光。
     */
    class SpotLightCom extends Light {
        /**
          * 聚光灯的锥形角度。
          */
        get spotAngle(): number;
        set spotAngle(value: number);
        /**
         * 聚光的范围。
         */
        get range(): number;
        set range(value: number);
        /**
         * 创建一个 <code>SpotLight</code> 实例。
         */
        constructor();
    }
    /**
     * <code>BlinnPhongMaterial</code> 类用于实现Blinn-Phong材质。
     */
    class BlinnPhongMaterial extends Material {
        /**高光强度数据源_漫反射贴图的Alpha通道。*/
        static SPECULARSOURCE_DIFFUSEMAPALPHA: number;
        /**高光强度数据源_高光贴图的RGB通道。*/
        static SPECULARSOURCE_SPECULARMAP: number;
        /**渲染状态_不透明。*/
        static RENDERMODE_OPAQUE: number;
        /**渲染状态_阿尔法测试。*/
        static RENDERMODE_CUTOUT: number;
        /**渲染状态_透明混合。*/
        static RENDERMODE_TRANSPARENT: number;
        /** 默认材质，禁止修改*/
        static defaultMaterial: BlinnPhongMaterial;
        /**
         * 设置渲染模式。
         * @param 渲染模式
         */
        set renderMode(value: number);
        /**
         * 是否支持顶点色。
         */
        get enableVertexColor(): boolean;
        set enableVertexColor(value: boolean);
        /**
         * 纹理平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * 反照率颜色。
         */
        get albedoColor(): Color;
        set albedoColor(value: Color);
        /**
         * 反照率强度。
         */
        get albedoIntensity(): number;
        set albedoIntensity(value: number);
        /**
         * 高光颜色。
         */
        get specularColor(): Color;
        set specularColor(value: Color);
        /**
         * 高光强度,范围为0到1。
         */
        get shininess(): number;
        set shininess(value: number);
        /**
         * 反照率贴图。
         */
        get albedoTexture(): BaseTexture;
        set albedoTexture(value: BaseTexture);
        /**
         * 法线贴图。
         */
        get normalTexture(): BaseTexture;
        set normalTexture(value: BaseTexture);
        /**
         * 高光贴图。
         */
        get specularTexture(): BaseTexture;
        set specularTexture(value: BaseTexture);
        /**
         * 是否支持透光色。
         */
        get enableTransmission(): boolean;
        set enableTransmission(value: boolean);
        /**
         * 透光率，会影响漫反射以及透光强度
         */
        get transmissionRata(): number;
        set transmissionRata(value: number);
        /**
         * 透射影响范围指数
         */
        get backDiffuse(): number;
        set backDiffuse(value: number);
        /**
         * 透射光强度
         */
        get backScale(): number;
        set backScale(value: number);
        /**
         * 厚度贴图，会影响透视光，越厚，透射光越弱
         */
        get thinknessTexture(): BaseTexture;
        set thinknessTexture(value: BaseTexture);
        /**
         * 透光颜色。模拟透光物质内部颜色吸收率
         */
        get transmissionColor(): Color;
        set transmissionColor(value: Color);
        /**
         * 请使用transmissionRata
         * @deprecated
         */
        get transmissionRate(): number;
        /**
         * 创建一个 <code>BlinnPhongMaterial</code> 实例。
         */
        constructor();
        /**
         * 克隆。
         * @return	 克隆副本。
         * @override
         */
        clone(): any;
        /**
         * @inheritDoc
         * @override
         */
        cloneTo(destObject: any): void;
    }
    /**
     * <code>EffectMaterial</code> 类用于实现Mesh特效材质。
     */
    class EffectMaterial extends Material {
        /** 默认材质，禁止修改*/
        static defaultMaterial: EffectMaterial;
        /**
         * 获取颜色。
         */
        get color(): Color;
        set color(value: Color);
        /**
         * 贴图。
         */
        get texture(): BaseTexture;
        set texture(value: BaseTexture);
        /**
         * 纹理平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * 创建一个 <code>EffectMaterial</code> 实例。
         */
        constructor();
        /**
         * 克隆。
         * @return	 克隆副本。
         * @override
         */
        clone(): any;
        /**
         * @deprecated
         * 渲染状态_加色法混合。
         */
        static RENDERMODE_ADDTIVE: number;
        /**
         * @deprecated
         * 渲染状态_透明混合。*/
        static RENDERMODE_ALPHABLENDED: number;
        /**
         * @deprecated
         * 设置渲染模式。
         * 可以使用新的渲染状态
         */
        set renderMode(value: number);
    }
    /**
     * ...
     * @author ...
     */
    class ExtendTerrainMaterial extends Material {
        /**渲染状态_不透明。*/
        static RENDERMODE_OPAQUE: number;
        /**渲染状态_透明混合。*/
        static RENDERMODE_TRANSPARENT: number;
        /**
         * splatAlpha贴图。
         */
        get splatAlphaTexture(): BaseTexture;
        set splatAlphaTexture(value: BaseTexture);
        /**
         * 第一层贴图。
         */
        get diffuseTexture1(): BaseTexture;
        set diffuseTexture1(value: BaseTexture);
        /**
         * 第二层贴图。
         */
        get diffuseTexture2(): BaseTexture;
        set diffuseTexture2(value: BaseTexture);
        /**
         * 第三层贴图。
         */
        get diffuseTexture3(): BaseTexture;
        set diffuseTexture3(value: BaseTexture);
        /**
         * 第四层贴图。
         */
        get diffuseTexture4(): BaseTexture;
        set diffuseTexture4(value: BaseTexture);
        /**
         * 第五层贴图。
         */
        get diffuseTexture5(): BaseTexture;
        set diffuseTexture5(value: BaseTexture);
        /**
         * 第一层贴图缩放偏移。
         */
        set diffuseScaleOffset1(scaleOffset1: Vector4);
        /**
         * 第二层贴图缩放偏移。
         */
        set diffuseScaleOffset2(scaleOffset2: Vector4);
        /**
         * 第三层贴图缩放偏移。
         */
        set diffuseScaleOffset3(scaleOffset3: Vector4);
        /**
         * 第四层贴图缩放偏移。
         */
        set diffuseScaleOffset4(scaleOffset4: Vector4);
        /**
         * 第五层贴图缩放偏移。
         */
        set diffuseScaleOffset5(scaleOffset5: Vector4);
        /**
         * 设置渲染模式。
         */
        set renderMode(value: number);
        /**
         * 创建一个 <code>ExtendTerrainMaterial</code> 实例。
         */
        constructor();
        /**
        * 克隆。
        * @return	 克隆副本。
        * @override
        */
        clone(): any;
    }
    /**
     * 渲染模式。
     */
    enum PBRRenderMode {
        /**不透明。*/
        Opaque = 0,
        /**透明裁剪。*/
        Cutout = 1,
        /**透明混合_游戏中经常使用的透明。*/
        Fade = 2,
        /**透明混合_物理上看似合理的透明。*/
        Transparent = 3
    }
    /**
     * PBR材质的父类,该类为抽象类。
     */
    class PBRMaterial extends Material {
        /** 渲染质量。*/
        static renderQuality: PBRRenderQuality;
        /**
         * @private
         */
        static __init__(): void;
        /**
         * 漫反射颜色。
         */
        get albedoColor(): Color;
        set albedoColor(value: Color);
        /**
         * 漫反射贴图。
         */
        get albedoTexture(): BaseTexture;
        set albedoTexture(value: BaseTexture);
        /**
         * 法线贴图。
         */
        get normalTexture(): BaseTexture;
        set normalTexture(value: BaseTexture);
        /**
         * 法线贴图缩放系数。
         */
        get normalTextureScale(): number;
        set normalTextureScale(value: number);
        /**
         * 视差贴图。
         */
        get parallaxTexture(): BaseTexture;
        set parallaxTexture(value: BaseTexture);
        /**
         * 视差贴图缩放系数。
         */
        get parallaxTextureScale(): number;
        set parallaxTextureScale(value: number);
        /**
         * 遮挡贴图。
         */
        get occlusionTexture(): BaseTexture;
        set occlusionTexture(value: BaseTexture);
        /**
         * 遮挡贴图强度,范围为0到1。
         */
        get occlusionTextureStrength(): number;
        set occlusionTextureStrength(value: number);
        /**
         * 光滑度,范围为0到1。
         */
        get smoothness(): number;
        set smoothness(value: number);
        /**
          * 是否支持顶点色。
          */
        get enableVertexColor(): boolean;
        set enableVertexColor(value: boolean);
        /**
         * 是否开启自发光。
         */
        get enableEmission(): boolean;
        set enableEmission(value: boolean);
        /**
         * 自发光颜色。
         */
        get emissionColor(): Color;
        set emissionColor(value: Color);
        set emissionIntensity(value: number);
        get emissionIntensity(): number;
        /**
         * 自发光贴图。
         */
        get emissionTexture(): BaseTexture;
        set emissionTexture(value: BaseTexture);
        /**
         * 纹理平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * 细节贴图。
         */
        get detailAlbedoTexture(): BaseTexture;
        set detailAlbedoTexture(value: BaseTexture);
        /**
         * 细节法线贴图。
         */
        get detailNormalTexture(): BaseTexture;
        set detailNormalTexture(value: BaseTexture);
        /**
        * 细节图纹理平铺和偏移。
        */
        get detailTilingOffset(): Vector4;
        set detailTilingOffset(value: Vector4);
        /**
        * 细节法线贴图缩放系数。
        */
        get detailNormalScale(): number;
        set detailNormalScale(value: number);
        /**
         * 渲染模式。
         */
        set renderMode(value: number);
        /**
         * 是否开启 anisotropy
         */
        get anisotropyEnable(): boolean;
        set anisotropyEnable(value: boolean);
        /**
         * anisotropy 强度
         */
        get anisotropy(): number;
        set anisotropy(value: number);
        /**
         * anisotropy 强度贴图
         */
        get anisotropyTexture(): Texture2D;
        set anisotropyTexture(value: Texture2D);
        /**
         * anisotropy 在 切线空间 中的旋转
         */
        get anisotropyRotation(): number;
        set anisotropyRotation(value: number);
        /**
         * 是否开启 clear coat
         */
        get clearCoatEnable(): boolean;
        set clearCoatEnable(value: boolean);
        /**
         * clear coat 层 强度
         */
        get clearCoat(): number;
        set clearCoat(value: number);
        /**
         * clear coat 强度贴图
         */
        get clearCoatTexture(): BaseTexture;
        set clearCoatTexture(value: BaseTexture);
        /**
         * clear coat 层 粗糙度
         */
        get clearCoatRoughness(): number;
        set clearCoatRoughness(value: number);
        /**
         * clear coat 层 粗糙度贴图
         */
        get clearCoatRoughnessTexture(): BaseTexture;
        set clearCoatRoughnessTexture(value: BaseTexture);
        /**
         * clear coat 法线贴图
         */
        get clearCoatNormalTexture(): BaseTexture;
        set clearCoatNormalTexture(value: BaseTexture);
        constructor();
        /**
         * @deprecated
         * 光滑度缩放系数,范围为0到1。
         */
        get smoothnessTextureScale(): number;
        set smoothnessTextureScale(value: number);
    }
    /**
     * PBR材质渲染质量。
     */
    enum PBRRenderQuality {
        /**高质量。*/
        High = 0,
        /**低质量。*/
        Low = 1
    }
    /**
     * 金属度PBR材质光滑度数据源。
     */
    enum PBRMetallicSmoothnessSource {
        /**金属度贴图的Alpha通道。*/
        MetallicGlossTextureAlpha = 0,
        /**反射率贴图的Alpha通道。*/
        AlbedoTextureAlpha = 1
    }
    /**
     * <code>PBRStandardMaterial</code> 类用于实现PBR材质。
     */
    class PBRStandardMaterial extends PBRMaterial {
        /** 默认材质，禁止修改*/
        static defaultMaterial: PBRStandardMaterial;
        /**
         * 金属光滑度贴图。
         */
        get metallicGlossTexture(): BaseTexture;
        set metallicGlossTexture(value: BaseTexture);
        /**
         * 获取金属度,范围为0到1。
         */
        get metallic(): number;
        set metallic(value: number);
        /**
         * 光滑度数据源,0或1。
         */
        get smoothnessSource(): PBRMetallicSmoothnessSource;
        set smoothnessSource(value: PBRMetallicSmoothnessSource);
        /**
         * 创建一个 <code>PBRStandardMaterial</code> 实例。
         */
        constructor();
        /**
         * 克隆。
         * @return	 克隆副本。
         * @override
         */
        clone(): any;
    }
    /**
     * <code>SkyBoxMaterial</code> 类用于实现SkyBoxMaterial材质。
     */
    class SkyBoxMaterial extends Material {
        static TINTCOLOR: number;
        static EXPOSURE: number;
        static ROTATION: number;
        static TEXTURECUBE: number;
        /** 默认材质，禁止修改*/
        static defaultMaterial: SkyBoxMaterial;
        /**
         * 颜色。
         */
        get tintColor(): Color;
        set tintColor(value: Color);
        /**
         * 曝光强度。
         */
        get exposure(): number;
        set exposure(value: number);
        /**
         * 旋转角度。
         */
        get rotation(): number;
        set rotation(value: number);
        /**
         * 天空盒纹理。
         */
        get textureCube(): TextureCube;
        set textureCube(value: TextureCube);
        /**
         * 克隆。
         * @return	 克隆副本。
         * @override
         */
        clone(): any;
        /**
         * 创建一个 <code>SkyBoxMaterial</code> 实例。
         */
        constructor();
    }
    /**
     * <code>SkyPanoramicMaterial</code> 类用于实现SkyPanoramicMaterial材质。
     */
    class SkyPanoramicMaterial extends Material {
        static TINTCOLOR: number;
        static EXPOSURE: number;
        static ROTATION: number;
        static TEXTURE: number;
        static TEXTURE_HDR_PARAMS: number;
        /**
         * 颜色。
         */
        get tintColor(): Color;
        set tintColor(value: Color);
        /**
         * 曝光强度。
         */
        get exposure(): number;
        set exposure(value: number);
        /**
         * 旋转角度。
         */
        get rotation(): number;
        set rotation(value: number);
        /**
         * 全景天空纹理。
         */
        get panoramicTexture(): Texture2D;
        set panoramicTexture(value: Texture2D);
        /**
         * 创建一个 <code>SkyPanoramicMaterial</code> 实例。
         */
        constructor();
    }
    /**
     * <code>SkyProceduralMaterial</code> 类用于实现SkyProceduralMaterial材质。
     */
    class SkyProceduralMaterial extends Material {
        /** 太阳_无*/
        static SUN_NODE: number;
        /** 太阳_精简*/
        static SUN_SIMPLE: number;
        /** 太阳_高质量*/
        static SUN_HIGH_QUALITY: number;
        /** 默认材质，禁止修改*/
        static defaultMaterial: SkyProceduralMaterial;
        /**
         * 太阳状态。
         */
        get sunDisk(): number;
        set sunDisk(value: number);
        /**
         * 太阳尺寸,范围是0到1。
         */
        get sunSize(): number;
        set sunSize(value: number);
        /**
         * 太阳尺寸收缩,范围是0到20。
         */
        get sunSizeConvergence(): number;
        set sunSizeConvergence(value: number);
        /**
         * 大气厚度,范围是0到5。
         */
        get atmosphereThickness(): number;
        set atmosphereThickness(value: number);
        /**
         * 天空颜色。
         */
        get skyTint(): Color;
        set skyTint(value: Color);
        /**
         * 地面颜色。
         */
        get groundTint(): Color;
        set groundTint(value: Color);
        /**
         * 曝光强度,范围是0到8。
         */
        get exposure(): number;
        set exposure(value: number);
        /**
         * 创建一个 <code>SkyProceduralMaterial</code> 实例。
         */
        constructor();
        /**
         * 克隆。
         * @return	 克隆副本。
         * @override
         */
        clone(): any;
    }
    /**
     * <code>UnlitMaterial</code> 类用于实现不受光照影响的材质。
     */
    class UnlitMaterial extends Material {
        static SHADERDEFINE_ALBEDOTEXTURE: ShaderDefine;
        static SHADERDEFINE_ENABLEVERTEXCOLOR: ShaderDefine;
        static ALBEDOTEXTURE: number;
        static ALBEDOCOLOR: number;
        static TILINGOFFSET: number;
        private _albedoIntensity;
        /**
         * 反照率颜色。
         */
        get albedoColor(): Color;
        set albedoColor(value: Color);
        /**
         * 反照率强度。
         */
        get albedoIntensity(): number;
        set albedoIntensity(value: number);
        /**
         * 反照率贴图。
         */
        get albedoTexture(): BaseTexture;
        set albedoTexture(value: BaseTexture);
        /**
         * 纹理平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * 是否支持顶点色。
         */
        get enableVertexColor(): boolean;
        set enableVertexColor(value: boolean);
        constructor();
        /**
         * 克隆。
         * @return	 克隆副本。
         * @override
         */
        clone(): any;
        /**
         * @deprecated
         * 渲染状态_不透明。
         */
        static RENDERMODE_OPAQUE: number;
        /**
         * @deprecated
         * 渲染状态_阿尔法测试。
        */
        static RENDERMODE_CUTOUT: number;
        /**
         * @deprecated
         * 渲染状态__透明混合。
         */
        static RENDERMODE_TRANSPARENT: number;
        /**
         * @deprecated
         * 渲染状态__加色法混合。
         */
        static RENDERMODE_ADDTIVE: number;
        /**
         * @deprecated
         * 渲染模式。
         */
        set renderMode(value: number);
    }
    /**
     * <code>WaterPrimaryMaterial</code> 类用于实现水材质。
     */
    class WaterPrimaryMaterial extends Material {
        static HORIZONCOLOR: number;
        static MAINTEXTURE: number;
        static NORMALTEXTURE: number;
        static WAVESCALE: number;
        static WAVESPEED: number;
        static SHADERDEFINE_MAINTEXTURE: ShaderDefine;
        static SHADERDEFINE_NORMALTEXTURE: ShaderDefine;
        /** 默认材质，禁止修改*/
        static defaultMaterial: WaterPrimaryMaterial;
        /**
         * 地平线颜色。
         */
        get horizonColor(): Vector4;
        set horizonColor(value: Vector4);
        /**
         * 主贴图。
         */
        get mainTexture(): BaseTexture;
        set mainTexture(value: BaseTexture);
        /**
         * 法线贴图。
         */
        get normalTexture(): BaseTexture;
        set normalTexture(value: BaseTexture);
        /**
         * 波动缩放系数。
         */
        get waveScale(): number;
        set waveScale(value: number);
        /**
         * 波动速率。
         */
        get waveSpeed(): Vector4;
        set waveSpeed(value: Vector4);
        constructor();
        /**
         * 克隆。
         * @return	 克隆副本。
         * @override
         */
        clone(): any;
    }
    /**
     * <code>MeshFilter</code> 类用于创建网格过滤器。
     */
    class MeshFilter extends Component {
        constructor();
        /**
         * 共享网格。
         */
        get sharedMesh(): Mesh;
        set sharedMesh(value: Mesh);
        protected _onDestroy(): void;
    }
    /**
     * <code>MeshRenderer</code> 类用于网格渲染器。
     */
    class MeshRenderer extends BaseRender {
        private morphTargetActiveCount;
        private morphTargetActiveWeight;
        private morphTargetActiveIndex;
        private morphtargetChannels;
        private _morphWeightChange;
        /**
         * 创建一个新的 <code>MeshRender</code> 实例。
         */
        constructor();
        /**@intermal */
        getMesh(): Mesh;
        protected _changeVertexDefine(mesh: Mesh): void;
        private _morphTargetValues;
        /**
         * 设置 morph target 通道 权重
         * @param channelName 通道名
         * @param weight 权重值
         */
        setMorphChannelWeight(channelName: string, weight: number): void;
        /**
         * 更新 morph target 数据
         */
        protected _applyMorphdata(): void;
        /**
         * 更新 mesh 时 更新 morph target data (shader define)
         * @param mesh
         */
        protected _changeMorphData(mesh: Mesh): void;
        protected _onDestroy(): void;
        /**
         * @override
         * @param dest
         */
        _cloneTo(dest: Component): void;
    }
    /**
     * @deprecated
     * <code>MeshSprite3D</code> 类用于创建网格。
     */
    class MeshSprite3D extends RenderableSprite3D {
        private _meshFilter;
        /**
         * 网格过滤器。
         */
        get meshFilter(): MeshFilter;
        /**
         * 网格渲染器。
         */
        get meshRenderer(): MeshRenderer;
        /**
         * 创建一个 <code>MeshSprite3D</code> 实例。
         * @param mesh 网格,同时会加载网格所用默认材质。
         * @param name 名字。
         */
        constructor(mesh?: Mesh, name?: string);
    }
    /**
     * 类用来记录精灵数据宏
     */
    class MeshSprite3DShaderDeclaration {
        /**UV0通道顶点数据宏 */
        static SHADERDEFINE_UV0: ShaderDefine;
        /**顶点色顶点数据宏 */
        static SHADERDEFINE_COLOR: ShaderDefine;
        /**UV1通道顶点数据宏 */
        static SHADERDEFINE_UV1: ShaderDefine;
        /** Tangent 通道顶点数据宏 */
        static SHADERDEFINE_TANGENT: ShaderDefine;
        /**instance调用宏 */
        static SHADERDEFINE_GPU_INSTANCE: ShaderDefine;
    }
    /**
     * <code>Burst</code> 类用于粒子的爆裂描述。
     */
    class Burst implements IClone {
        /** 爆裂时间,单位为秒。*/
        private _time;
        /** 爆裂的最小数量。*/
        private _minCount;
        /** 爆裂的最大数量。*/
        private _maxCount;
        /**
         * 获取爆裂时间,单位为秒。
         * @return 爆裂时间,单位为秒。
         */
        get time(): number;
        /**
         * 获取爆裂的最小数量。
         * @return 爆裂的最小数量。
         */
        get minCount(): number;
        /**
         * 获取爆裂的最大数量。
         * @return 爆裂的最大数量。
         */
        get maxCount(): number;
        /**
         * 创建一个 <code>Burst</code> 实例。
         * @param time 爆裂时间,单位为秒。
         * @param minCount 爆裂的最小数量。
         * @param time 爆裂的最大数量。
         */
        constructor(time?: number, minCount?: number, maxCount?: number);
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>ColorOverLifetime</code> 类用于粒子的生命周期颜色。
     */
    class ColorOverLifetime {
        private _color;
        /**是否启用。*/
        enable: boolean;
        /**
         *获取颜色。
         */
        get color(): GradientColor;
        /**
         * 创建一个 <code>ColorOverLifetime</code> 实例。
         */
        constructor(color: GradientColor);
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>Emission</code> 类用于粒子发射器。
     */
    class Emission implements IClone {
        private _emissionRateOverDistance;
        /**是否启用。*/
        enable: boolean;
        /**
         * 设置粒子发射速率。
         * @param emissionRate 粒子发射速率 (个/秒)。
         */
        set emissionRate(value: number);
        /**
         * 获取粒子发射速率。
         * @return 粒子发射速率 (个/秒)。
         */
        get emissionRate(): number;
        get emissionRateOverDistance(): number;
        set emissionRateOverDistance(value: number);
        /**
         * 获取是否已销毁。
         * @return 是否已销毁。
         */
        get destroyed(): boolean;
        /**
         * 创建一个 <code>Emission</code> 实例。
         */
        constructor();
        /**
         * @private
         */
        destroy(): void;
        /**
         * 获取粒子爆裂个数。
         * @return 粒子爆裂个数。
         */
        getBurstsCount(): number;
        /**
         * 通过索引获取粒子爆裂。
         * @param index 爆裂索引。
         * @return 粒子爆裂。
         */
        getBurstByIndex(index: number): Burst;
        /**
         * 增加粒子爆裂。
         * @param burst 爆裂。
         */
        addBurst(burst: Burst): void;
        /**
         * 移除粒子爆裂。
         * @param burst 爆裂。
         */
        removeBurst(burst: Burst): void;
        /**
         * 通过索引移除粒子爆裂。
         * @param index 爆裂索引。
         */
        removeBurstByIndex(index: number): void;
        /**
         * 清空粒子爆裂。
         */
        clearBurst(): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>FrameOverTime</code> 类用于创建时间帧。
     */
    class FrameOverTime implements IClone {
        /**
         * 通过固定帧创建一个 <code>FrameOverTime</code> 实例。
         * @param	constant 固定帧。
         * @return 时间帧。
         */
        static createByConstant(constant?: number): FrameOverTime;
        /**
         * 通过时间帧创建一个 <code>FrameOverTime</code> 实例。
         * @param	overTime 时间帧。
         * @return 时间帧。
         */
        static createByOverTime(overTime: GradientDataInt): FrameOverTime;
        /**
         * 通过随机双固定帧创建一个 <code>FrameOverTime</code> 实例。
         * @param	constantMin 最小固定帧。
         * @param	constantMax 最大固定帧。
         * @return 时间帧。
         */
        static createByRandomTwoConstant(constantMin?: number, constantMax?: number): FrameOverTime;
        /**
         * 通过随机双时间帧创建一个 <code>FrameOverTime</code> 实例。
         * @param	gradientFrameMin 最小时间帧。
         * @param	gradientFrameMax 最大时间帧。
         * @return 时间帧。
         */
        static createByRandomTwoOverTime(gradientFrameMin: GradientDataInt, gradientFrameMax: GradientDataInt): FrameOverTime;
        private _type;
        private _constant;
        private _overTime;
        private _constantMin;
        private _constantMax;
        private _overTimeMin;
        private _overTimeMax;
        /**
         *生命周期旋转类型,0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
         */
        get type(): number;
        /**
         * 固定帧。
         */
        get constant(): number;
        /**
         * 时间帧。
         */
        get frameOverTimeData(): GradientDataInt;
        /**
         * 最小固定帧。
         */
        get constantMin(): number;
        /**
         * 最大固定帧。
         */
        get constantMax(): number;
        /**
         * 最小时间帧。
         */
        get frameOverTimeDataMin(): GradientDataInt;
        /**
         * 最大时间帧。
         */
        get frameOverTimeDataMax(): GradientDataInt;
        /**
         * 创建一个 <code>FrameOverTime,不允许new，请使用静态创建函数。</code> 实例。
         */
        constructor();
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>GradientRotation</code> 类用于创建渐变角速度。
     */
    class GradientAngularVelocity implements IClone {
        /**
         * 通过固定角速度创建一个 <code>GradientAngularVelocity</code> 实例。
         * @param	constant 固定角速度。
         * @return 渐变角速度。
         */
        static createByConstant(constant: number): GradientAngularVelocity;
        /**
         * 通过分轴固定角速度创建一个 <code>GradientAngularVelocity</code> 实例。
         * @param	separateConstant 分轴固定角速度。
         * @return 渐变角速度。
         */
        static createByConstantSeparate(separateConstant: Vector3): GradientAngularVelocity;
        /**
         * 通过渐变角速度创建一个 <code>GradientAngularVelocity</code> 实例。
         * @param	gradient 渐变角速度。
         * @return 渐变角速度。
         */
        static createByGradient(gradient: GradientDataNumber): GradientAngularVelocity;
        /**
         * 通过分轴渐变角速度创建一个 <code>GradientAngularVelocity</code> 实例。
         * @param	gradientX X轴渐变角速度。
         * @param	gradientY Y轴渐变角速度。
         * @param	gradientZ Z轴渐变角速度。
         * @return  渐变角速度。
         */
        static createByGradientSeparate(gradientX: GradientDataNumber, gradientY: GradientDataNumber, gradientZ: GradientDataNumber): GradientAngularVelocity;
        /**
         * 通过随机双固定角速度创建一个 <code>GradientAngularVelocity</code> 实例。
         * @param	constantMin 最小固定角速度。
         * @param	constantMax 最大固定角速度。
         * @return 渐变角速度。
         */
        static createByRandomTwoConstant(constantMin: number, constantMax: number): GradientAngularVelocity;
        /**
         * 通过随机分轴双固定角速度创建一个 <code>GradientAngularVelocity</code> 实例。
         * @param	separateConstantMin  最小分轴固定角速度。
         * @param	separateConstantMax  最大分轴固定角速度。
         * @return  渐变角速度。
         */
        static createByRandomTwoConstantSeparate(separateConstantMin: Vector3, separateConstantMax: Vector3): GradientAngularVelocity;
        /**
         * 通过随机双渐变角速度创建一个 <code>GradientAngularVelocity</code> 实例。
         * @param	gradientMin 最小渐变角速度。
         * @param	gradientMax 最大渐变角速度。
         * @return  渐变角速度。
         */
        static createByRandomTwoGradient(gradientMin: GradientDataNumber, gradientMax: GradientDataNumber): GradientAngularVelocity;
        /**
         * 通过分轴随机双渐变角速度创建一个 <code>GradientAngularVelocity</code> 实例。
         * @param	gradientXMin  最小X轴渐变角速度。
         * @param	gradientXMax  最大X轴渐变角速度。
         * @param	gradientYMin  最小Y轴渐变角速度。
         * @param	gradientYMax  最大Y轴渐变角速度。
         * @param	gradientZMin  最小Z轴渐变角速度。
         * @param	gradientZMax  最大Z轴渐变角速度。
         * @return  渐变角速度。
         */
        static createByRandomTwoGradientSeparate(gradientXMin: GradientDataNumber, gradientXMax: GradientDataNumber, gradientYMin: GradientDataNumber, gradientYMax: GradientDataNumber, gradientZMin: GradientDataNumber, gradientZMax: GradientDataNumber, gradientWMin: GradientDataNumber, gradientWMax: GradientDataNumber): GradientAngularVelocity;
        private _type;
        private _separateAxes;
        private _constant;
        private _constantSeparate;
        private _gradient;
        private _gradientX;
        private _gradientY;
        private _gradientZ;
        private _gradientW;
        private _constantMin;
        private _constantMax;
        private _constantMinSeparate;
        private _constantMaxSeparate;
        private _gradientMin;
        private _gradientMax;
        private _gradientXMin;
        private _gradientXMax;
        private _gradientYMin;
        private _gradientYMax;
        private _gradientZMin;
        private _gradientZMax;
        private _gradientWMin;
        private _gradientWMax;
        /**
         *生命周期角速度类型,0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
         */
        get type(): number;
        /**
         *是否分轴。
         */
        get separateAxes(): boolean;
        /**
         * 固定角速度。
         */
        get constant(): number;
        /**
         * 分轴固定角速度。
         */
        get constantSeparate(): Vector3;
        /**
         * 渐变角速度。
         */
        get gradient(): GradientDataNumber;
        /**
         * 渐变角角速度X。
         */
        get gradientX(): GradientDataNumber;
        /**
         * 渐变角速度Y。
         */
        get gradientY(): GradientDataNumber;
        /**
         *渐变角速度Z。
         */
        get gradientZ(): GradientDataNumber;
        /**
         *渐变角速度Z。
         */
        get gradientW(): GradientDataNumber;
        /**
         * 最小随机双固定角速度。
         */
        get constantMin(): number;
        /**
         * 最大随机双固定角速度。
         */
        get constantMax(): number;
        /**
         * 最小分轴随机双固定角速度。
         */
        get constantMinSeparate(): Vector3;
        /**
         * 最大分轴随机双固定角速度。
         */
        get constantMaxSeparate(): Vector3;
        /**
         *最小渐变角速度。
         */
        get gradientMin(): GradientDataNumber;
        /**
         * 最大渐变角速度。
         */
        get gradientMax(): GradientDataNumber;
        /**
         * 最小渐变角速度X。
         */
        get gradientXMin(): GradientDataNumber;
        /**
         * 最大渐变角速度X。
         */
        get gradientXMax(): GradientDataNumber;
        /**
         * 最小渐变角速度Y。
         */
        get gradientYMin(): GradientDataNumber;
        /**
         *最大渐变角速度Y。
         */
        get gradientYMax(): GradientDataNumber;
        /**
         * 最小渐变角速度Z。
         */
        get gradientZMin(): GradientDataNumber;
        /**
         * 最大渐变角速度Z。
         */
        get gradientZMax(): GradientDataNumber;
        /**
         * 最小渐变角速度Z。
         */
        get gradientWMin(): GradientDataNumber;
        /**
         * 最大渐变角速度Z。
         */
        get gradientWMax(): GradientDataNumber;
        /**
         * 创建一个 <code>GradientAngularVelocity,不允许new，请使用静态创建函数。</code> 实例。
         */
        constructor();
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>GradientColor</code> 类用于创建渐变颜色。
     */
    class GradientColor implements IClone {
        /**
         * 通过固定颜色创建一个 <code>GradientColor</code> 实例。
         * @param constant 固定颜色。
         */
        static createByConstant(constant: Vector4): GradientColor;
        /**
         * 通过渐变颜色创建一个 <code>GradientColor</code> 实例。
         * @param gradient 渐变色。
         */
        static createByGradient(gradient: Gradient): GradientColor;
        /**
         * 通过随机双固定颜色创建一个 <code>GradientColor</code> 实例。
         * @param minConstant 最小固定颜色。
         * @param maxConstant 最大固定颜色。
         */
        static createByRandomTwoConstant(minConstant: Vector4, maxConstant: Vector4): GradientColor;
        /**
         * 通过随机双渐变颜色创建一个 <code>GradientColor</code> 实例。
         * @param minGradient 最小渐变颜色。
         * @param maxGradient 最大渐变颜色。
         */
        static createByRandomTwoGradient(minGradient: Gradient, maxGradient: Gradient): GradientColor;
        private _type;
        private _constant;
        private _constantMin;
        private _constantMax;
        private _gradient;
        private _gradientMin;
        private _gradientMax;
        /**
         *生命周期颜色类型,0为固定颜色模式,1渐变模式,2为随机双固定颜色模式,3随机双渐变模式。
         */
        get type(): number;
        /**
         * 固定颜色。
         */
        get constant(): Vector4;
        /**
         * 最小固定颜色。
         */
        get constantMin(): Vector4;
        /**
         * 最大固定颜色。
         */
        get constantMax(): Vector4;
        /**
         * 渐变颜色。
         */
        get gradient(): Gradient;
        /**
         * 最小渐变颜色。
         */
        get gradientMin(): Gradient;
        /**
         * 最大渐变颜色。
         */
        get gradientMax(): Gradient;
        /**
         * 创建一个 <code>GradientColor,不允许new，请使用静态创建函数。</code> 实例。
         */
        constructor();
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>GradientDataInt</code> 类用于创建整形渐变。
     */
    class GradientDataInt implements IClone {
        private _currentLength;
        /**整形渐变数量。*/
        get gradientCount(): number;
        /**
         * 创建一个 <code>GradientDataInt</code> 实例。
         */
        constructor();
        /**
         * 增加整形渐变。
         * @param	key 生命周期，范围为0到1。
         * @param	value 整形值。
         */
        add(key: number, value: number): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>GradientDataNumber</code> 类用于创建浮点渐变。
     */
    class GradientDataNumber implements IClone {
        private _currentLength;
        /**渐变浮点数量。*/
        get gradientCount(): number;
        /**
         * 创建一个 <code>GradientDataNumber</code> 实例。
         */
        constructor();
        /**
         * 增加浮点渐变。
         * @param	key 生命周期，范围为0到1。
         * @param	value 浮点值。
         */
        add(key: number, value: number): void;
        /**
         * 通过索引获取键。
         * @param	index 索引。
         * @return	value 键。
         */
        getKeyByIndex(index: number): number;
        /**
         * 通过索引获取值。
         * @param	index 索引。
         * @return	value 值。
         */
        getValueByIndex(index: number): number;
        /**
         * 获取平均值。
         */
        getAverageValue(): number;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>GradientDataVector2</code> 类用于创建二维向量渐变。
     */
    class GradientDataVector2 implements IClone {
        private _currentLength;
        /**二维向量渐变数量。*/
        get gradientCount(): number;
        /**
         * 创建一个 <code>GradientDataVector2</code> 实例。
         */
        constructor();
        /**
         * 增加二维向量渐变。
         * @param	key 生命周期，范围为0到1。
         * @param	value 二维向量值。
         */
        add(key: number, value: Vector2): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>GradientSize</code> 类用于创建渐变尺寸。
     */
    class GradientSize implements IClone {
        /**
         * 通过渐变尺寸创建一个 <code>GradientSize</code> 实例。
         * @param	gradient 渐变尺寸。
         * @return  渐变尺寸。
         */
        static createByGradient(gradient: GradientDataNumber): GradientSize;
        /**
         * 通过分轴渐变尺寸创建一个 <code>GradientSize</code> 实例。
         * @param	gradientX 渐变尺寸X。
         * @param	gradientY 渐变尺寸Y。
         * @param	gradientZ 渐变尺寸Z。
         * @return  渐变尺寸。
         */
        static createByGradientSeparate(gradientX: GradientDataNumber, gradientY: GradientDataNumber, gradientZ: GradientDataNumber): GradientSize;
        /**
         * 通过随机双固定尺寸创建一个 <code>GradientSize</code> 实例。
         * @param	constantMin 最小固定尺寸。
         * @param	constantMax 最大固定尺寸。
         * @return 渐变尺寸。
         */
        static createByRandomTwoConstant(constantMin: number, constantMax: number): GradientSize;
        /**
         * 通过分轴随机双固定尺寸创建一个 <code>GradientSize</code> 实例。
         * @param	constantMinSeparate 分轴最小固定尺寸.
         * @param	constantMaxSeparate 分轴最大固定尺寸。
         * @return   渐变尺寸。
         */
        static createByRandomTwoConstantSeparate(constantMinSeparate: Vector3, constantMaxSeparate: Vector3): GradientSize;
        /**
         * 通过随机双渐变尺寸创建一个 <code>GradientSize</code> 实例。
         * @param	gradientMin 最小渐变尺寸。
         * @param	gradientMax 最大渐变尺寸。
         * @return 渐变尺寸。
         */
        static createByRandomTwoGradient(gradientMin: GradientDataNumber, gradientMax: GradientDataNumber): GradientSize;
        /**
         * 通过分轴随机双渐变尺寸创建一个 <code>GradientSize</code> 实例。
         * @param	gradientXMin X轴最小渐变尺寸。
         * @param	gradientXMax X轴最大渐变尺寸。
         * @param	gradientYMin Y轴最小渐变尺寸。
         * @param	gradientYMax Y轴最大渐变尺寸。
         * @param	gradientZMin Z轴最小渐变尺寸。
         * @param	gradientZMax Z轴最大渐变尺寸。
         * @return  渐变尺寸。
         */
        static createByRandomTwoGradientSeparate(gradientXMin: GradientDataNumber, gradientXMax: GradientDataNumber, gradientYMin: GradientDataNumber, gradientYMax: GradientDataNumber, gradientZMin: GradientDataNumber, gradientZMax: GradientDataNumber): GradientSize;
        private _type;
        private _separateAxes;
        private _gradient;
        private _gradientX;
        private _gradientY;
        private _gradientZ;
        private _constantMin;
        private _constantMax;
        private _constantMinSeparate;
        private _constantMaxSeparate;
        private _gradientMin;
        private _gradientMax;
        private _gradientXMin;
        private _gradientXMax;
        private _gradientYMin;
        private _gradientYMax;
        private _gradientZMin;
        private _gradientZMax;
        /**
         *生命周期尺寸类型，0曲线模式，1随机双常量模式，2随机双曲线模式。
         */
        get type(): number;
        /**
         *是否分轴。
         */
        get separateAxes(): boolean;
        /**
         * 渐变尺寸。
         */
        get gradient(): GradientDataNumber;
        /**
         * 渐变尺寸X。
         */
        get gradientX(): GradientDataNumber;
        /**
         * 渐变尺寸Y。
         */
        get gradientY(): GradientDataNumber;
        /**
         *渐变尺寸Z。
         */
        get gradientZ(): GradientDataNumber;
        /**
         *最小随机双固定尺寸。
         */
        get constantMin(): number;
        /**
         * 最大随机双固定尺寸。
         */
        get constantMax(): number;
        /**
         * 最小分轴随机双固定尺寸。
         */
        get constantMinSeparate(): Vector3;
        /**
         *  最小分轴随机双固定尺寸。
         */
        get constantMaxSeparate(): Vector3;
        /**
         *渐变最小尺寸。
         */
        get gradientMin(): GradientDataNumber;
        /**
         * 渐变最大尺寸。
         */
        get gradientMax(): GradientDataNumber;
        /**
         * 渐变最小尺寸X。
         */
        get gradientXMin(): GradientDataNumber;
        /**
         * 渐变最大尺寸X。
         */
        get gradientXMax(): GradientDataNumber;
        /**
         * 渐变最小尺寸Y。
         */
        get gradientYMin(): GradientDataNumber;
        /**
         *渐变最大尺寸Y。
         */
        get gradientYMax(): GradientDataNumber;
        /**
         * 渐变最小尺寸Z。
         */
        get gradientZMin(): GradientDataNumber;
        /**
         * 渐变最大尺寸Z。
         */
        get gradientZMax(): GradientDataNumber;
        /**
         * 创建一个 <code>GradientSize,不允许new，请使用静态创建函数。</code> 实例。
         */
        constructor();
        /**
         * 获取最大尺寸。
         */
        getMaxSizeInGradient(meshMode?: boolean): number;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>GradientVelocity</code> 类用于创建渐变速度。
     */
    class GradientVelocity implements IClone {
        /**
         * 通过固定速度创建一个 <code>GradientVelocity</code> 实例。
         * @param	constant 固定速度。
         * @return 渐变速度。
         */
        static createByConstant(constant: Vector3): GradientVelocity;
        /**
         * 通过渐变速度创建一个 <code>GradientVelocity</code> 实例。
         * @param	gradientX 渐变速度X。
         * @param	gradientY 渐变速度Y。
         * @param	gradientZ 渐变速度Z。
         * @return  渐变速度。
         */
        static createByGradient(gradientX: GradientDataNumber, gradientY: GradientDataNumber, gradientZ: GradientDataNumber): GradientVelocity;
        /**
         * 通过随机双固定速度创建一个 <code>GradientVelocity</code> 实例。
         * @param	constantMin 最小固定角速度。
         * @param	constantMax 最大固定角速度。
         * @return 渐变速度。
         */
        static createByRandomTwoConstant(constantMin: Vector3, constantMax: Vector3): GradientVelocity;
        /**
         * 通过随机双渐变速度创建一个 <code>GradientVelocity</code> 实例。
         * @param	gradientXMin X轴最小渐变速度。
         * @param	gradientXMax X轴最大渐变速度。
         * @param	gradientYMin Y轴最小渐变速度。
         * @param	gradientYMax Y轴最大渐变速度。
         * @param	gradientZMin Z轴最小渐变速度。
         * @param	gradientZMax Z轴最大渐变速度。
         * @return  渐变速度。
         */
        static createByRandomTwoGradient(gradientXMin: GradientDataNumber, gradientXMax: GradientDataNumber, gradientYMin: GradientDataNumber, gradientYMax: GradientDataNumber, gradientZMin: GradientDataNumber, gradientZMax: GradientDataNumber): GradientVelocity;
        private _type;
        private _constant;
        private _gradientX;
        private _gradientY;
        private _gradientZ;
        private _constantMin;
        private _constantMax;
        private _gradientXMin;
        private _gradientXMax;
        private _gradientYMin;
        private _gradientYMax;
        private _gradientZMin;
        private _gradientZMax;
        /**
         *生命周期速度类型，0常量模式，1曲线模式，2随机双常量模式，3随机双曲线模式。
         */
        get type(): number;
        /**固定速度。*/
        get constant(): Vector3;
        /**
         * 渐变速度X。
         */
        get gradientX(): GradientDataNumber;
        /**
         * 渐变速度Y。
         */
        get gradientY(): GradientDataNumber;
        /**
         *渐变速度Z。
         */
        get gradientZ(): GradientDataNumber;
        /**最小固定速度。*/
        get constantMin(): Vector3;
        /**最大固定速度。*/
        get constantMax(): Vector3;
        /**
         * 渐变最小速度X。
         */
        get gradientXMin(): GradientDataNumber;
        /**
         * 渐变最大速度X。
         */
        get gradientXMax(): GradientDataNumber;
        /**
         * 渐变最小速度Y。
         */
        get gradientYMin(): GradientDataNumber;
        /**
         *渐变最大速度Y。
         */
        get gradientYMax(): GradientDataNumber;
        /**
         * 渐变最小速度Z。
         */
        get gradientZMin(): GradientDataNumber;
        /**
         * 渐变最大速度Z。
         */
        get gradientZMax(): GradientDataNumber;
        /**
         * 创建一个 <code>GradientVelocity,不允许new，请使用静态创建函数。</code> 实例。
         */
        constructor();
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>RotationOverLifetime</code> 类用于粒子的生命周期旋转。
     */
    class RotationOverLifetime implements IClone {
        private _angularVelocity;
        /**是否启用*/
        enable: boolean;
        /**
         *获取角速度。
         */
        get angularVelocity(): GradientAngularVelocity;
        /**
         * 创建一个 <code>RotationOverLifetime,不允许new，请使用静态创建函数。</code> 实例。
         */
        constructor(angularVelocity: GradientAngularVelocity);
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    enum ParticleSystemShapeType {
        /**盒体 */
        Box = 0,
        /**环形 */
        Circle = 1,
        /**锥体 */
        Cone = 2,
        /**半球体 */
        Hemisphere = 3,
        /**球体 */
        Sphere = 4
    }
    /**
     * <code>BaseShape</code> 类用于粒子形状。
     */
    class BaseShape implements IClone {
        /**是否启用。*/
        enable: boolean;
        /**随机方向。*/
        randomDirection: number;
        /**粒子类型 */
        shapeType: ParticleSystemShapeType;
        /**
         * 创建一个 <code>BaseShape</code> 实例。
         */
        constructor();
        /**
         * 用于生成粒子初始位置和方向。
         * @param	position 粒子位置。
         * @param	direction 粒子方向。
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>BoxShape</code> 类用于创建球形粒子形状。
     */
    class BoxShape extends BaseShape {
        /**发射器X轴长度。*/
        x: number;
        /**发射器Y轴长度。*/
        y: number;
        /**发射器Z轴长度。*/
        z: number;
        /**
         * 创建一个 <code>BoxShape</code> 实例。
         */
        constructor();
        /**
         *  用于生成粒子初始位置和方向。
         * @param	position 粒子位置。
         * @param	direction 粒子方向。
         * @override
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @param destObject
         * @override
         */
        cloneTo(destObject: any): void;
        /**
         * @override
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>CircleShape</code> 类用于创建环形粒子形状。
     */
    class CircleShape extends BaseShape {
        /**发射器半径。*/
        radius: number;
        /**环形弧度。*/
        arc: number;
        /**从边缘发射。*/
        emitFromEdge: boolean;
        /**
         * 创建一个 <code>CircleShape</code> 实例。
         */
        constructor();
        /**
         * 发射角度0-360
         */
        set arcDEG(deg: number);
        get arcDEG(): number;
        /**
         *  用于生成粒子初始位置和方向。
         * @param	position 粒子位置。
         * @param	direction 粒子方向。
         * @override
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @param destObject
         * @override
         */
        cloneTo(destObject: any): void;
        /**
         * @override
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>ConeShape</code> 类用于创建锥形粒子形状。
     */
    class ConeShape extends BaseShape {
        /**发射弧度。*/
        angle: number;
        /**发射器半径。*/
        radius: number;
        /**椎体长度。*/
        length: number;
        /**发射类型,0为Base,1为BaseShell,2为Volume,3为VolumeShell。*/
        emitType: number;
        /**
         * 创建一个 <code>ConeShape</code> 实例。
         */
        constructor();
        /**
         * 发射角度0-360
         */
        set angleDEG(deg: number);
        get angleDEG(): number;
        /**
         *  用于生成粒子初始位置和方向。
         * @param	position 粒子位置。
         * @param	direction 粒子方向。
         * @override
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @override
         */
        cloneTo(destObject: any): void;
        /**
         * @override
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>HemisphereShape</code> 类用于创建半球形粒子形状。
     */
    class HemisphereShape extends BaseShape {
        /**发射器半径。*/
        radius: number;
        /**从外壳发射。*/
        emitFromShell: boolean;
        /**
         * 创建一个 <code>HemisphereShape</code> 实例。
         */
        constructor();
        /**
         *  用于生成粒子初始位置和方向。
         * @param	position 粒子位置。
         * @param	direction 粒子方向。
         * @override
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @override
         */
        cloneTo(destObject: any): void;
        /**
         * @override
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>SphereShape</code> 类用于创建球形粒子形状。
     */
    class SphereShape extends BaseShape {
        /**发射器半径。*/
        radius: number;
        /**从外壳发射。*/
        emitFromShell: boolean;
        /**
         * 创建一个 <code>SphereShape</code> 实例。
         */
        constructor();
        /**
         *  用于生成粒子初始位置和方向。
         * @param	position 粒子位置。
         * @param	direction 粒子方向。
         * @override
         */
        generatePositionAndDirection(position: Vector3, direction: Vector3, rand?: Rand, randomSeeds?: Uint32Array): void;
        /**
         * @override
         */
        cloneTo(destObject: any): void;
        /**
         * @override
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>SizeOverLifetime</code> 类用于粒子的生命周期尺寸。
     */
    class SizeOverLifetime implements IClone {
        private _size;
        /**是否启用*/
        enable: boolean;
        /**
         *获取尺寸。
         */
        get size(): GradientSize;
        /**
         * 创建一个 <code>SizeOverLifetime</code> 实例。
         */
        constructor(size: GradientSize);
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>StartFrame</code> 类用于创建开始帧。
     */
    class StartFrame implements IClone {
        /**
         * 通过随机常量旋转创建一个 <code>StartFrame</code> 实例。
         * @param	constant  固定帧。
         * @return 开始帧。
         */
        static createByConstant(constant?: number): StartFrame;
        /**
         *  通过随机双常量旋转创建一个 <code>StartFrame</code> 实例。
         * @param	constantMin 最小固定帧。
         * @param	constantMax 最大固定帧。
         * @return 开始帧。
         */
        static createByRandomTwoConstant(constantMin?: number, constantMax?: number): StartFrame;
        private _type;
        private _constant;
        private _constantMin;
        private _constantMax;
        /**
         *开始帧类型,0常量模式，1随机双常量模式。
         */
        get type(): number;
        /**
         * 固定帧。
         */
        get constant(): number;
        /**
         * 最小固定帧。
         */
        get constantMin(): number;
        /**
         * 最大固定帧。
         */
        get constantMax(): number;
        /**
         * 创建一个 <code>StartFrame,不允许new，请使用静态创建函数。</code> 实例。
         */
        constructor();
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>TextureSheetAnimation</code> 类用于创建粒子帧动画。
     */
    class TextureSheetAnimation implements IClone {
        /**纹理平铺。*/
        tiles: Vector2;
        /**类型,0为whole sheet、1为singal row。*/
        type: number;
        /**是否随机行，type为1时有效。*/
        randomRow: boolean;
        /**行索引,type为1时有效。*/
        rowIndex: number;
        /**循环次数。*/
        cycles: number;
        /**UV通道类型,0为Noting,1为Everything,待补充,暂不支持。*/
        enableUVChannels: number;
        /**是否启用*/
        enable: boolean;
        /**获取时间帧率。*/
        get frame(): FrameOverTime;
        /**获取开始帧率。*/
        get startFrame(): StartFrame;
        /**
         * 创建一个 <code>TextureSheetAnimation</code> 实例。
         * @param frame 动画帧。
         * @param  startFrame 开始帧。
         */
        constructor(frame: FrameOverTime, startFrame: StartFrame);
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>VelocityOverLifetime</code> 类用于粒子的生命周期速度。
     */
    class VelocityOverLifetime implements IClone {
        /**是否启用*/
        enable: boolean;
        /**速度空间,0为local,1为world。*/
        space: number;
        /**
         *获取尺寸。
         */
        get velocity(): GradientVelocity;
        /**
         * 创建一个 <code>VelocityOverLifetime</code> 实例。
         */
        constructor(velocity: GradientVelocity);
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>ShuriKenParticle3D</code> 3D粒子。
     */
    class ShuriKenParticle3D extends RenderableSprite3D {
        /**
         * 粒子系统。
         */
        get particleSystem(): ShurikenParticleSystem;
        /**
         * 粒子渲染器。
         */
        get particleRenderer(): ShurikenParticleRenderer;
        /**
         * 创建一个 <code>Particle3D</code> 实例。
         */
        constructor();
        /**
         * <p>销毁此对象。</p>
         * @param	destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
         * @override
         */
        destroy(destroyChild?: boolean): void;
    }
    class ShurikenParticleInstanceSystem extends ShurikenParticleSystem {
        private _instanceParticleVertexBuffer;
        private _instanceVertex;
        private _meshIndexCount;
        private _meshFloatCountPreVertex;
        /**
         * 每个粒子数据 float 个数
         */
        private _floatCountPerParticleData;
        constructor(render: ShurikenParticleRenderer);
        /***
         * 重排 mesh vb
         */
        private _initMeshVertex;
        /**
         * 初始化 buffer
         * @returns
         */
        _initBufferDatas(): void;
        protected _retireActiveParticles(): void;
        protected _freeRetiredParticles(): void;
        addParticle(position: Vector3, direction: Vector3, time: number): boolean;
        addNewParticlesToVertexBuffer(): void;
        _updateRenderParams(stage: RenderContext3D): void;
        destroy(): void;
    }
    /**
     * <code>ShurikenParticleMaterial</code> 类用于实现粒子材质。
     */
    class ShurikenParticleMaterial extends Material {
        /**渲染状态_透明混合。*/
        static RENDERMODE_ALPHABLENDED: number;
        /**渲染状态_加色法混合。*/
        static RENDERMODE_ADDTIVE: number;
        /**@interanl */
        static SHADERDEFINE_ADDTIVEFOG: ShaderDefine;
        /** 默认材质，禁止修改*/
        static defaultMaterial: ShurikenParticleMaterial;
        /**
         * 颜色。
         */
        get color(): Color;
        set color(value: Color);
        /**
         * 纹理平铺和偏移。
         */
        get tilingOffset(): Vector4;
        set tilingOffset(value: Vector4);
        /**
         * 漫反射贴图。
         */
        get texture(): BaseTexture;
        set texture(value: BaseTexture);
        /**
         * 创建一个 <code>ShurikenParticleMaterial</code> 实例。
         */
        constructor();
        /**
        * 克隆。
        * @return	 克隆副本。
        * @override
        */
        clone(): any;
        /**
         * @deprecated
         * 渲染模式。
         */
        set renderMode(value: number);
        /**
         * @deprecated
         * 纹理平铺和偏移X分量。
         */
        get tilingOffsetX(): number;
        set tilingOffsetX(x: number);
        /**
         * @deprecated
         * 纹理平铺和偏移Y分量。
         */
        get tilingOffsetY(): number;
        set tilingOffsetY(y: number);
        /**
         * @deprecated
         * 纹理平铺和偏移Z分量。
         */
        get tilingOffsetZ(): number;
        set tilingOffsetZ(z: number);
        /**
         * @deprecated
         * 纹理平铺和偏移W分量。
         */
        get tilingOffsetW(): number;
        set tilingOffsetW(w: number);
        /**
         * @deprecated
         * 颜色R分量。
         */
        get colorR(): number;
        set colorR(value: number);
        /**
         * @deprecated
         * 颜色G分量。
         */
        get colorG(): number;
        set colorG(value: number);
        /**
         * @deprecated
         * 颜色B分量。
         */
        get colorB(): number;
        set colorB(value: number);
        /**
         * @deprecated
         * 颜色Z分量。
         */
        get colorA(): number;
        set colorA(value: number);
    }
    /**
     * <code>ShurikenParticleRender</code> 类用于创建3D粒子渲染器。
     */
    class ShurikenParticleRenderer extends BaseRender {
        /**重力值。*/
        static gravity: Vector3;
        private _dragConstant;
        /**@interanl */
        _particleSystem: ShurikenParticleSystem;
        /**拉伸广告牌模式摄像机速度缩放,暂不支持。*/
        stretchedBillboardCameraSpeedScale: number;
        /**拉伸广告牌模式速度缩放。*/
        stretchedBillboardSpeedScale: number;
        /**拉伸广告牌模式长度缩放。*/
        stretchedBillboardLengthScale: number;
        get particleSystem(): ShurikenParticleSystem;
        /**
         * 获取渲染模式,0为BILLBOARD、1为STRETCHEDBILLBOARD、2为HORIZONTALBILLBOARD、3为VERTICALBILLBOARD、4为MESH。
         */
        get renderMode(): number;
        set renderMode(value: number);
        /**
         * 获取网格渲染模式所使用的Mesh,rendderMode为4时生效。
         */
        get mesh(): Mesh;
        set mesh(value: Mesh);
        /**
         * 创建一个 <code>ShurikenParticleRender</code> 实例。
         */
        constructor();
        protected _getcommonUniformMap(): Array<string>;
        protected _onAdded(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        /**
         * @inheritDoc
         * @override
         */
        get bounds(): Bounds;
        protected _onDestroy(): void;
    }
    /**
     * <code>ShurikenParticleSystem</code> 类用于创建3D粒子数据模板。
     */
    class ShurikenParticleSystem extends GeometryElement implements IClone {
        protected _emissionLastPosition: Vector3;
        /**粒子运行的总时长，单位为秒。*/
        duration: number;
        /**是否循环。*/
        looping: boolean;
        /**是否预热。暂不支持*/
        prewarm: boolean;
        /**开始延迟类型，0为常量模式,1为随机随机双常量模式，不能和prewarm一起使用。*/
        startDelayType: number;
        /**开始播放延迟，不能和prewarm一起使用。*/
        startDelay: number;
        /**开始播放最小延迟，不能和prewarm一起使用。*/
        startDelayMin: number;
        /**开始播放最大延迟，不能和prewarm一起使用。*/
        startDelayMax: number;
        /**开始速度模式，0为恒定速度，2为两个恒定速度的随机插值。缺少1、3模式*/
        startSpeedType: number;
        /**开始速度,0模式。*/
        startSpeedConstant: number;
        /**最小开始速度,1模式。*/
        startSpeedConstantMin: number;
        /**最大开始速度,1模式。*/
        startSpeedConstantMax: number;
        /**阻力模式，0为恒定速度，2为两个恒定速度的随机插值*/
        dragType: number;
        /**开始速度,0模式。*/
        dragConstant: number;
        /**最小开始速度,1模式。*/
        dragSpeedConstantMin: number;
        /**最大开始速度,1模式。*/
        dragSpeedConstantMax: number;
        /**开始尺寸是否为3D模式。*/
        threeDStartSize: boolean;
        /**开始尺寸模式,0为恒定尺寸，2为两个恒定尺寸的随机插值。缺少1、3模式和对应的二种3D模式*/
        startSizeType: number;
        /**开始尺寸，0模式。*/
        startSizeConstant: number;
        /**开始三维尺寸，0模式。*/
        startSizeConstantSeparate: Vector3;
        /**最小开始尺寸，2模式。*/
        startSizeConstantMin: number;
        /**最大开始尺寸，2模式。*/
        startSizeConstantMax: number;
        /**最小三维开始尺寸，2模式。*/
        startSizeConstantMinSeparate: Vector3;
        /**最大三维开始尺寸，2模式。*/
        startSizeConstantMaxSeparate: Vector3;
        /**3D开始旋转。*/
        threeDStartRotation: boolean;
        /**开始旋转模式,0为恒定尺寸，2为两个恒定旋转的随机插值,缺少2种模式,和对应的四种3D模式。*/
        startRotationType: number;
        /**开始旋转，0模式。*/
        startRotationConstant: number;
        /**开始三维旋转，0模式。*/
        startRotationConstantSeparate: Vector3;
        /**最小开始旋转，1模式。*/
        startRotationConstantMin: number;
        /**最大开始旋转，1模式。*/
        startRotationConstantMax: number;
        /**最小开始三维旋转，1模式。*/
        startRotationConstantMinSeparate: Vector3;
        /**最大开始三维旋转，1模式。*/
        startRotationConstantMaxSeparate: Vector3;
        /**随机旋转方向，范围为0.0到1.0*/
        randomizeRotationDirection: number;
        /**开始颜色模式，0为恒定颜色，2为两个恒定颜色的随机插值,缺少2种模式。*/
        startColorType: number;
        /**开始颜色，0模式。*/
        startColorConstant: Vector4;
        /**最小开始颜色，1模式。*/
        startColorConstantMin: Vector4;
        /**最大开始颜色，1模式。*/
        startColorConstantMax: Vector4;
        /**重力敏感度。*/
        gravityModifier: number;
        /**模拟器空间,0为World,1为Local。暂不支持Custom。*/
        simulationSpace: number;
        /**粒子的播放速度。 */
        simulationSpeed: number;
        /**缩放模式，0为Hiercachy,1为Local,2为World。*/
        scaleMode: number;
        /**激活时是否自动播放。*/
        playOnAwake: boolean;
        /**随机种子,注:play()前设置有效。*/
        randomSeed: Uint32Array;
        /**是否使用随机种子。 */
        autoRandomSeed: boolean;
        /**是否为性能模式,性能模式下会延迟粒子释放。*/
        isPerformanceMode: boolean;
        /**最大粒子数。*/
        get maxParticles(): number;
        set maxParticles(value: number);
        /**
         * 获取发射器。
         */
        get emission(): Emission;
        /**
         * 粒子存活个数。
         */
        get aliveParticleCount(): number;
        /**
         * 一次循环内的累计时间。
         */
        get emissionTime(): number;
        /**
         * 形状。
         */
        get shape(): BaseShape;
        set shape(value: BaseShape);
        /**
         * 是否存活。
         */
        get isAlive(): boolean;
        /**
         * 是否正在发射。
         */
        get isEmitting(): boolean;
        /**
         * 是否正在播放。
         */
        get isPlaying(): boolean;
        /**
         * 是否已暂停。
         */
        get isPaused(): boolean;
        /**
         * 开始生命周期模式,0为固定时间，1为渐变时间，2为两个固定之间的随机插值,3为两个渐变时间的随机插值。
         */
        get startLifetimeType(): number;
        set startLifetimeType(value: number);
        /**
         * 开始生命周期，0模式,单位为秒。
         */
        get startLifetimeConstant(): number;
        set startLifetimeConstant(value: number);
        /**
         * 开始渐变生命周期，1模式,单位为秒。
         */
        get startLifeTimeGradient(): GradientDataNumber;
        set startLifeTimeGradient(value: GradientDataNumber);
        /**
         * 最小开始生命周期，2模式,单位为秒。
         */
        get startLifetimeConstantMin(): number;
        set startLifetimeConstantMin(value: number);
        /**
         * 最大开始生命周期，2模式,单位为秒。
         */
        get startLifetimeConstantMax(): number;
        set startLifetimeConstantMax(value: number);
        /**
         * 开始渐变最小生命周期，3模式,单位为秒。
         */
        get startLifeTimeGradientMin(): GradientDataNumber;
        set startLifeTimeGradientMin(value: GradientDataNumber);
        /**
         * 开始渐变最大生命周期，3模式,单位为秒。
         */
        get startLifeTimeGradientMax(): GradientDataNumber;
        set startLifeTimeGradientMax(value: GradientDataNumber);
        /**
         * 生命周期速度,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
         */
        get velocityOverLifetime(): VelocityOverLifetime;
        set velocityOverLifetime(value: VelocityOverLifetime);
        /**
         * 生命周期颜色,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
         */
        get colorOverLifetime(): ColorOverLifetime;
        set colorOverLifetime(value: ColorOverLifetime);
        /**
         * 生命周期尺寸,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
         */
        get sizeOverLifetime(): SizeOverLifetime;
        set sizeOverLifetime(value: SizeOverLifetime);
        /**
         * 生命周期旋转,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
         */
        get rotationOverLifetime(): RotationOverLifetime;
        set rotationOverLifetime(value: RotationOverLifetime);
        /**
         * 生命周期纹理动画,注意:如修改该值的某些属性,需重新赋值此属性才可生效。
         */
        get textureSheetAnimation(): TextureSheetAnimation;
        set textureSheetAnimation(value: TextureSheetAnimation);
        constructor(render: ShurikenParticleRenderer, meshTopology?: MeshTopology, drawType?: DrawType);
        /**
         * 设置 自定义 包围盒
         */
        get customBounds(): Bounds;
        set customBounds(value: Bounds);
        /**
         * 发射一个粒子。
         */
        emit(time: number): boolean;
        addParticle(position: Vector3, direction: Vector3, time: number): boolean;
        addNewParticlesToVertexBuffer(): void;
        /**
         * @inheritDoc
         * @override
         */
        _getType(): number;
        /**
         * 开始发射粒子。
         */
        play(): void;
        /**
         * 暂停发射粒子。
         */
        pause(): void;
        /**
         * 通过指定时间增加粒子播放进度，并暂停播放。
         * @param time 进度时间.如果restart为true,粒子播放时间会归零后再更新进度。
         * @param restart 是否重置播放状态。
         */
        simulate(time: number, restart?: boolean): void;
        /**
         * 停止发射粒子。
         */
        stop(): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>PixelLineData</code> 类用于表示线数据。
     */
    class PixelLineData {
        /**线开始位置 */
        startPosition: Vector3;
        /**线结束位置 */
        endPosition: Vector3;
        /**线开始颜色 */
        startColor: Color;
        /**线结束颜色 */
        endColor: Color;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: PixelLineData): void;
    }
    /**
     * <code>PixelLineFilter</code> 类用于线过滤器。
     */
    class PixelLineFilter extends GeometryElement {
        /** @private */
        private static _tempVector0;
        /** @private */
        private static _tempVector1;
        /**
         * 创建一个PixelLineFilter实例
         * @param owner 渲染精灵节点
         * @param maxLineCount 最大线长
         */
        constructor(owner: PixelLineRenderer, maxLineCount: number);
        /**
         * 获取线段数据
         * @return 线段数据。
         */
        _getLineData(index: number, out: PixelLineData): void;
        /**
         * @inheritDoc
         * @override
         * 删除
         */
        destroy(): void;
    }
    /**
     * <code>PixelLineMaterial</code> 类用于实现像素线材质。
     */
    class PixelLineMaterial extends Material {
        /** 默认材质，禁止修改*/
        static defaultMaterial: PixelLineMaterial;
        /**
         * 获取颜色。
         * @return 颜色。
         */
        get color(): Vector4;
        /**
         * 设置颜色。
         * @param value 颜色。
         */
        set color(value: Vector4);
        /**
         *  创建一个 <code>PixelLineMaterial</code> 实例。
         */
        constructor();
    }
    /**
     * <code>PixelLineRenderer</code> 类用于线渲染器。
     */
    class PixelLineRenderer extends BaseRender {
        /** @private 是否调用active */
        private _isRenderActive;
        /** @private 是否加入渲染队列*/
        private _isInRenders;
        private _needUpdatelines;
        /**
         * 创建一个PixelLineRenderer实例
         * @param owner 线渲染精灵
         */
        constructor();
        private _lines;
        get pixelLinesDatas(): PixelLineData[];
        set pixelLinesDatas(value: PixelLineData[]);
        /**
         * 最大线数量
         */
        get maxLineCount(): number;
        set maxLineCount(value: number);
        /**
         * 获取线数量。
         */
        get lineCount(): number;
        protected _onAdded(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        /**
         * @inheritDoc
         */
        _changeRenderObjects(index: number, material: Material): void;
        /**
         * 增加一条线。
         * @param	startPosition  初始点位置
         * @param	endPosition	   结束点位置
         * @param	startColor	   初始点颜色
         * @param	endColor	   结束点颜色
         */
        addLine(startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color): void;
        /**
         * 添加多条线段。
         * @param	lines  线段数据
         */
        addLines(lines: PixelLineData[]): void;
        /**
         * 移除一条线段。
         * @param index 索引。
         */
        removeLine(index: number): void;
        /**
         * 更新线
         * @param	index  		   索引
         * @param	startPosition  初始点位置
         * @param	endPosition	   结束点位置
         * @param	startColor	   初始点颜色
         * @param	endColor	   结束点颜色
         */
        setLine(index: number, startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color): void;
        /**
         * 获取线段数据
         * @param out 线段数据。
         */
        getLine(index: number, out: PixelLineData): void;
        /**
         * 清除所有线段。
         */
        clear(): void;
        protected _onDestroy(): void;
        /**
         * @override
         * @param dest
         */
        _cloneTo(dest: Component): void;
    }
    /**
     * <code>PixelLineSprite3D</code> 类用于像素线渲染精灵。
     */
    class PixelLineSprite3D extends RenderableSprite3D {
        /** @private 是否调用active */
        private _isRenderActive;
        /** @private 是否加入渲染队列*/
        private _isInRenders;
        /**
         * 最大线数量
         */
        get maxLineCount(): number;
        set maxLineCount(value: number);
        /**
         * 获取线数量。
         */
        get lineCount(): number;
        /**
         * line渲染器。
         */
        get pixelLineRenderer(): PixelLineRenderer;
        /**
         * 创建一个 <code>PixelLineSprite3D</code> 实例。
         * @param maxCount 最大线段数量。
         * @param name 名字。
         */
        constructor(maxCount?: number, name?: string);
        /**
         * 增加一条线。
         * @param	startPosition  初始点位置
         * @param	endPosition	   结束点位置
         * @param	startColor	   初始点颜色
         * @param	endColor	   结束点颜色
         */
        addLine(startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color): void;
        /**
         * 添加多条线段。
         * @param	lines  线段数据
         */
        addLines(lines: PixelLineData[]): void;
        /**
         * 移除一条线段。
         * @param index 索引。
         */
        removeLine(index: number): void;
        /**
         * 更新线
         * @param	index  		   索引
         * @param	startPosition  初始点位置
         * @param	endPosition	   结束点位置
         * @param	startColor	   初始点颜色
         * @param	endColor	   结束点颜色
         */
        setLine(index: number, startPosition: Vector3, endPosition: Vector3, startColor: Color, endColor: Color): void;
        /**
         * 获取线段数据
         * @param out 线段数据。
         */
        getLine(index: number, out: PixelLineData): void;
        /**
         * 清除所有线段。
         */
        clear(): void;
    }
    /**
     * <code>QuaternionKeyframe</code> 类用于创建四元数关键帧实例。
     */
    class QuaternionKeyframe extends Keyframe {
        /**内切线 */
        inTangent: Vector4;
        /**外切线 */
        outTangent: Vector4;
        /**帧数据 */
        value: Quaternion;
        /**内权重 */
        inWeight: Vector4;
        /**外权重 */
        outWeight: Vector4;
        /**权重模式*/
        weightedMode: Vector4;
        /**
         * 创建一个 <code>QuaternionKeyframe</code> 实例。
         */
        constructor(weightMode?: boolean);
        /**
         * 克隆。
         * @param	destObject 克隆源。
         * @override
         */
        cloneTo(dest: any): void;
    }
    enum RenderBitFlag {
        RenderBitFlag_CullFlag = 0,
        RenderBitFlag_Batch = 1,
        RenderBitFlag_Editor = 2,
        RenderBitFlag_InstanceBatch = 3,
        RenderBitFlag_VertexMergeBatch = 4
    }
    enum IrradianceMode {
        LightMap = 0,
        VolumetricGI = 1,
        Common = 2
    }
    /**
     * <code>Render</code> 类用于渲染器的父类，抽象类不允许实例。
     */
    class BaseRender extends Component implements IBoundsCell {
        /**
         * BaseRender Init
         */
        static __init__(): void;
        static changeVertexDefine(oldMesh: Mesh, mesh: Mesh, defineDatas: ShaderData): void;
        static shaderValueInit(): void;
        /**排序矫正值。*/
        sortingFudge: number;
        /**
         * DistanceVolumCull
         * 根据距离和包围盒进行裁剪，越大越容易被裁
         */
        set ratioIgnor(value: number);
        get ratioIgnor(): number;
        get renderbitFlag(): number;
        set boundsChange(value: boolean);
        get boundsChange(): boolean;
        shadowCullPass(): boolean;
        /**@interface */
        _receiveShadow: boolean;
        get renderNode(): IBaseRenderNode;
        set distanceForSort(value: number);
        get distanceForSort(): number;
        get geometryBounds(): Bounds;
        /**
         * 获取唯一标识ID,通常用于识别。
         */
        get id(): number;
        /**
         * 光照贴图的索引。
         */
        get lightmapIndex(): number;
        set lightmapIndex(value: number);
        /**
         * 光照功能查询
         */
        get irradientMode(): IrradianceMode;
        /**
         * 光照贴图的缩放和偏移。
         */
        get lightmapScaleOffset(): Vector4;
        set lightmapScaleOffset(value: Vector4);
        /**
         * 返回第一个实例材质,第一次使用会拷贝实例对象。
         */
        get material(): Material;
        set material(value: Material);
        /**
         * 潜拷贝实例材质列表,第一次使用会拷贝实例对象。
         */
        get materials(): Material[];
        set materials(value: Material[]);
        /**
         * 返回第一个材质。
         */
        get sharedMaterial(): Material;
        set sharedMaterial(value: Material);
        /**
         * 浅拷贝材质列表。
         */
        get sharedMaterials(): Material[];
        set sharedMaterials(value: Material[]);
        /**
         * 包围盒,只读,不允许修改其值。
         */
        get bounds(): Bounds;
        set receiveShadow(value: boolean);
        /**
         * 是否接收阴影属性
         */
        get receiveShadow(): boolean;
        /**
         * 是否产生阴影。
         */
        get castShadow(): boolean;
        set castShadow(value: boolean);
        /**
         * 反射模式
         */
        set reflectionMode(value: ReflectionProbeMode);
        get reflectionMode(): ReflectionProbeMode;
        set volume(value: Volume);
        get volume(): Volume;
        set lightProb(volumetricGI: VolumetricGI);
        /**
         * 创建一个新的 <code>BaseRender</code> 实例。
         */
        constructor();
        private _getIrradientMode;
        protected _getcommonUniformMap(): Array<string>;
        protected _createBaseRenderNode(): IBaseRenderNode;
        private _changeLayer;
        private _changeStaticMask;
        protected _onAdded(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        /**
         * 设置渲染flag,每一位都代表不同的淘汰原因，1表示lod淘汰
         */
        setRenderbitFlag(flag: number, pass: boolean): void;
        /**
         * apply lightProb
         * @returns
         */
        _applyLightProb(): void;
        /**
         * apply reflection
         * @returns
         */
        _applyReflection(): void;
        protected _onDestroy(): void;
        /**
         * @override
         * @param dest
         */
        _cloneTo(dest: Component): void;
    }
    /**
     * 类用于创建从渲染源输出到渲染目标的指令
     */
    class BlitFrameBufferCMD {
        /**
       * 渲染命令集
       * @param source
       * @param dest
       * @param viewport
       * @param offsetScale
       * @param shader
       * @param shaderData
       * @param subShader
       */
        static create(source: BaseTexture, dest: RenderTexture, viewport: Viewport, offsetScale?: Vector4, shader?: Shader3D, shaderData?: ShaderData, subShader?: number): BlitFrameBufferCMD;
        constructor();
        set shaderData(value: ShaderData);
        setshader(shader: Shader3D, subShader: number, shaderData: ShaderData): void;
        /**
         * @inheritDoc
         * @override
         */
        run(): void;
        /**
         * @inheritDoc
         * @override
         */
        recover(): void;
    }
    class BlitScreenQuadCMD extends Command {
        /**
        * 创建命令流
        * @param source 原始贴图 如果设置为null  将会使用默认的Camera流程中的原RenderTexture
        * @param dest 目标贴图 如果设置为null，将会使用默认的camera渲染目标
        * @param offsetScale 偏移缩放
        * @param shader 渲染shader
        * @param shaderData 渲染数据
        * @param subShader subshader的节点
        * @param screenType
        */
        static create(source: BaseTexture, dest: RenderTexture, offsetScale?: Vector4, shader?: Shader3D, shaderData?: ShaderData, subShader?: number, screenType?: number, commandbuffer?: CommandBuffer): BlitScreenQuadCMD;
        constructor();
        set shaderData(value: ShaderData);
        setshader(shader: Shader3D, subShader: number, shaderData: ShaderData): void;
        /**
         * @inheritDoc
         * @override
         */
        run(): void;
        /**
         * @inheritDoc
         * @override
         */
        recover(): void;
        destroy(): void;
    }
    /**
     * <code>Command</code> 类用于创建指令。
     */
    class Command {
        /**
         * 创建一个 <code>Command</code> 实例。
         */
        constructor();
        /**
         * 运行渲染指令
         */
        run(): void;
        /**
         * 回收渲染指令
         */
        recover(): void;
        /**
         * 设置渲染上下文
         * @param context 渲染上下文
         */
        setContext(context: RenderContext3D): void;
    }
    /**
     * <code>CommandBuffer</code> 类用于创建命令流。
     */
    class CommandBuffer {
        /**
         * 创建一个 <code>CommandBuffer</code> 实例。
         */
        constructor(name?: string, shadowCaster?: boolean);
        get name(): string;
        get casterShadow(): boolean;
        set context(value: RenderContext3D);
        get context(): RenderContext3D;
        /**
         * 调用所有渲染指令
         */
        _apply(): void;
        _applyOne(): boolean;
        getCommandsSize(): number;
        /**
         * 设置shader图片数据
         * @param shaderData shader数据集合
         * @param nameID 图片UniformID
         * @param source 图片源
         */
        setShaderDataTexture(shaderData: ShaderData, nameID: number, source: BaseTexture): void;
        /**
         * 设置全局纹理数据
         * @param nameID 图片uniformID
         * @param source 图片源
         */
        setGlobalTexture(nameID: number, source: BaseTexture): void;
        /**
         * 设置shader Vector4数据
         * @param shaderData shader数据集合
         * @param nameID 数据ID
         * @param value 数据
         */
        setShaderDataColor(shaderData: ShaderData, nameID: number, value: Color): void;
        /**
         * 设置全局Vector4数据
         * @param nameID Vector4数据ID
         * @param source 数据
         */
        setGlobalColor(nameID: number, source: Color): void;
        /**
         * 设置shader Vector4数据
         * @param shaderData shader数据集合
         * @param nameID 数据ID
         * @param value 数据
         */
        setShaderDataVector(shaderData: ShaderData, nameID: number, value: Vector4): void;
        /**
         * 设置全局Vector4数据
         * @param nameID Vector4数据ID
         * @param source 数据
         */
        setGlobalVector(nameID: number, source: Vector4): void;
        /**
         * 设置shader Vector3数据
         * @param shaderData shader数据集合
         * @param nameID 数据ID
         * @param value 数据
         */
        setShaderDataVector3(shaderData: ShaderData, nameID: number, value: Vector3): void;
        /**
         * 设置全局Vector3数据
         * @param nameID 数据ID
         * @param source 数据
         */
        setGlobalVector3(nameID: number, source: Vector3): void;
        /**
         * 设置shader Vector2数据
         * @param shaderData shader数据集合
         * @param nameID 数据ID
         * @param value 数据
         */
        setShaderDataVector2(shaderData: ShaderData, nameID: number, value: Vector2): void;
        /**
         * 设置全局Vector2数据
         * @param nameID 数据ID
         * @param source 数据
         */
        setGlobalVector2(nameID: number, source: Vector2): void;
        /**
         * 设置shader Number属性
         * @param shaderData shader数据集合
         * @param nameID 数据ID
         * @param value 数据
         */
        setShaderDataNumber(shaderData: ShaderData, nameID: number, value: number): void;
        /**
         * 设置全局number属性
         * @param nameID 数据ID
         * @param source 数据
         */
        setGlobalNumber(nameID: number, source: number): void;
        /**
         * 设置shader Int属性
         * @param shaderData shader数据集合
         * @param nameID 数据ID
         * @param value 数据
         */
        setShaderDataInt(shaderData: ShaderData, nameID: number, value: number): void;
        /**
         * 设置全局int属性
         * @param nameID 数据ID
         * @param source 数据
         */
        setGlobalInt(nameID: number, source: number): void;
        /**
         * 设置shader Matrix属性
         * @param shaderData shader数据集合
         * @param nameID 数据ID
         * @param value 数据
         */
        setShaderDataMatrix(shaderData: ShaderData, nameID: number, value: Matrix4x4): void;
        setShaderDefine(shaderData: ShaderData, define: string, value: boolean): void;
        /**
         * 设置全局Matrix属性
         * @param nameID 数据ID
         * @param source 数据
         */
        setGlobalMatrix(nameID: number, source: number): void;
        /**
         * 添加一条通过全屏四边形将源纹理渲染到目标渲染纹理指令。
         * @param	source 源纹理. 如果为null,前渲染结果为原纹理
         * @param	dest  目标纹理. 如果为null，直接渲染到最终画布
         * @param	offsetScale 偏移缩放。
         * @param	shader 着色器,如果为null使用内部拷贝着色器,不做任何处理。
         * @param	shaderData 着色器数据,如果为null只接收sourceTexture。
         * @param	subShader subShader索引,默认值为0。
         */
        blitScreenQuad(source: BaseTexture, dest: RenderTexture, offsetScale?: Vector4, shader?: Shader3D, shaderData?: ShaderData, subShader?: number): void;
        /**
         * 添加一条通过全屏四边形将源纹理渲染到目标渲染纹理指令。
         * @param source 源纹理 如果为null,前渲染结果为原纹理
         * @param dest 目标纹理 如果为null，直接渲染到最终画布
         * @param offsetScale 偏移缩放
         * @param material 材质
         * @param subShader shader索引
         */
        blitScreenQuadByMaterial(source: BaseTexture, dest: RenderTexture, offsetScale?: Vector4, material?: Material, subShader?: number): void;
        /**
         * 添加一条通过全屏三角形将源纹理渲染到目标渲染纹理指令。
         * @param	source 源纹理。
         * @param	dest  目标纹理。
         * @param	offsetScale 偏移缩放。
         * @param	shader 着色器,如果为null使用内部拷贝着色器,不做任何处理。
         * @param	shaderData 着色器数据,如果为null只接收sourceTexture。
         * @param	subShader subShader索引,默认值为0。
         */
        blitScreenTriangle(source: BaseTexture, dest: RenderTexture, offsetScale?: Vector4, shader?: Shader3D, shaderData?: ShaderData, subShader?: number): void;
        /**
         * 设置指令渲染目标
         * @param renderTexture RT渲染目标
         */
        setRenderTarget(renderTexture: RenderTexture): void;
        /**
         * clear渲染纹理
         * @param clearColor
         * @param clearDepth
         * @param backgroundColor
         * @param depth
         */
        clearRenderTarget(clearColor: boolean, clearDepth: boolean, backgroundColor: Color, depth?: number): void;
        /**
         * 渲染一个Mesh
         * @param mesh 原始网格信息
         * @param matrix 网格世界矩阵
         * @param material 材质
         * @param submeshIndex 子网格索引 如果索引为
         * @param subShaderIndex 子shader索引 一般为0
         */
        drawMesh(mesh: Mesh, matrix: Matrix4x4, material: Material, submeshIndex: number, subShaderIndex: number): void;
        /**
         * 渲染一个Render
         * @param render 渲染器
         * @param material 材质
         * @param subShaderIndex 子shader索引 一般为0
         */
        drawRender(render: BaseRender, material: Material, subShaderIndex: number): void;
        /**
         * 使用instance动态合批的方式渲染一个Mesh
         * @param mesh 原始网格信息
         * @param subMeshIndex mesh索引
         * @param matrixs 渲染的世界矩阵数组，用来描述每个Mesh需要渲染的位置,如果为null，将不创建更新世界矩阵Buffer
         * @param material 渲染材质
         * @param subShaderIndex 渲染材质shader索引
         * @param instanceProperty Instance自定义属性
         * @param drawnums 渲染个数
         */
        drawMeshInstance(mesh: Mesh, subMeshIndex: number, matrixs: Matrix4x4[], material: Material, subShaderIndex: number, instanceProperty: MaterialInstancePropertyBlock, drawnums: number): any;
        /**
         * add 自定义的渲染命令
         * @param command
         */
        addCustomCMD(command: Command): void;
    }
    class DrawMeshInstancedCMD extends Command {
        /**设置最大DrawInstance数 */
        static maxInstanceCount: number;
        constructor();
        set material(value: Material);
        get bufferState(): VertexBuffer3D;
        set mesh(value: Mesh);
        get mesh(): Mesh;
        /**
         * 重置DrawInstance的世界矩阵数组
         * @param worldMatrixArray
         */
        setWorldMatrix(worldMatrixArray: Matrix4x4[]): void;
        /**
         * 重置渲染个数
         * @param drawNums
         */
        setDrawNums(drawNums: number): void;
        run(): void;
        /**
         * @inheritDoc
         * @override
         */
        recover(): void;
        destroy(): void;
    }
    class DrawRenderCMD extends Command {
        constructor();
        set material(value: Material);
        /**
         * @inheritDoc
         * @override
         */
        run(): void;
        /**
         * @inheritDoc
         * @override
         */
        recover(): void;
        destroy(): void;
    }
    enum InstanceLocation {
        CUSTOME0 = 12,
        CUSTOME1 = 13,
        CUSTOME2 = 14,
        CUSTOME3 = 15
    }
    /**
     * <code>Mesh</code> 类用于创建CustomInstance属性块。
     */
    class MaterialInstancePropertyBlock {
        /**Instance合并方案 */
        /**attribute instance渲染方案 优点：合并数量多,合并效率高，渲染性能优 缺点：instance变量元素少*/
        static INSTANCETYPE_ATTRIBUTE: number;
        /**uniform instance渲染方案 优点：instance变量多，灵活  缺点：合并数量受WebGLContext._maxUniformFragmentVectors的影响，合并效率低 */
        static INSTANCETYPE_UNIFORMBUFFER: number;
        constructor();
        /**
         * 创建instance属性
         * @param attributeName name
         * @param arrays data
         * @param vertexStride vertex size
         * @param vertexformat vertexFormat
         * @param attributeLocation  attribute location
         */
        private _creatProperty;
        /**
         * 设置Vector4材质数组属性
         * @param attributeName 属性名称（要对应到Shader中）
         * @param arrays 数据
         * @param attributeLocation  属性Shader位置（需要与shader中的声明Attribute一一对应）
         */
        setVectorArray(attributeName: string, arrays: Vector4[] | Float32Array, attributeLocation: InstanceLocation): void;
        /**
         * 设置Vector3材质数组属性
         * @param attributeName 属性名称（要对应到Shader中）
         * @param arrays 数据
         * @param attributeLocation 属性shader位置（需要与shader中的声明Attribute一一对应）
         */
        setVector3Array(attributeName: string, arrays: Vector3[] | Float32Array, attributeLocation: InstanceLocation): void;
        /**
         * 设置Vector2材质数组属性
         * @param attributeName 属性名称（要对应到Shader中）
         * @param arrays 数据
         * @param attributeLocation 属性shader位置（需要与shader中的声明Attribute一一对应）
         */
        setVector2Array(attributeName: string, arrays: Vector2[] | Float32Array, attributeLocation: InstanceLocation): void;
        /**
         * 设置Number材质数组属性
         * @param attributeName 属性名称（要对应到Shader中）
         * @param arrays 数据
         * @param attributeLocation 属性shader位置（需要与shader中的声明Attribute一一对应）
         */
        setNumberArray(attributeName: string, arrays: Float32Array, attributeLocation: InstanceLocation): void;
        /**
         * 获得属性数据
         * @param attributeLocation  属性shader位置
         */
        getPropertyArray(attributeLocation: InstanceLocation): Vector4[] | Vector3[] | Vector2[] | Float32Array;
        clear(): void;
    }
    class InstanceRenderElement extends RenderElement {
        static create(): InstanceRenderElement;
        constructor();
        set InvertFront(value: boolean);
        protected _createRenderElementOBJ(): void;
        compileShader(context: IRenderContext3D): void;
        _renderUpdatePre(context: RenderContext3D): void;
        updateInstanceData(mesh: Mesh): void;
        clear(): void;
        recover(): void;
    }
    /**
     * <code>BloomEffect</code> 类用于创建泛光效果。
     */
    class BloomEffect extends PostProcessEffect {
        /**
         * bloom resource init
         */
        static init(): void;
        static CompositeInit(): void;
        static __initDefine__(): void;
        /**泛光颜色。*/
        private _color;
        /**是否开启快速模式。该模式通过降低质量来提升性能。*/
        private _fastMode;
        /**镜头污渍纹路,用于为泛光特效增加污渍灰尘效果*/
        private _dirtTexture;
        /**
         * 泛光像素的数量,该值在伽马空间
         */
        get clamp(): number;
        set clamp(value: number);
        /**
         * 泛光颜色。
         */
        get color(): Color;
        set color(value: Color);
        /**
         * 快速模式
         */
        get fastMode(): boolean;
        set fastMode(value: boolean);
        /**
         * 脏迹贴图
         */
        get dirtTexture(): BaseTexture;
        set dirtTexture(value: BaseTexture);
        /**
         * 获取泛光过滤器强度,最小值为0。
         * @return 强度。
         */
        get intensity(): number;
        /**
         * 设置泛光过滤器强度,最小值为0。
         * @param value 强度。
         */
        set intensity(value: number);
        /**
         * 设置泛光阈值,在该阈值亮度以下的像素会被过滤掉,该值在伽马空间。
         * @return 阈值。
         */
        get threshold(): number;
        /**
         * 获取泛光阈值,在该阈值亮度以下的像素会被过滤掉,该值在伽马空间。
         * @param value 阈值。
         */
        set threshold(value: number);
        /**
         * 获取软膝盖过渡强度,在阈值以下进行渐变过渡(0为完全硬过度,1为完全软过度)。
         * @return 软膝盖值。
         */
        get softKnee(): number;
        /**
         * 设置软膝盖过渡强度,在阈值以下进行渐变过渡(0为完全硬过度,1为完全软过度)。
         * @param value 软膝盖值。
         */
        set softKnee(value: number);
        /**
         * 获取扩散值,改变泛光的扩散范围,最好使用整数值保证效果,该值会改变内部的迭代次数,范围是1到10。
         * @return 光晕的扩散范围。
         */
        get diffusion(): number;
        /**
         * 设置扩散值,改变泛光的扩散范围,最好使用整数值保证效果,该值会改变内部的迭代次数,范围是1到10。
         * @param value 光晕的扩散范围。
         */
        set diffusion(value: number);
        /**
         * 获取形变比,通过扭曲泛光产生视觉上形变,负值为垂直扭曲,正值为水平扭曲。-1 - 1
         * @return 形变比。
         */
        get anamorphicRatio(): number;
        /**
         * 设置形变比,通过扭曲泛光产生视觉上形变,负值为垂直扭曲,正值为水平扭曲。-1 - 1
         * @param value 形变比。
         */
        set anamorphicRatio(value: number);
        /**
         * 获取污渍强度。
         * @return 污渍强度。
         */
        get dirtIntensity(): number;
        /**
         * 设置污渍强度。0-1
         * @param value 污渍强度。
         */
        set dirtIntensity(value: number);
        /**
         * 创建一个 <code>BloomEffect</code> 实例。
         */
        constructor();
        /**
         * 添加到后期处理栈时,会调用
         */
        effectInit(postprocess: PostProcess): void;
        /**
         * 根据后期处理设置cameraDepthTextureMode
         * @inheritDoc
         * @override
         * @returns
         */
        getCameraDepthTextureModeFlag(): number;
        /**
         * 释放Effect
         */
        release(postprocess: PostProcess): void;
    }
    enum ToneMappingType {
        None = 0,
        ACES = 1
    }
    /**
     * <code>ColorGradEffect</code> 类用于创建调色Effect
     */
    class ColorGradEffect extends PostProcessEffect {
        static SHADERDEFINE_ACES: ShaderDefine;
        static SHADERDEFINE_CUSTOMLUT: ShaderDefine;
        static SHADERVALUE_LUT: number;
        static SHADERVALUE_LUTPARAMS: number;
        static SHADERVALUE_CUSTOMLUT: number;
        static SHADERVALUE_CUSTOMLUTPARAMS: number;
        /**
         * bloom resource init
         */
        static init(): void;
        static __initDefine__(): void;
        private _needBuildLUT;
        private _lutCommond;
        _lutTex: RenderTexture;
        private _lutBuilderMat;
        private _LUTShader;
        private _lutShaderData;
        private _blitlutParams;
        private _splitShadow;
        private _splitBalance;
        private _splithighlights;
        private _u_SplitShadow;
        private _enableSMH;
        private _enableLiftGammaGain;
        private _enableBalance;
        private _tint;
        private _temperature;
        /**
         * Tone Map色彩空间
         */
        get toneMapping(): ToneMappingType;
        set toneMapping(value: ToneMappingType);
        /**
         * 是否开启Split Tone
         */
        get enableSplitTone(): boolean;
        set enableSplitTone(value: boolean);
        /**
         * split shadow
         */
        get splitShadow(): Vector3;
        set splitShadow(value: Vector3);
        /**
         * split hightLight
         */
        get splithighlights(): Vector3;
        set splithighlights(value: Vector3);
        /**
         * split balance
         */
        get splitBalance(): number;
        set splitBalance(value: number);
        get enableSMH(): boolean;
        set enableSMH(value: boolean);
        /**
         * shadows 0-5
         */
        get shadows(): Vector3;
        set shadows(value: Vector3);
        /**
         * midtones 0-5
         */
        get midtones(): Vector3;
        set midtones(value: Vector3);
        /**
         * highlights 0-5
         */
        get highlights(): Vector3;
        set highlights(value: Vector3);
        /**
         * shadow limit start 0-1
         */
        get shadowLimitStart(): number;
        set shadowLimitStart(value: number);
        /**
         * shadow limit end 0-1
         */
        get shadowLimitEnd(): number;
        set shadowLimitEnd(value: number);
        /**
         * high Light limit start 0-1
         */
        get highLightLimitStart(): number;
        set highLightLimitStart(value: number);
        /**
         * high Light limit end 0-1
         */
        get highLightLimitEnd(): number;
        set highLightLimitEnd(value: number);
        get enableLiftGammaGain(): boolean;
        set enableLiftGammaGain(value: boolean);
        /**
         * lift -1-1
         */
        get lift(): Vector3;
        set lift(value: Vector3);
        /**
         * gamma 999-0.5
         */
        get gamma(): Vector3;
        set gamma(value: Vector3);
        /**
         * gain 0-2
         */
        get gain(): Vector3;
        set gain(value: Vector3);
        private _StandardIlluminantY;
        private _CIExyToLMS;
        private _ColorBalanceToLMSCoeffs;
        get enableBalance(): boolean;
        set enableBalance(value: boolean);
        /**
         * tint -100 - 100
         */
        get tint(): number;
        set tint(value: number);
        /**
         * temperature -100-100
         */
        get temperature(): number;
        set temperature(value: number);
        get enableColorAdjust(): boolean;
        set enableColorAdjust(value: boolean);
        /**
         * 曝光
         */
        get postExposure(): number;
        set postExposure(value: number);
        /**
         * contrast颜色对比度range 0-2
         */
        get contrast(): number;
        set contrast(value: number);
        /**
         * 正片叠底
         */
        get colorFilter(): Color;
        set colorFilter(value: Color);
        /**色相 -0.5-0.5*/
        get HueShift(): number;
        set HueShift(value: number);
        /**
         * 饱和度
         */
        get saturation(): number;
        set saturation(value: number);
        /**
         * 创建一个 <code>BloomEffect</code> 实例。
         */
        constructor();
        private get lutSize();
        private set lutSize(value);
        private default_balance;
        private default_splitShadow;
        private default_splithighlights;
        private default_shadow;
        private default_midtones;
        private default_highlight;
        private default_limint;
        private default_lift;
        private default_gamma;
        private default_gain;
        private default_ColorFilter;
        private default_HueSatCon;
        /**
         * 添加到后期处理栈时,会调用
         */
        effectInit(postprocess: PostProcess): void;
        /**
         * 释放Effect
         */
        release(postprocess: PostProcess): void;
    }
    /**
     *  <code>BloomEffect</code> 类用于创建环境光遮罩效果。
     *  Gaussian DoF
     *  * 只支持 远景模糊
     *  - start: 开始远景模糊的深度
     *  - end: 达到最大模糊半径的远景深度
     *  - maxRadius: 远景模糊最大半径
     */
    class GaussianDoF extends PostProcessEffect {
        /**
         * GaussianDOF resource init
         */
        static init(): void;
        /**
         * 实例化一个高斯DOF效果类
         */
        constructor();
        /**
         * 开始远景模糊的深度
         */
        set farStart(value: number);
        get farStart(): number;
        /**
         * 达到最大模糊半径的远景深度
         */
        set farEnd(value: number);
        get farEnd(): number;
        /**
         * 最大模糊半径
         */
        set maxRadius(value: number);
        get maxRadius(): number;
        /**
        * @override
        * @param context
        */
        render(context: PostProcessRenderContext): void;
    }
    class LensFlareCMD extends Command {
        /**instance绘制的个数 */
        private _instanceCount;
        get instanceCount(): number;
        set instanceCount(value: number);
        /**
         * instance CMD
         */
        constructor();
        /**
         * init material
         */
        private _initMaterial;
        get lensFlareElement(): LensFlareElement;
        /**
         * apply element Data
         */
        applyElementData(): void;
        /**
         * @inheritDoc
         * @override
         */
        run(): void;
    }
    /**
     * lens Flare Element
     * 光耀元素
     */
    class LensFlareElement {
        private _startPosition;
        private _angularOffset;
        /**
         * 是否激活
         */
        get active(): boolean;
        set active(value: boolean);
        /**
         * 颜色
         */
        get tint(): Color;
        set tint(value: Color);
        /**
         * 强度
         */
        get intensity(): number;
        set intensity(value: number);
        /**
         * 贴图
         */
        get texture(): BaseTexture;
        set texture(value: BaseTexture);
        /**
         * 位置偏移(屏幕空间下)
         */
        get positionOffset(): Vector2;
        set positionOffset(value: Vector2);
        /**
         * 缩放(每个轴上)
         */
        get scale(): Vector2;
        set scale(value: Vector2);
        /**
         * 自动旋转
         */
        get autoRotate(): boolean;
        set autoRotate(value: boolean);
        /**
         * 旋转角度
         */
        get rotation(): number;
        set rotation(value: number);
        /**
         * 起始位置
         */
        get startPosition(): number;
        set startPosition(value: number);
        /**
         * 角度偏移
         */
        get angularOffset(): number;
        set angularOffset(value: number);
    }
    /**
     * lens Flare Data
     * 资源数据
     */
    class LensFlareData extends Resource {
        constructor();
        elements: LensFlareElement[];
    }
    /**
     * lens Flare Element
     */
    class LensFlareEffect extends PostProcessEffect {
        /**@interal */
        static SHADERDEFINE_AUTOROTATE: ShaderDefine;
        /**
         * init Shader\Geometry
         */
        static init(): void;
        /**
         * LensFlareData
         */
        set lensFlareData(value: LensFlareData);
        get lensFlareData(): LensFlareData;
        /**
         * bind light
         */
        set bindLight(light: Light);
        get bindLight(): Light;
        /**
         * 后处理强度
         */
        get effectIntensity(): number;
        set effectIntensity(value: number);
        /**
         * 后处理缩放
         */
        get effectScale(): number;
        set effectScale(value: number);
        constructor();
        /**
         * 计算直射光中心点
         * @param camera
         */
        caculateDirCenter(camera: Camera): void;
        /**
         * 计算点光
         * @param camera
         */
        caculatePointCenter(camera: Camera): void;
        /**
         * 计算spot光
         * @param value
         */
        caculateSpotCenter(value: Vector2): void;
        /**
         * 渲染流程
         * @param context
         * @returns
         */
        render(context: PostProcessRenderContext): void;
        /**
       * 释放Effect
       * @inheritDoc
       * @override
       */
        release(postprocess: PostProcess): void;
    }
    class LensFlareElementGeomtry extends GeometryElement {
        static PositionUV: number;
        static PositionRotationScale: number;
        /**
         * initData
         */
        static init(): void;
        /**
         * instance LensFlaresGeometry
         */
        constructor();
        /**
         * 销毁。
         */
        destroy(): void;
    }
    class LensFlareShaderInit {
        static init(): void;
    }
    /**
     * AO质量
     */
    enum AOQUALITY {
        /**高 */
        High = 0,
        /**中 */
        MEDIUM = 1,
        /**低 */
        LOWEST = 2
    }
    /**
     * <code>BloomEffect</code> 类用于创建环境光遮罩效果。
     */
    class ScalableAO extends PostProcessEffect {
        /**
         * scaleAO resource init
         */
        static init(): void;
        private _aoQuality;
        /**
         * 实例化一个AO效果类
         */
        constructor();
        /**
         * ao Color
         */
        set aoColor(value: Color);
        get aoColor(): Color;
        /**
         * ao intensity
         */
        set intensity(value: number);
        get intensity(): number;
        /**
         * ao影响半径
         */
        set radius(value: number);
        get radius(): number;
        /**
         * ao质量
         */
        get aoQuality(): AOQUALITY;
        set aoQuality(value: AOQUALITY);
        /**
         * @override
         */
        getCameraDepthTextureModeFlag(): DepthTextureMode;
        /**
         * @override
         * @param context
         */
        render(context: PostProcessRenderContext): void;
    }
    /**
         * <code>PostProcessEffect</code> 类用于创建后期处理渲染效果。
         */
    class PostProcessEffect {
        /**
         * 创建一个 <code>PostProcessEffect</code> 实例。
         */
        constructor();
        get singleton(): boolean;
        /**
         * 是否开启
         */
        get active(): boolean;
        set active(value: boolean);
        /**
         * 根据后期处理设置cameraDepthTextureMode
         * @inheritDoc
         * @override
         * @returns
         */
        getCameraDepthTextureModeFlag(): number;
        /**
         * 添加到后期处理栈时,会调用
         * @inheritDoc
         * @override
         */
        effectInit(postprocess: PostProcess): void;
        /**
         * 释放Effect
         * @inheritDoc
         * @override
         */
        release(postprocess: PostProcess): void;
    }
    /**
     * * <code>PostProcessRenderContext</code> 类用于创建后期处理渲染上下文。
     */
    class PostProcessRenderContext {
        /** origan RenderTexture 原始渲染RT,禁止改变此RT*/
        source: RenderTexture | null;
        /** forward effect target 上个后期处理的结果*/
        indirectTarget: RenderTexture | null;
        /** dest RenderTexture 需要将处理后的结果画入此RT*/
        destination: RenderTexture | null;
        /** 渲染相机。*/
        camera: Camera | null;
        /** 合成着色器数据。*/
        compositeShaderData: ShaderData | null;
        /** 后期处理指令流。*/
        command: CommandBuffer | null;
        /** 临时纹理数组。可以将创建的纹理放入此,也可以从这里选取要用的RT来节省显存*/
        deferredReleaseTextures: RenderTexture[];
        /**
         * 从回收的RT中选择一个RT 用来节省内存
         */
        createRTByContextReleaseTexture(width: number, height: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat, mipmap?: boolean, multiSamples?: number, depthTexture?: boolean, sRGB?: boolean): RenderTexture;
    }
    /**
     * <code>RenderContext3D</code> 类用于实现渲染状态。
     */
    class RenderContext3D {
        static _instance: RenderContext3D;
        /**渲染区宽度。*/
        static clientWidth: number;
        /**渲染区高度。*/
        static clientHeight: number;
        camera: Camera;
        /**设置渲染管线 */
        configPipeLineMode: PipelineMode;
        set viewport(value: Viewport);
        set scissor(value: Vector4);
        set invertY(value: boolean);
        set pipelineMode(value: PipelineMode);
        get cameraShaderValue(): ShaderData;
        set cameraShaderValue(value: ShaderData);
        get scene(): Scene3D;
        changeViewport(x: number, y: number, width: number, height: number): void;
        changeScissor(x: number, y: number, width: number, height: number): void;
        applyContext(cameraUpdateMark: number): void;
        /**
         * 渲染一个
         * @param element
         */
        drawRenderElement(element: RenderElement): void;
        /**
         * 创建一个 <code>RenderContext3D</code> 实例。
         */
        constructor();
    }
    /**
     * <code>RenderElement</code> 类用于实现渲染元素。
     */
    class RenderElement {
        /**
         * 可提交底层的渲染节点
         */
        _renderElementOBJ: IRenderElement;
        _batchElement: RenderElement;
        _transform: Transform3D;
        /**
         * set RenderElement Material/Shaderdata
         */
        set material(value: Material);
        /**
         * 设置 SubShader
         */
        set renderSubShader(value: SubShader);
        get renderSubShader(): SubShader;
        set subShaderIndex(value: number);
        get subShaderIndex(): number;
        get render(): BaseRender;
        /**
         * 创建一个 <code>RenderElement</code> 实例。
         */
        constructor();
        protected _createRenderElementOBJ(): void;
        /**
         * 设置位置
         */
        setTransform(transform: Transform3D): void;
        /**
         * 设置渲染几何信息
         */
        setGeometry(geometry: GeometryElement): void;
        /**
         * 编译shader
         * @param context
         */
        compileShader(context: IRenderContext3D): void;
        /**
         * 切换Shader
         * @param customShader
         * @param replacementTag
         * @param subshaderIndex
         * @returns
         */
        _convertSubShader(customShader: Shader3D, replacementTag: string, subshaderIndex?: number): void;
        /**
         * pre update data
         * @param context
         */
        _renderUpdatePre(context: RenderContext3D): void;
    }
    /**
     * <code>ScreenQuad</code> 类用于创建全屏四边形。
     */
    class ScreenQuad extends GeometryElement {
        /**
         * 创建一个 <code>ScreenQuad</code> 实例,禁止使用。
         */
        constructor();
        /**
         * set BufferState
         */
        set invertY(value: boolean);
        /**
         * @inheritDoc
         * @override
         */
        destroy(): void;
    }
    class Sprite3DRenderDeclaration {
        /**盒子反射宏 */
        static SHADERDEFINE_SPECCUBE_BOX_PROJECTION: ShaderDefine;
        static SHADERDEFINE_VOLUMETRICGI: ShaderDefine;
    }
    /**
     * @deprecated
     * <code>RenderableSprite3D</code> 类用于可渲染3D精灵的父类，抽象类不允许实例。
     */
    class RenderableSprite3D extends Sprite3D {
        /**精灵级着色器宏定义,接收阴影。*/
        static SHADERDEFINE_RECEIVE_SHADOW: ShaderDefine;
        /**精灵级着色器宏定义,光照贴图。*/
        static SAHDERDEFINE_LIGHTMAP: ShaderDefine;
        /**精灵级着色器宏定义,光照贴图方向。 */
        static SHADERDEFINE_LIGHTMAP_DIRECTIONAL: ShaderDefine;
        /**着色器变量名，光照贴图缩放和偏移。*/
        static LIGHTMAPSCALEOFFSET: number;
        /**着色器变量名，光照贴图。*/
        static LIGHTMAP: number;
        /**着色器变量名，光照贴图方向。*/
        static LIGHTMAP_DIRECTION: number;
        /**拾取颜色。*/
        static PICKCOLOR: number;
        /** 反射探针位置 最大、最小值*/
        static REFLECTIONCUBE_PROBEPOSITION: number;
        static REFLECTIONCUBE_PROBEBOXMAX: number;
        static REFLECTIONCUBE_PROBEBOXMIN: number;
        /** volumetric GI */
        static VOLUMETRICGI_PROBECOUNTS: number;
        static VOLUMETRICGI_PROBESTEPS: number;
        static VOLUMETRICGI_PROBESTARTPOS: number;
        static VOLUMETRICGI_PROBEPARAMS: number;
        static VOLUMETRICGI_IRRADIANCE: number;
        static VOLUMETRICGI_DISTANCE: number;
        static SHADERDEFINE_MORPHTARGET: ShaderDefine;
        static SHADERDEFINE_MORPHTARGET_POSITION: ShaderDefine;
        static SHADERDEFINE_MORPHTARGET_NORMAL: ShaderDefine;
        static SHADERDEFINE_MORPHTARGET_TANGENT: ShaderDefine;
        /**
         * @deprecated
         *  反射贴图
         */
        static REFLECTIONTEXTURE: number;
        /**
         * @deprecated
         *  反射贴图参数
         */
        static REFLECTIONCUBE_HDR_PARAMS: number;
        /**
         * @deprecated
         * 创建一个 <code>RenderableSprite3D</code> 实例。
         */
        constructor(name: string);
        /**
         * @inheritDoc
         * @override
         */
        protected _onInActive(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected _onActive(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected _onActiveInScene(): void;
    }
    /**
     * 环境光模式
     */
    enum AmbientMode {
        /** 固定颜色。*/
        SolidColor = 0,
        /** 球谐光照, 通过天空盒生成的球谐数据。 */
        SphericalHarmonics = 1,
        /** 分别设置天空, 地平线, 地面的环境光颜色 */
        TripleColor = 2
    }
    /**
     * BVH系统
     */
    class BVHSpatial {
        /**
         * Override it
         * @returns
         */
        protected _creatChildNode(): BVHSpatialBox<IBoundsCell>;
        /**
         * 创建BVH系统实例
         */
        constructor(bvhConfig?: BVHSpatialConfig, bvhManager?: BVHSpatialManager);
        /**
         * 获得空间节点
         */
        get bvhSpatialBox(): BVHSpatialBox<IBoundsCell>;
        /**
         * 是否合法
         * @param cell
         * @returns
         */
        cellLegal(cell: IBoundsCell): boolean;
        /**
         * add one
         * @param cell
         */
        addOne(cell: IBoundsCell): boolean;
        /**
         * remove one
         * @param cell
         * @returns
         */
        removeOne(cell: IBoundsCell): boolean;
        /**
         * remove
         * @param cell
         */
        motionOne(cell: IBoundsCell): void;
        /**
        * 通过CameraCull查找逻辑对象
        * @override
        * @param frustum 视锥
        * @param out 输出逻辑对象组
        */
        getItemByCameraCullInfo(cameraCullInfo: ICameraCullInfo, out: SingletonList<IBoundsCell>): void;
        /**
         * 通过视锥查找逻辑对象
         * @override
         * @param frustum 视锥
         * @param out 输出逻辑对象组
         */
        getItemByFrustum(frustum: BoundFrustum, out: SingletonList<IBoundsCell>): void;
        /**
         * 通过阴影裁剪信息查找逻辑对象
         * @override
         * @param sci
         * @param out
         */
        getItemBySCI(sci: IShadowCullInfo, out: SingletonList<IBoundsCell>): void;
        /**
         * 帧循环，根据具体需求，选适合频率调用
         */
        update(): void;
        /**
         * rebuild
         */
        rebuild(): void;
        /**
         * destroy
         */
        destroy(): void;
    }
    /**
     * BVH子空间
     */
    class BVHSpatialBox<T> {
        private static _tempV3;
        private static _tempV3_2;
        /**
         * 包围盒和阴影相机的关系
         * @param box
         * @param cullInfo
         * @returns 0: 不相交，1：包含， 2：相交
         */
        static sciContainsBox(box: Bounds, cullInfo: IShadowCullInfo): number;
        /**
         * 包围盒是否和阴影相机相交
         * @param box
         * @param cullInfo
        */
        static sciIntersectsBox(box: Bounds, cullInfo: IShadowCullInfo): boolean;
        protected _children1: BVHSpatialBox<T>;
        /**此BVH设置 */
        protected _config: BVHSpatialConfig;
        /**BVH管理 */
        protected _bvhmanager: BVHSpatialManager;
        /**
         * 创建BVHSpaticalBox实例
         * @param bvhmanager
         * @param config
         */
        constructor(bvhmanager: BVHSpatialManager, config: BVHSpatialConfig);
        /**
         * 父节点
         */
        set parent(value: BVHSpatialBox<IBoundsCell>);
        get parent(): BVHSpatialBox<IBoundsCell>;
        /**
         * 去重
         * @param cell
         * @returns
         */
        private _isRepeat;
        /**
         * add one cell to list
         * @param cell
         */
        private _addOneCell;
        /**
         * remove one cell to list
         * @param cell
         * @returns
         */
        private _removeOneCell;
        /**
         * 清除队列
         * TODO 是否要清理bvhmanager
         */
        private _clearList;
        /**
         * 判断Float是否接近
         * @param x
         * @param y
         * @returns
         */
        private _isFloatMax;
        /**
         * 这个包围盒是否影响Box的包围盒大小
         */
        private _isBoundsContainedBySpatialBox;
        /**
         * 给box增加一个Bounds
         * @param cell
         */
        private _addBounds;
        /**
         * 给box减少一个bounds
         * @param cell
         */
        private _removeBounds;
        /**
         * 获得渲染list
         * @returns
         */
        getList(): IBoundsCell[];
        /**
         * 获得child0
         * @returns
         */
        getchild0(): BVHSpatialBox<T>;
        /**
         * 获得child1
         * @returns
         */
        getchild1(): BVHSpatialBox<T>;
        /**
         * fill one Cell
         * add but dont Split immediately
         */
        fillCell(cell: IBoundsCell): void;
        /**
         * fill remove one cell
         * remove but dont split imediately
         * @param cell
         */
        fillRemove(cell: IBoundsCell): void;
        /**
         * add one Cell
         * @param cell
         * @returns
         */
        addCell(cell: IBoundsCell): void;
        /**
         * remove one Cell
         * @param cell
         */
        removeCell(cell: IBoundsCell): void;
        /**
         * 构建BVHBox
         * @returns
         */
        splitBox(): void;
        /**
         * 获得最近的Content BVHBox
         * @param checkPos
         * @returns
         */
        getNearlist(checkPos: Vector3): BVHSpatialBox<T>;
        /**
         * 获得这个节点包含的所有content
         * @param out
         * @param conditionalFun条件函数
         */
        traverseBoundsCell(out: SingletonList<IBoundsCell>, conditionalFun?: Function): void;
        /**
         * Override it
         * @returns
         */
        protected _creatChildNode(): BVHSpatialBox<T>;
        /**
         * 通过CameraCull查找逻辑对象
         * @override
         * @param frustum 视锥
         * @param out 输出逻辑对象组
         */
        getItemByCameraCullInfo(cameraCullInfo: ICameraCullInfo, out: SingletonList<IBoundsCell>): void;
        /**
         * 通过视锥查找逻辑对象
         * @override
         * @param frustum 视锥
         * @param out 输出逻辑对象组
         */
        getItemByFrustum(frustum: BoundFrustum, out: SingletonList<IBoundsCell>): void;
        /**
         * 通过阴影裁剪信息查找逻辑对象
         * @override
         * @param sci
         * @param out
         */
        getItemBySCI(sci: IShadowCullInfo, out: SingletonList<IBoundsCell>): void;
        /**
         * 重算包围盒
         * null need Update by child
         * contents need Update by List
         */
        recaculateBox(): void;
        /**
         * 是否是根节点
         * @returns
         */
        isRoot(): boolean;
        /**
         * 是否是叶节点
         * @returns
         */
        isContentBox(): boolean;
        /**
         * 删除box
         */
        destroy(): void;
    }
    /**
     * 接受空间分割管理的逻辑对象   容器
     */
    class BVHSpatialManager {
        /**
         * 实例化BVHSpatialManager
         */
        constructor();
        /**
         * clear
         */
        clear(): void;
        /**
         * destroy
         */
        destroy(): void;
    }
    /**
     * BVHConfig
     */
    class BVHSpatialConfig {
    }
    /**
     * 类实现BVH架构的裁剪Pass
     */
    class BVHCullPass extends CullPassBase {
        protected _cullList: SingletonList<BaseRender>;
        /**
         * 获得裁剪队列
         */
        get cullList(): SingletonList<BaseRender>;
        /**
         * 基于相机视锥裁剪
         * @param cameraCullInfo
         * @param renderManager
         */
        cullByCameraCullInfo(cameraCullInfo: ICameraCullInfo, renderManager: BVHSceneRenderManager): void;
        /**
         * 基于阴影视锥裁剪
         * @param cullInfo
         * @param renderManager
         */
        cullByShadowCullInfo(cullInfo: IShadowCullInfo, renderManager: BVHSceneRenderManager): void;
        /**
         * 基于Spot视锥的裁剪
         * @param cameraCullInfo
         * @param renderManager
         */
        cullingSpotShadow(cameraCullInfo: ICameraCullInfo, renderManager: ISceneRenderManager): void;
    }
    class BVHRenderSpatial extends BVHSpatial {
        /**
         * Override it
         * @returns
         */
        protected _creatChildNode(): BVHRenderBox<BaseRender>;
        /**
         * 是否合法
         * @param cell
         * @returns
         */
        cellLegal(cell: BaseRender): boolean;
    }
    class BVHRenderBox<T> extends BVHSpatialBox<T> {
        /**
         * Override it
         * @returns
         */
        protected _creatChildNode(): BVHSpatialBox<T>;
        /**
         * 通过CameraCull查找逻辑对象
         * @override
         * @param frustum 视锥
         * @param out 输出逻辑对象组
         */
        getItemByCameraCullInfo(cameraCullInfo: ICameraCullInfo, out: SingletonList<BaseRender>): void;
        /**
        * 通过阴影裁剪信息查找逻辑对象
        * @override
        * @param sci
        * @param out
        */
        getItemBySCI(sci: IShadowCullInfo, out: SingletonList<BaseRender>): void;
    }
    class BVHSceneRenderManager extends SceneRenderManager {
        private _allRenderList;
        /**
         * 实例化
         */
        constructor(bvhConfig?: BVHSpatialConfig);
        /**
        * get RenderList
        */
        get list(): SingletonList<BaseRender>;
        set list(value: SingletonList<BaseRender>);
        get bvhSpatial(): BVHRenderSpatial;
        get otherList(): SingletonList<BaseRender>;
        /**
         * add Render Node
         * @param object
         */
        addRenderObject(object: BaseRender): void;
        /**
         * remove Render Node
         * @param object
         */
        removeRenderObject(object: BaseRender): void;
        /**
         * remove motion Object
         * @param object
         */
        removeMotionObject(object: BaseRender): void;
        /**
         * update All Motion Render Data
         */
        updateMotionObjects(): void;
        /**
         * add motion Render Data
         * @param object
         */
        addMotionObject(object: BaseRender): void;
        /**
         * destroy
         */
        destroy(): void;
    }
    /**
     * Interface Overall management of a type of component
     */
    interface IElementComponentManager {
    }
    /**
     * 光照贴图。
     */
    class Lightmap {
        static ApplyLightmapEvent: string;
        /** 光照贴图颜色。 */
        lightmapColor: Texture2D;
        /** 光照贴图方向。 */
        lightmapDirection: Texture2D;
    }
    enum FogMode {
        Linear = 0,
        EXP = 1,
        EXP2 = 2
    }
    /**
     * 用于实现3D场景。
     */
    class Scene3D extends Sprite implements ISubmit {
        /** reflection mode */
        static REFLECTIONMODE_SKYBOX: number;
        static REFLECTIONMODE_CUSTOM: number;
        /** RenderQueue mode */
        static SCENERENDERFLAG_RENDERQPAQUE: number;
        static SCENERENDERFLAG_SKYBOX: number;
        static SCENERENDERFLAG_RENDERTRANSPARENT: number;
        /**Scene3D UniformMap */
        static sceneUniformMap: CommandUniformMap;
        static SceneUBOData: UnifromBufferData;
        static componentManagerMap: Map<string, any>;
        /**
         * 场景更新标记
         */
        static set _updateMark(value: number);
        static get _updateMark(): number;
        static regManager(type: string, cla: any): void;
        /**
         * init shaderData
         */
        static shaderValueInit(): void;
        /**
         * legency ShaderData
         */
        static legacyLightingValueInit(): void;
        /**
         * 加载场景,注意:不缓存。
         * @param url 模板地址。
         * @param complete 完成回调。
         */
        static load(url: string, complete: Handler): void;
        /**ide配置文件使用 */
        _reflectionsSource: number;
        /**ide配置文件使用 */
        _reflectionsResolution: string;
        /**ide配置文件使用 */
        _reflectionsIblSamples: number;
        /**@interanl */
        _sundir: Vector3;
        /** @interanl */
        _sceneUniformData: UnifromBufferData;
        /** 当前创建精灵所属遮罩层。*/
        currentCreationLayer: number;
        /** 是否启用灯光。*/
        enableLight: boolean;
        componentElementMap: Map<string, IElementComponentManager>;
        /**
         * Scene3D所属的2D场景，使用IDE编辑的场景载入后具有此属性。
         */
        get scene2D(): Scene;
        /**
         * set SceneRenderableManager
         */
        set sceneRenderableManager(manager: SceneRenderManager);
        get sceneRenderableManager(): SceneRenderManager;
        /**
         * set ICullPass
         */
        set cullPass(cullPass: ICullPass);
        /**
         * 是否允许雾化。
         */
        get enableFog(): boolean;
        set enableFog(value: boolean);
        /**
         * 场景雾模式
         */
        get fogMode(): FogMode;
        set fogMode(value: FogMode);
        /**
         * 雾化颜色。
         */
        get fogColor(): Color;
        set fogColor(value: Color);
        /**
         * 雾化起始位置。
         */
        get fogStart(): number;
        set fogStart(value: number);
        /**
         * 雾化end范围。
         */
        get fogEnd(): number;
        set fogEnd(value: number);
        /**
         * 雾化密度
         */
        get fogDensity(): number;
        set fogDensity(value: number);
        set fogParams(value: Vector4);
        set GIRotate(value: number);
        get GIRotate(): number;
        /**
         * 环境光模式。
         * 如果值为AmbientMode.SolidColor一般使用ambientColor作为环境光源，如果值为如果值为AmbientMode.SphericalHarmonics一般使用ambientSphericalHarmonics作为环境光源。
         */
        get ambientMode(): AmbientMode;
        set ambientMode(value: AmbientMode);
        get sceneReflectionProb(): ReflectionProbe;
        /**
         * 固定颜色环境光。
         */
        get ambientColor(): Color;
        set ambientColor(value: Color);
        /**
         * 设置环境漫反射的强度
         */
        get ambientIntensity(): number;
        set ambientIntensity(value: number);
        /**
         * 设置反射探针强度
         */
        get reflectionIntensity(): number;
        set reflectionIntensity(value: number);
        /**
         * ambient sh
         */
        get ambientSH(): Float32Array;
        set ambientSH(value: Float32Array);
        /**
         * ambient iblTexture
         */
        get iblTex(): TextureCube;
        set iblTex(value: TextureCube);
        /**
         * ambient rgbd compress
         */
        get iblTexRGBD(): boolean;
        set iblTexRGBD(value: boolean);
        /**
         * 天空渲染器。
         */
        get skyRenderer(): SkyRenderer;
        /**
         * 物理模拟器。
         */
        get physicsSimulation(): IPhysicsManager;
        /**
         * 场景时钟。
         * @override
         */
        get timer(): Timer;
        set timer(value: Timer);
        /**
         * 光照贴图数组,返回值为浅拷贝数组。
         */
        get lightmaps(): Lightmap[];
        set lightmaps(value: Lightmap[]);
        /**
         * 阴影图更新频率（如果无自阴影，可以加大频率优化性能）
         */
        get shadowMapFrequency(): number;
        set shadowMapFrequency(value: number);
        /**
         * 创建一个 <code>Scene3D</code> 实例。
         */
        constructor();
        get componentElementDatasMap(): any;
        /**
         * @inheritDoc
         * @override
         */
        protected _onActive(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected _onInActive(): void;
        private _cullInfoCamera;
        get cullInfoCamera(): Camera;
        /**
         * scence外的Camera渲染场景,需要设置这个接口
         * @param camera
         */
        _setCullCamera(camera: Camera): void;
        /**
         * 重新计算CullCamera
         */
        recaculateCullCamera(): void;
        /**
         * @inheritDoc
         * @override
         * 删除资源
         */
        destroy(destroyChild?: boolean): void;
        /**
         * 获得某个组件的管理器
         * @param type
         */
        getComponentElementManager(type: string): IElementComponentManager;
        /**
         * 渲染入口
         */
        renderSubmit(): number;
        /**
         * 获得渲染类型
         */
        getRenderType(): number;
        /**
         * 删除渲染
         */
        releaseRender(): void;
        /**
         * 设置全局渲染数据
         * @param name 数据对应着色器名字
         * @param shaderDataType 渲染数据类型
         * @param value 渲染数据值
         */
        setGlobalShaderValue(name: string, type: ShaderDataType, value: ShaderDataItem): void;
        /**
         * @deprecated
         */
        get fogRange(): number;
        set fogRange(value: number);
        /**
         * @deprecated
         * 设置光照贴图。
         * @param value 光照贴图。
         */
        setlightmaps(value: Texture2D[]): void;
        /**
         * @deprecated
         * 获取光照贴图浅拷贝列表。
         * @return 获取光照贴图浅拷贝列表。
         */
        getlightmaps(): Texture2D[];
    }
    /**
     * <code>类用来实现场景渲染节点管理<code/>
     */
    class SceneRenderManager {
        /**
         * 实例化一个场景管理节点
         */
        constructor();
        /**
         * get RenderList
         */
        get list(): SingletonList<BaseRender>;
        set list(value: SingletonList<BaseRender>);
        /**
         * add Render Node
         * @param object
         */
        addRenderObject(object: BaseRender): void;
        /**
         * remove Render Node
         * @param object
         */
        removeRenderObject(object: BaseRender): void;
        /**
         * remove motion Object
         * @param object
         */
        removeMotionObject(object: BaseRender): void;
        /**
         * update All Motion Render Data
         */
        updateMotionObjects(): void;
        /**
         * add motion Render Data
         * @param object
         */
        addMotionObject(object: BaseRender): void;
        /**
         * destroy
         */
        destroy(): void;
    }
    class SimpleSkinnedMeshRenderer extends SkinnedMeshRenderer {
        /**
         * 创建一个 <code>SkinnedMeshRender</code> 实例。
         */
        constructor();
        protected _getcommonUniformMap(): string[];
        /**
         * 自定义数据
         * @param value1 自定义数据1
         * @param value2 自定义数据1
         */
        setCustomData(value1: number, value2?: number): void;
        _cloneTo(dest: Component): void;
        /**
         * 删除节点
         */
        protected _onDestroy(): void;
    }
    /**
     * <code>SkinnedMeshSprite3D</code> 类用于创建网格。
     */
    class SimpleSkinnedMeshSprite3D extends RenderableSprite3D {
        /** */
        static SIMPLE_SIMPLEANIMATORTEXTURE: number;
        static SIMPLE_SIMPLEANIMATORPARAMS: number;
        static SIMPLE_SIMPLEANIMATORTEXTURESIZE: number;
        /**
         * 网格过滤器。
         */
        get meshFilter(): MeshFilter;
        /**
         * 网格渲染器。
         */
        get simpleSkinnedMeshRenderer(): SimpleSkinnedMeshRenderer;
        /**
         * 创建一个 <code>MeshSprite3D</code> 实例。
         * @param mesh 网格,同时会加载网格所用默认材质。
         * @param name 名字。
         */
        constructor(mesh?: Mesh, name?: string);
        /**
         * @inheritDoc
         * @override
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * <code>SkinMeshRenderer</code> 类用于蒙皮渲染器。
     */
    class SkinnedMeshRenderer extends MeshRenderer {
        _bones: Sprite3D[];
        /**
         * 局部边界。
         */
        get localBounds(): Bounds;
        set localBounds(value: Bounds);
        /**
         * 根节点。
         */
        get rootBone(): Sprite3D;
        set rootBone(value: Sprite3D);
        /**
         * 用于蒙皮的骨骼。
         */
        get bones(): Sprite3D[];
        /**
         * 创建一个 <code>SkinnedMeshRender</code> 实例。
         */
        constructor();
        protected _computeSkinnedData(): void;
        protected _computeSkinnedDataForNative(): void;
        _setBelongScene(scene: Scene3D): void;
        protected _onDestroy(): void;
    }
    /**
     * <code>SkinnedMeshSprite3D</code> 类用于绑点骨骼节点精灵。
     */
    class SkinnedMeshSprite3D extends RenderableSprite3D {
        /**着色器变量名，蒙皮动画。*/
        static BONES: number;
        /**
         * 网格过滤器。
         */
        get meshFilter(): MeshFilter;
        /**
         * 网格渲染器。
         */
        get skinnedMeshRenderer(): SkinnedMeshRenderer;
        /**
         * 创建一个 <code>MeshSprite3D</code> 实例。
         * @param mesh 网格,同时会加载网格所用默认材质。
         * @param name 名字。
         */
        constructor(mesh?: Mesh, name?: string);
        /**
         * @inheritDoc
         * @override
         */
        destroy(destroyChild?: boolean): void;
    }
    class SkinnedMeshSprite3DShaderDeclaration {
        /**精灵级着色器宏定义,蒙皮动画。*/
        static SHADERDEFINE_BONE: ShaderDefine;
        static SHADERDEFINE_SIMPLEBONE: ShaderDefine;
    }
    /**
     * <code>Sprite3D</code> 类用于实现3D精灵。
     */
    class Sprite3D extends Node {
        static WORLDINVERTFRONT: number;
        /**
         * 创建精灵的克隆实例。
         * @param	original  原始精灵。
         * @param   parent    父节点。
         * @param   worldPositionStays 是否保持自身世界变换。
         * @param	position  世界位置,worldPositionStays为false时生效。
         * @param	rotation  世界旋转,worldPositionStays为false时生效。
         * @return  克隆实例。
         */
        static instantiate(original: Sprite3D, parent?: Node, worldPositionStays?: boolean, position?: Vector3, rotation?: Quaternion): Sprite3D;
        /**
         * 加载网格模板。
         * @param url 模板地址。
         * @param complete 完成回掉。
         */
        static load(url: string, complete: Handler): void;
        /**
         * 唯一标识ID。
         */
        get id(): number;
        /**
         * 蒙版层。
         */
        get layer(): number;
        set layer(value: number);
        /**
         * 是否为静态。
         */
        get isStatic(): boolean;
        /**
         * 精灵变换。
         */
        get transform(): Transform3D;
        get scene(): Scene3D;
        /**
         * 创建一个 <code>Sprite3D</code> 实例。
         * @param name 精灵名称。
         * @param isStatic 是否为静态。
         */
        constructor(name?: string, isStatic?: boolean);
        /**
        * @private
        */
        protected _onActive(): void;
        /**
         * @private
         */
        protected _onInActive(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected _onAdded(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected _onRemoved(): void;
        protected onStartListeningToType(type: string): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): Node;
        /**
         * @inheritDoc
         * @override
         */
        destroy(destroyChild?: boolean): void;
    }
    enum TrailAlignment {
        /** 使拖尾面向摄像机。*/
        View = 0,
        /** 使拖尾的与组件的方向对齐*/
        TransformZ = 1
    }
    /**
     * <code>TrailFilter</code> 类用于创建拖尾过滤器。
     */
    class TrailFilter {
        static CURTIME: number;
        static LIFETIME: number;
        static WIDTHCURVE: number;
        static WIDTHCURVEKEYLENGTH: number;
        static __init__(): void;
        _ownerRender: TrailRenderer;
        _lastPosition: Vector3;
        _curtime: number;
        /**轨迹准线。*/
        alignment: TrailAlignment;
        /**
         * 获取淡出时间。
         * @return  淡出时间。
         */
        get time(): number;
        /**
         * 设置淡出时间。
         * @param value 淡出时间。
         */
        set time(value: number);
        /**
         * 获取新旧顶点之间最小距离。
         * @return  新旧顶点之间最小距离。
         */
        get minVertexDistance(): number;
        /**
         * 设置新旧顶点之间最小距离。
         * @param value 新旧顶点之间最小距离。
         */
        set minVertexDistance(value: number);
        /**
         * 获取宽度倍数。
         * @return  宽度倍数。
         */
        get widthMultiplier(): number;
        /**
         * 设置宽度倍数。
         * @param value 宽度倍数。
         */
        set widthMultiplier(value: number);
        /**
         * 获取宽度曲线。
         * @return  宽度曲线。
         */
        get widthCurve(): FloatKeyframe[];
        /**
         * 设置宽度曲线。最多10个
         * @param value 宽度曲线。
         */
        set widthCurve(value: FloatKeyframe[]);
        /**
         * 获取颜色梯度。
         * @return  颜色梯度。
         */
        get colorGradient(): Gradient;
        /**
         * 设置颜色梯度。
         * @param value 颜色梯度。
         */
        set colorGradient(value: Gradient);
        /**
         * 获取纹理模式。
         * @return  纹理模式。
         */
        get textureMode(): TrailTextureMode;
        /**
         * 设置纹理模式。
         * @param value 纹理模式。
         */
        set textureMode(value: TrailTextureMode);
        constructor(owner: TrailRenderer);
        clear(): void;
    }
    /**
     * <code>TrailGeometry</code> 类用于创建拖尾渲染单元。
     */
    class TrailGeometry extends GeometryElement {
        /** 轨迹准线_面向摄像机。*/
        static ALIGNMENT_VIEW: number;
        /** 轨迹准线_面向运动方向。*/
        static ALIGNMENT_TRANSFORM_Z: number;
        private tmpColor;
        /** @private */
        private _disappearBoundsMode;
        constructor(owner: TrailFilter);
        /**
         * @inheritDoc
         * @override
         */
        _getType(): number;
        /**
         * @inheritDoc
         * @override
         */
        destroy(): void;
        clear(): void;
    }
    /**
     * <code>TrailMaterial</code> 类用于实现拖尾材质。
     */
    class TrailMaterial extends Material {
        /** 默认材质，禁止修改*/
        static defaultMaterial: TrailMaterial;
        /**
         * 获取颜色。
         * @return 颜色。
         */
        get color(): Color;
        /**
         * 设置颜色。
         * @param value 颜色。
         */
        set color(value: Color);
        /**
         * 获取贴图。
         * @return 贴图。
         */
        get texture(): BaseTexture;
        /**
         * 设置贴图。
         * @param value 贴图。
         */
        set texture(value: BaseTexture);
        /**
         * 获取纹理平铺和偏移。
         * @return 纹理平铺和偏移。
         */
        get tilingOffset(): Vector4;
        /**
         * 设置纹理平铺和偏移。
         * @param value 纹理平铺和偏移。
         */
        set tilingOffset(value: Vector4);
        constructor();
        /**
         * @inheritdoc
         * @override
         */
        clone(): any;
        /**
         * @deprecated
         * 渲染状态_透明混合。
         */
        static RENDERMODE_ALPHABLENDED: number;
        /**
        * @deprecated
        * 渲染状态_加色法混合。
        */
        static RENDERMODE_ADDTIVE: number;
        /**
         * @deprecated
         * 渲染模式。现在可以直接使用materialRenderMode
         */
        set renderMode(value: number);
    }
    /**
     * <code>TrailRenderer</code> 类用于创建拖尾渲染器。
     */
    class TrailRenderer extends BaseRender {
        protected _projectionViewWorldMatrix: Matrix4x4;
        /**
         * 实例化一个拖尾渲染器
         */
        constructor();
        protected _getcommonUniformMap(): Array<string>;
        protected _onAdded(): void;
        /**
         * 获取淡出时间。单位s
         * @return  淡出时间。
         */
        get time(): number;
        /**
         * 设置淡出时间。单位s
         * @param value 淡出时间。
         */
        set time(value: number);
        /**
         * 获取新旧顶点之间最小距离。
         * @return  新旧顶点之间最小距离。
         */
        get minVertexDistance(): number;
        /**
         * 设置新旧顶点之间最小距离。
         * @param value 新旧顶点之间最小距离。
         */
        set minVertexDistance(value: number);
        /**
         * 获取宽度倍数。
         * @return  宽度倍数。
         */
        get widthMultiplier(): number;
        /**
         * 设置宽度倍数。
         * @param value 宽度倍数。
         */
        set widthMultiplier(value: number);
        /**
         * 获取宽度曲线。
         * @return  宽度曲线。
         */
        get widthCurve(): FloatKeyframe[];
        /**
         * 设置宽度曲线。最多10个
         * @param value 宽度曲线。
         */
        set widthCurve(value: FloatKeyframe[]);
        /**
         * 获取颜色梯度。
         * @return  颜色梯度。
         */
        get colorGradient(): Gradient;
        /**
         * 设置颜色梯度。
         * @param value 颜色梯度。
         */
        set colorGradient(value: Gradient);
        /**
         * 获取纹理模式。
         * @return  纹理模式。
         */
        get textureMode(): TrailTextureMode;
        /**
         * 设置纹理模式。
         * @param value 纹理模式。
         */
        set textureMode(value: TrailTextureMode);
        get alignment(): TrailAlignment;
        set alignment(value: TrailAlignment);
        protected _onEnable(): void;
        onUpdate(): void;
        /**
         * 包围盒,只读,不允许修改其值。
         */
        get bounds(): Bounds;
        clear(): void;
        _cloneTo(dest: Component): void;
    }
    /**
     * <code>TrailSprite3D</code> 类用于创建拖尾渲染精灵。
     */
    class TrailSprite3D extends RenderableSprite3D {
        /**
         * Trail过滤器。
         */
        get trailFilter(): TrailFilter;
        /**
         * Trail渲染器。
         */
        get trailRenderer(): TrailRenderer;
        constructor(name?: string);
        clear(): void;
    }
    class TrailTextureMode {
        /**
         * 拉伸模式。
         */
        static Stretch: number;
        /**
         * 平铺模式。
         */
        static Tile: number;
    }
    /**
     * <code>Transform3D</code> 类用于实现3D变换。
     */
    class Transform3D extends EventDispatcher {
        protected _faceInvert: boolean;
        protected _frontFaceValue: number;
        getFrontFaceValue(): number;
        /**
         * 所属精灵。
         */
        get owner(): Sprite3D;
        /**
         * 世界矩阵是否需要更新。
         */
        get worldNeedUpdate(): boolean;
        /**
         * 局部位置X轴分量。
         */
        get localPositionX(): number;
        set localPositionX(x: number);
        /**
         * 局部位置Y轴分量。
         */
        get localPositionY(): number;
        set localPositionY(y: number);
        /**
         * 局部位置Z轴分量。
         */
        get localPositionZ(): number;
        set localPositionZ(z: number);
        /**
         * 局部位置。
         */
        get localPosition(): Vector3;
        set localPosition(value: Vector3);
        /**
         * 局部旋转四元数X分量。
         */
        get localRotationX(): number;
        set localRotationX(x: number);
        /**
         * 局部旋转四元数Y分量。
         */
        get localRotationY(): number;
        set localRotationY(y: number);
        /**
         * 局部旋转四元数Z分量。
         */
        get localRotationZ(): number;
        set localRotationZ(z: number);
        /**
         * 局部旋转四元数W分量。
         */
        get localRotationW(): number;
        set localRotationW(w: number);
        /**
         * 局部旋转。
         */
        get localRotation(): Quaternion;
        set localRotation(value: Quaternion);
        /**
         * 局部缩放X。
         */
        get localScaleX(): number;
        set localScaleX(value: number);
        /**
         * 局部缩放Y。
         */
        get localScaleY(): number;
        set localScaleY(value: number);
        /**
         * 局部缩放Z。
         */
        get localScaleZ(): number;
        set localScaleZ(value: number);
        /**
         * 局部缩放。
         */
        get localScale(): Vector3;
        set localScale(value: Vector3);
        /**
         * 局部空间的X轴欧拉角。
         */
        get localRotationEulerX(): number;
        set localRotationEulerX(value: number);
        /**
         * 局部空间的Y轴欧拉角。
         */
        get localRotationEulerY(): number;
        set localRotationEulerY(value: number);
        /**
         * 局部空间的Z轴欧拉角。
         */
        get localRotationEulerZ(): number;
        set localRotationEulerZ(value: number);
        /**
         * 局部空间欧拉角。
         */
        get localRotationEuler(): Vector3;
        set localRotationEuler(value: Vector3);
        /**
         * 局部矩阵。
         */
        get localMatrix(): Matrix4x4;
        set localMatrix(value: Matrix4x4);
        /**
         * 世界位置。
         */
        get position(): Vector3;
        set position(value: Vector3);
        /**
         * 世界旋转。
         */
        get rotation(): Quaternion;
        set rotation(value: Quaternion);
        /**
         * 世界空间的旋转角度，顺序为x、y、z。
         */
        get rotationEuler(): Vector3;
        set rotationEuler(value: Vector3);
        /**
         * 世界矩阵。
         */
        get worldMatrix(): Matrix4x4;
        set worldMatrix(value: Matrix4x4);
        /**
         * 平移变换。
         * @param 	translation 移动距离。
         * @param 	isLocal 是否局部空间。
         */
        translate(translation: Vector3, isLocal?: boolean): void;
        /**
         * 旋转变换。
         * @param 	rotations 旋转幅度。
         * @param 	isLocal 是否局部空间。
         * @param 	isRadian 是否弧度制。
         */
        rotate(rotation: Vector3, isLocal?: boolean, isRadian?: boolean): void;
        /**
         * 获取向前方向。
         * @param forward 前方向。
         */
        getForward(forward: Vector3): void;
        /**
         * 获取向上方向。
         * @param up 上方向。
         */
        getUp(up: Vector3): void;
        /**
         * 获取向右方向。
         * @param 右方向。
         */
        getRight(right: Vector3): void;
        /**
         * 观察目标位置。
         * @param	target 观察目标。
         * @param	up 向上向量。
         * @param	isLocal 是否局部空间。
         */
        lookAt(target: Vector3, up: Vector3, isLocal?: boolean, isCamera?: boolean): void;
        /**
         * 对象朝向目标
         * @param target
         * @param up
         * @param isLocal
         */
        objLookat(target: Vector3, up: Vector3, isLocal?: boolean): void;
        /**
         * 世界缩放。
         * 某种条件下获取该值可能不正确（例如：父节点有缩放，子节点有旋转），缩放会倾斜，无法使用Vector3正确表示,必须使用Matrix3x3矩阵才能正确表示。
         * @return	世界缩放。
         */
        getWorldLossyScale(): Vector3;
        /**
         * 设置世界缩放。
         * 某种条件下设置该值可能不正确（例如：父节点有缩放，子节点有旋转），缩放会倾斜，无法使用Vector3正确表示,必须使用Matrix3x3矩阵才能正确表示。
         * @return	世界缩放。
         */
        setWorldLossyScale(value: Vector3): void;
        /**
         * @deprecated
         */
        get scale(): Vector3;
        /**
         * @deprecated
         */
        set scale(value: Vector3);
        localToGlobal(value: Vector3, out: Vector3): void;
        /**
         *转化成局部坐标
            * @param pos
            * @param out
            *
            */
        globalToLocal(pos: Vector3, out: Vector3): void;
        /**
         *转化成局部向量
         * @param pos
         * @param out
         *
         */
        toLocalNormal(pos: Vector3, out: Vector3): void;
        toDir(forward: Vector3, dir: Vector3): void;
        static tmpVec3: Vector3;
        /**
         * 这是一个 glmatrix中的函数
         * a,b都是规格化以后的向量
         * Sets a quaternion to represent the shortest rotation from one
         * vector to another.
         *
         * Both vectors are assumed to be unit length.
         *
         * @param {quat} out the receiving quaternion.
         * @param {vec3} a the initial vector
         * @param {vec3} b the destination vector
         * @returns {quat} out
         */
        rotationTo(out: Quaternion, a: Vector3, b: Vector3): boolean;
    }
    /**
     * <code>BaseCamera</code> 类用于创建摄像机的父类。
     */
    class UI3D extends BaseRender {
        /**@intrtnal */
        static TempMatrix: Matrix4x4;
        private _shellSprite;
        /**
         * 3D渲染的UI节点
         */
        set sprite(value: Sprite);
        get sprite(): Sprite;
        /**
         * IDE
         * 3D渲染的UI预制体
         */
        set prefab(value: Prefab);
        get prefab(): Prefab;
        /**
         * UI3DmeshScale
         */
        set scale(value: Vector2);
        get scale(): Vector2;
        /**
         * UI渲染模式
         */
        set renderMode(value: MaterialRenderMode);
        get renderMode(): MaterialRenderMode;
        /**
         * UI剔除模式
         */
        set cull(value: number);
        get cull(): number;
        /**
         * 分辨率比例
         */
        get resolutionRate(): number;
        set resolutionRate(value: number);
        /**
         * 面向相机模式
         */
        get billboard(): boolean;
        set billboard(value: boolean);
        /**
         * 检测鼠标事件(关闭优化性能)，开启可以触发鼠标事件
         */
        get enableHit(): boolean;
        set enableHit(value: boolean);
        /**
         * 实例化一个UI3D
         */
        constructor();
        /**
        * 分析碰撞点
        * @param hit
        */
        private _parseHit;
        /**
         * 获得ui渲染图
         */
        getUITexture(): BaseTexture;
        /**
         * get camera distance
         * @param rayOri
         * @returns
         */
        _getCameraDistance(rayOri: Vector3): number;
        private _transByRotate;
    }
    class UI3DGeometry extends GeometryElement {
        private _changeVertex;
        /**
         * @inheritDoc
         * @override
         */
        destroy(): void;
    }
    class UI3DManager {
        _UI3Dlist: SingletonList<UI3D>;
        constructor();
        add(value: UI3D): void;
        remove(value: UI3D): void;
        update(): void;
        /**
         * 判断是否碰撞
         */
        rayCast(ray: Ray): any;
        /**
         * Destroy
         */
        destory(): void;
    }
    /**
     * <code>Vector2Keyframe</code> 类用于创建三维向量关键帧实例。
     */
    class Vector2Keyframe extends Keyframe {
        /**内切线 */
        inTangent: Vector2;
        /**外切线 */
        outTangent: Vector2;
        /**帧数据 */
        value: Vector2;
        /**内权重 */
        inWeight: Vector2;
        /**外权重 */
        outWeight: Vector2;
        /**权重模式 */
        weightedMode: Vector2;
        /**
         * 创建一个 <code>Vector2Keyframe</code> 实例。
         */
        constructor(weightMode?: boolean);
        /**
         * 克隆。
         * @param	destObject 克隆源。
         * @override
         */
        cloneTo(dest: any): void;
    }
    /**
     * <code>Vector3Keyframe</code> 类用于创建三维向量关键帧实例。
     */
    class Vector3Keyframe extends Keyframe {
        /**内切线 */
        inTangent: Vector3;
        /**外切线 */
        outTangent: Vector3;
        /**帧数据 */
        value: Vector3;
        /**内权重 */
        inWeight: Vector3;
        /**外权重 */
        outWeight: Vector3;
        /**权重模式 */
        weightedMode: Vector3;
        /**
         * 创建一个 <code>Vector3Keyframe</code> 实例。
         */
        constructor(weightMode?: boolean);
        /**
         * 克隆。
         * @param	destObject 克隆源。
         * @override
         */
        cloneTo(dest: any): void;
    }
    /**
     * <code>Vector4Keyframe</code> 类用于创建三维向量关键帧实例。
     */
    class Vector4Keyframe extends Keyframe {
        /**内切线 */
        inTangent: Vector4;
        /**外切线 */
        outTangent: Vector4;
        /**帧数据 */
        value: Vector4;
        /**内权重 */
        inWeight: Vector4;
        /**外权重 */
        outWeight: Vector4;
        /**权重模式 */
        weightedMode: Vector4;
        /**
         * 创建一个 <code>Vector4Keyframe</code> 实例。
         */
        constructor(weightMode?: boolean);
        /**
         * 克隆。
         * @param	destObject 克隆源。
         * @override
         */
        cloneTo(dest: any): void;
    }
    class DepthCasterData {
        static DepthCasterUBOData: UnifromBufferData;
    }
    /**
     * 深度贴图模式
     */
    enum DepthTextureMode {
        /**不生成深度贴图 */
        None = 0,
        /**生成深度贴图 */
        Depth = 1,
        /**生成深度+法线贴图 */
        DepthNormals = 2,
        /**是否应渲染运动矢量  TODO*/
        DepthAndDepthNormals = 3,
        MotionVectors = 4
    }
    /**
     * <code>ShadowCasterPass</code> 类用于实现阴影渲染管线
     */
    class DepthPass {
        private static SHADOW_BIAS;
        static __init__(): void;
        constructor();
        /**
         * 渲染深度更新
         * @param camera
         * @param depthType
         */
        update(camera: Camera, depthType: DepthTextureMode, depthTextureFormat: RenderTargetFormat): void;
        /**
         * 渲染深度帧缓存
         * @param context
         * @param depthType
         */
        render(context: RenderContext3D, depthType: DepthTextureMode): void;
    }
    class RenderElementBatch {
        static instance: RenderElementBatch;
        private _instanceBatchManager;
        private _recoverList;
        constructor();
        /**
         * after batchRender
         */
        recoverData(): void;
        /**
         * BatchData
         * @param elements
         */
        batch(elements: FastSinglelist<RenderElement>): void;
    }
    /**
     * 请使用LayaGL.RenderOBJCreate.createIndexBuffer3D来创建
     * <code>IndexBuffer3D</code> 类用于创建索引缓冲。
     */
    class IndexBuffer3D extends IndexBuffer {
        /**
         * 索引类型。
         */
        get indexType(): IndexFormat;
        /**
         * 索引类型字节数量。
         */
        get indexTypeByteCount(): number;
        /**
         * 索引个数。
         */
        get indexCount(): number;
        /**
         * 是否可读。
         */
        get canRead(): boolean;
        /**
         * 创建一个 <code>IndexBuffer3D,不建议开发者使用并用IndexBuffer3D.create()代替</code> 实例。
         * @param	indexType 索引类型。
         * @param	indexCount 索引个数。
         * @param	bufferUsage IndexBuffer3D用途类型。
         * @param	canRead 是否可读。
         */
        constructor(indexType: IndexFormat, indexCount: number, bufferUsage?: BufferUsage, canRead?: boolean);
        /**
         * 设置数据。
         * @param	data 索引数据。
         * @param	bufferOffset 索引缓冲中的偏移。
         * @param	dataStartIndex 索引数据的偏移。
         * @param	dataCount 索引数据的数量。
         */
        setData(data: any, bufferOffset?: number, dataStartIndex?: number, dataCount?: number): void;
        /**
         * 获取索引数据。
         * @return	索引数据。
         */
        getData(): Uint16Array;
        /**
         * @inheritDoc
         * @override
         */
        destroy(): void;
    }
    /**
         * <code>IVertex</code> 接口用于实现创建顶点声明。
         */
    interface IVertex {
        /**顶点声明 */
        vertexDeclaration: VertexDeclaration;
    }
    /**
     * 二阶球谐函数。
     */
    class SphericalHarmonicsL2 {
        /**
         * 获取颜色通道的系数。
         * @param i 通道索引，范围0到2。
         * @param j 系数索引，范围0到8。
         */
        getCoefficient(i: number, j: number): number;
        /**
         * 设置颜色通道的系数。
         * @param i 通道索引，范围0到2。
         * @param j 系数索引，范围0到8。
         */
        setCoefficient(i: number, j: number, coefficient: number): void;
        /**
         * 设置颜色通道的系数。
         * @param i 通道索引，范围0到2。
         * @param coefficient0 系数0
         * @param coefficient1 系数1
         * @param coefficient2 系数2
         * @param coefficient3 系数3
         * @param coefficient4 系数4
         * @param coefficient5 系数5
         * @param coefficient6 系数6
         * @param coefficient7 系数7
         * @param coefficient8 系数8
         */
        setCoefficients(i: number, coefficient0: number, coefficient1: number, coefficient2: number, coefficient3: number, coefficient4: number, coefficient5: number, coefficient6: number, coefficient7: number, coefficient8: number): void;
        /**
         * 克隆
         * @param dest
         */
        cloneTo(dest: SphericalHarmonicsL2): void;
    }
    /**
     * 请使用LayaGL.RenderOBJCreate.createIndexBuffer3D来创建
     * <code>VertexBuffer3D</code> 类用于创建顶点缓冲。
     */
    class VertexBuffer3D extends VertexBuffer {
        /**
         * 获取顶点声明。
         */
        get vertexDeclaration(): VertexDeclaration | null;
        set vertexDeclaration(value: VertexDeclaration | null);
        /**
         * 是否可读。
         */
        get canRead(): boolean;
        /**
         * 创建一个 <code>VertexBuffer3D</code> 实例。
         * @param	byteLength 字节长度。
         * @param	bufferUsage VertexBuffer3D用途类型。
         * @param	canRead 是否可读。
         */
        constructor(byteLength: number, bufferUsage: BufferUsage, canRead?: boolean);
        /**
         * 剥离内存块存储。
         */
        orphanStorage(): void;
        /**
         * 设置数据。
         * @param	data 顶点数据。
         * @param	bufferOffset 顶点缓冲中的偏移,以字节为单位。
         * @param	dataStartIndex 顶点数据的偏移,以字节为单位。
         * @param	dataCount 顶点数据的长度,以字节为单位。
         */
        setData(buffer: ArrayBuffer, bufferOffset?: number, dataStartIndex?: number, dataCount?: number): void;
        /**
         * 获取顶点数据。
         * @return	顶点数据。
         */
        getUint8Data(): Uint8Array;
        /**
         * @ignore
         */
        getFloat32Data(): Float32Array | null;
        /**
         * @ignore
         */
        markAsUnreadbale(): void;
        /**
         * @inheritDoc
         * @override
         */
        destroy(): void;
    }
    class CubemapLoader implements IResourceLoader {
        constructor();
        load(task: ILoadTask): Promise<TextureCube>;
        private move;
    }
    class LensFlareSettingsLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<LensFlareData>;
    }
    class Texture2DArrayLoader implements IResourceLoader {
        constructor();
        load(task: ILoadTask): Promise<any>;
    }
    /**
     * <code>BoundBox</code> 类用于创建包围盒。
     */
    class BoundBox implements IClone {
        /**最小顶点。*/
        min: Vector3;
        /**最大顶点。*/
        max: Vector3;
        /**
         * 创建一个 <code>BoundBox</code> 实例。
         * @param	min 包围盒的最小顶点。
         * @param	max 包围盒的最大顶点。
         */
        constructor(min: Vector3, max: Vector3);
        /**
         * 获取包围盒的8个角顶点。
         * @param	corners 返回顶点的输出队列。
         */
        getCorners(corners: Vector3[]): void;
        /**
         * 获取中心点。
         * @param	out
         */
        getCenter(out: Vector3): void;
        /**
         * 获取范围。
         * @param	out
         */
        getExtent(out: Vector3): void;
        /**
         * 设置中心点和范围。
         * @param	center
         */
        setCenterAndExtent(center: Vector3, extent: Vector3): void;
        toDefault(): void;
        /**
         * 从顶点生成包围盒。
         * @param	points 所需顶点队列。
         * @param	out 生成的包围盒。
         */
        static createfromPoints(points: Vector3[], out: BoundBox): void;
        /**
         * 合并两个包围盒。
         * @param	box1 包围盒1。
         * @param	box2 包围盒2。
         * @param	out 生成的包围盒。
         */
        static merge(box1: BoundBox, box2: BoundBox, out: BoundBox): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: BoundBox): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * 锥体角点。
     */
    enum FrustumCorner {
        FarBottomLeft = 0,
        FarTopLeft = 1,
        FarTopRight = 2,
        FarBottomRight = 3,
        nearBottomLeft = 4,
        nearTopLeft = 5,
        nearTopRight = 6,
        nearBottomRight = 7,
        unknown = 8
    }
    /**
     * <code>BoundFrustum</code> 类用于创建锥截体。
     */
    class BoundFrustum implements IClone {
        /**
         * 根据矩阵获取6个包围平面。
         * @param  m 描述矩阵。
         * @param  np 近平面。
         * @param  fp 远平面。
         * @param  lp 左平面。
         * @param  rp 右平面。
         * @param  tp 顶平面。
         * @param  bp 底平面。
         */
        static getPlanesFromMatrix(m: Matrix4x4, np: Plane, fp: Plane, lp: Plane, rp: Plane, tp: Plane, bp: Plane): void;
        /**
         * 创建一个 <code>BoundFrustum</code> 实例。
         * @param	matrix 锥截体的描述4x4矩阵。
         */
        constructor(matrix: Matrix4x4);
        protected initBoundingPlane(): void;
        /**
         * 描述矩阵。
         */
        get matrix(): Matrix4x4;
        set matrix(matrix: Matrix4x4);
        /**
         * 近平面。
         */
        get near(): Plane;
        /**
         * 远平面。
         */
        get far(): Plane;
        /**
         * 左平面。
         */
        get left(): Plane;
        /**
         * 右平面。
         */
        get right(): Plane;
        /**
         * 顶平面。
         */
        get top(): Plane;
        /**
         * 底平面。
         */
        get bottom(): Plane;
        /**
         * 判断是否与其他锥截体相等。
         * @param	other 锥截体。
         */
        equalsBoundFrustum(other: BoundFrustum): boolean;
        /**
         * 判断是否与其他对象相等。
         * @param	obj 对象。
         */
        equalsObj(obj: any): boolean;
        /**
         * 获取锥截体的任意一平面。
         * 0:近平面
         * 1:远平面
         * 2:左平面
         * 3:右平面
         * 4:顶平面
         * 5:底平面
         * @param	index 索引。
         */
        getPlane(index: number): Plane;
        /**
         * 锥截体三个相交平面的交点。
         * @param  p1  平面1。
         * @param  p2  平面2。
         * @param  p3  平面3。
         */
        static get3PlaneInterPoint(p1: Plane, p2: Plane, p3: Plane, out: Vector3): void;
        /**
         * 锥截体的8个顶点。
         * @param  corners  返回顶点的输出队列。
         */
        getCorners(corners: Vector3[]): void;
        /**
         * 与点的关系。
         * @param  point  点。
         * @returns 包涵:1,相交:2,不相交:0
         */
        containsPoint(point: Vector3): number;
        /**
         * 是否与包围盒交叉。
         * @param box 包围盒。
         * @returns boolean 是否相交
         */
        intersects(box: BoundBox | Bounds): boolean;
        /**
         * 与包围盒的位置关系。
         * @param  box  包围盒。
         * @returns 包涵:1,相交:2,不相交:0
         */
        containsBoundBox(box: BoundBox | Bounds): number;
        /**
         * 与包围球的位置关系
         * @param  sphere  包围球。
         * @returns 包涵:1,相交:2,不相交:0
         */
        containsBoundSphere(sphere: BoundSphere): number;
        cloneTo(dest: BoundFrustum): void;
        clone(): BoundFrustum;
    }
    /**
     * <code>Bounds</code> 类用于创建包围体。
     */
    class Bounds implements IClone {
        /**
         * 合并两个包围盒。
         * @param	box1 包围盒1。
         * @param	box2 包围盒2。
         * @param	out 生成的包围盒。
         */
        static merge(box1: Bounds, box2: Bounds, out: Bounds): void;
        /**
         * 包围盒是否包含点
         * @param box
         * @param point
         * @returns
         */
        static containPoint(box: Bounds, point: Vector3): boolean;
        get min(): Vector3;
        set min(value: Vector3);
        get max(): Vector3;
        set max(value: Vector3);
        /**
         * 设置包围盒的最小点。
         * @param value	包围盒的最小点。
         */
        setMin(value: Vector3): void;
        /**
         * 获取包围盒的最小点。
         * @return	包围盒的最小点。
         */
        getMin(): Vector3;
        /**
         * 设置包围盒的最大点。
         * @param value	包围盒的最大点。
         */
        setMax(value: Vector3): void;
        /**
         * 获取包围盒的最大点。
         * @return	包围盒的最大点。
         */
        getMax(): Vector3;
        /**
         * 设置包围盒的中心点。
         * @param value	包围盒的中心点。
         */
        setCenter(value: Vector3): void;
        /**
         * 获取包围盒的中心点。
         * @return	包围盒的中心点。
         */
        getCenter(): Vector3;
        /**
         * 设置包围盒的范围。
         * @param value	包围盒的范围。
         */
        setExtent(value: Vector3): void;
        /**
         * 获取包围盒的范围。
         * @return	包围盒的范围。
         */
        getExtent(): Vector3;
        /**
         * 创建一个 <code>Bounds</code> 实例。
         * @param	min  min 最小坐标
         * @param	max  max 最大坐标。
         */
        constructor(min?: Vector3, max?: Vector3);
        protected _getUpdateFlag(type: number): boolean;
        protected _setUpdateFlag(type: number, value: boolean): void;
        protected _getCenter(min: Vector3, max: Vector3, out: Vector3): void;
        protected _getExtent(min: Vector3, max: Vector3, out: Vector3): void;
        protected _getMin(center: Vector3, extent: Vector3, out: Vector3): void;
        protected _getMax(center: Vector3, extent: Vector3, out: Vector3): void;
        protected _rotateExtents(extents: Vector3, rotation: Matrix4x4, out: Vector3): void;
        getCorners(corners: Vector3[]): void;
        /**
         * TODO
         * @param box
         */
        getBoundBox(box: BoundBox): void;
        /**
         * @returns -1为不相交 不为0的时候返回值为相交体积
         */
        calculateBoundsintersection(bounds: Bounds): number;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>BoundsImp</code> 类用于创建包围体。
     */
    class BoundsImpl implements IClone {
        protected _updateFlag: number;
        /***/
        _boundBox: BoundBox;
        get min(): Vector3;
        set min(value: Vector3);
        get max(): Vector3;
        set max(value: Vector3);
        /**
         * 设置包围盒的最小点。
         * @param value	包围盒的最小点。
         */
        setMin(value: Vector3): void;
        /**
         * 获取包围盒的最小点。
         * @return	包围盒的最小点。
         */
        getMin(): Vector3;
        /**
         * 设置包围盒的最大点。
         * @param value	包围盒的最大点。
         */
        setMax(value: Vector3): void;
        /**
         * 获取包围盒的最大点。
         * @return	包围盒的最大点。
         */
        getMax(): Vector3;
        /**
         * 设置包围盒的中心点。
         * @param value	包围盒的中心点。
         */
        setCenter(value: Vector3): void;
        /**
         * 获取包围盒的中心点。
         * @return	包围盒的中心点。
         */
        getCenter(): Vector3;
        /**
         * 设置包围盒的范围。
         * @param value	包围盒的范围。
         */
        setExtent(value: Vector3): void;
        /**
         * 获取包围盒的范围。
         * @return	包围盒的范围。
         */
        getExtent(): Vector3;
        /**
         * 创建一个 <code>BoundsImp</code> 实例。
         * @param	min  min 最小坐标
         * @param	max  max 最大坐标。
         */
        constructor(min?: Vector3, max?: Vector3);
        protected _getUpdateFlag(type: number): boolean;
        protected _setUpdateFlag(type: number, value: boolean): void;
        protected _getCenter(min: Vector3, max: Vector3, out: Vector3): void;
        protected _getExtent(min: Vector3, max: Vector3, out: Vector3): void;
        protected _getMin(center: Vector3, extent: Vector3, out: Vector3): void;
        protected _getMax(center: Vector3, extent: Vector3, out: Vector3): void;
        protected _rotateExtents(extents: Vector3, rotation: Matrix4x4, out: Vector3): void;
        /**
         * @returns -1为不相交 不为0的时候返回值为相交体积
         */
        calculateBoundsintersection(bounds: BoundsImpl): number;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>BoundSphere</code> 类用于创建包围球。
     */
    class BoundSphere implements IClone {
        private static _tempVector3;
        /**包围球的中心。*/
        _center: Vector3;
        /**包围球的半径。*/
        _radius: number;
        set center(value: Vector3);
        get center(): Vector3;
        set radius(value: number);
        get radius(): number;
        /**
         * 创建一个 <code>BoundSphere</code> 实例。
         * @param	center 包围球的中心。
         * @param	radius 包围球的半径。
         */
        constructor(center?: Vector3, radius?: number);
        toDefault(): void;
        /**
         * 从顶点的子队列生成包围球。
         * @param	points 顶点的队列。
         * @param	start 顶点子队列的起始偏移。
         * @param	count 顶点子队列的顶点数。
         * @param	result 生成的包围球。
         */
        static createFromSubPoints(points: Vector3[], start: number, count: number, out: BoundSphere): void;
        /**
         * 从顶点队列生成包围球。
         * @param	points 顶点的队列。
         * @param	result 生成的包围球。
         */
        static createfromPoints(points: Vector3[], out: BoundSphere): void;
        /**
         * 判断射线是否与碰撞球交叉，并返回交叉距离。
         * @param	ray 射线。
         * @return 距离交叉点的距离，-1表示不交叉。
         */
        intersectsRayDistance(ray: Ray): number;
        /**
         * 判断射线是否与碰撞球交叉，并返回交叉点。
         * @param	ray  射线。
         * @param	outPoint 交叉点。
         * @return  距离交叉点的距离，-1表示不交叉。
         */
        intersectsRayPoint(ray: Ray, outPoint: Vector3): number;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
         * <code>Collision</code> 类用于检测碰撞。
         */
    class CollisionUtils {
        /**
         * 创建一个 <code>Collision</code> 实例。
         */
        constructor();
        /**
         * 空间中点到平面的距离
         * @param	plane 平面
         * @param	point 点
         */
        static distancePlaneToPoint(plane: Plane, point: Vector3): number;
        /**
         * 空间中点到包围盒的距离
         * @param	box 包围盒
         * @param	point 点
         */
        static distanceBoxToPoint(box: BoundBox, point: Vector3): number;
        /**
         * 空间中包围盒到包围盒的距离
         * @param	box1 包围盒1
         * @param	box2 包围盒2
         */
        static distanceBoxToBox(box1: BoundBox, box2: BoundBox): number;
        /**
         * 空间中点到包围球的距离
         * @param	sphere 包围球
         * @param	point  点
         */
        static distanceSphereToPoint(sphere: BoundSphere, point: Vector3): number;
        /**
         * 空间中包围球到包围球的距离
         * @param	sphere1 包围球1
         * @param	sphere2 包围球2
         */
        static distanceSphereToSphere(sphere1: BoundSphere, sphere2: BoundSphere): number;
        /**
         * 空间中射线和三角面是否相交,输出距离
         * @param	ray 射线
         * @param	vertex1 三角面顶点1
         * @param	vertex2	三角面顶点2
         * @param	vertex3 三角面顶点3
         * @param	out 点和三角面的距离
         * @return  是否相交
         */
        static intersectsRayAndTriangleRD(ray: Ray, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3, out: number): boolean;
        /**
         * 空间中射线和三角面是否相交,输出相交点
         * @param	ray 射线
         * @param	vertex1 三角面顶点1
         * @param	vertex2	三角面顶点2
         * @param	vertex3 三角面顶点3
         * @param	out 相交点
         * @return  是否相交
         */
        static intersectsRayAndTriangleRP(ray: Ray, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3, out: Vector3): boolean;
        /**
         * 空间中射线和点是否相交
         * @param	sphere1 包围球1
         * @param	sphere2 包围球2
         */
        static intersectsRayAndPoint(ray: Ray, point: Vector3): boolean;
        /**
         * 空间中射线和射线是否相交
         * @param	ray1 射线1
         * @param	ray2 射线2
         * @param	out 相交点
         */
        static intersectsRayAndRay(ray1: Ray, ray2: Ray, out: Vector3): boolean;
        /**
         * 空间中平面和三角面是否相交
         * @param	plane 平面
         * @param	vertex1 三角面顶点1
         * @param	vertex2 三角面顶点2
         * @param	vertex3 三角面顶点3
         * @return  返回空间位置关系
         */
        static intersectsPlaneAndTriangle(plane: Plane, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3): number;
        /**
         * 射线和平面是否相交,并返回相交距离。
         * @param	ray   射线。
         * @param	plane 平面。
         * @return	相交距离,-1为不相交。
         */
        static intersectsRayAndPlaneRD(ray: Ray, plane: Plane): number;
        /**
         * 空间中射线和平面是否相交，并返回相交点。
         * @param	ray   射线。
         * @param	plane 平面。
         * @param	out 相交点。
         */
        static intersectsRayAndPlaneRP(ray: Ray, plane: Plane, out: Vector3): boolean;
        /**
         * 空间中射线和包围盒是否相交
         * @param	ray 射线
         * @param	box	包围盒
         * @param	out 相交距离,如果为0,不相交
         */
        static intersectsRayAndBoxRD(ray: Ray, box: BoundBox): number;
        /**
         * 空间中射线和包围盒是否相交
         * @param	ray 射线
         * @param	box	包围盒
         * @param	out 相交点
         */
        static intersectsRayAndBoxRP(ray: Ray, box: BoundBox, out: Vector3): number;
        /**
         * 空间中射线和包围球是否相交
         * @param	ray    射线
         * @param	sphere 包围球
         * @return	相交距离,-1表示不相交
         */
        static intersectsRayAndSphereRD(ray: Ray, sphere: BoundSphere): number;
        /**
         * 空间中射线和包围球是否相交
         * @param	ray    射线
         * @param	sphere 包围球
         * @param	out    相交点
         * @return  相交距离,-1表示不相交
         */
        static intersectsRayAndSphereRP(ray: Ray, sphere: BoundSphere, out: Vector3): number;
        /**
         * 空间中包围球和三角面是否相交
         * @param	sphere 包围球
         * @param	vertex1 三角面顶点1
         * @param	vertex2 三角面顶点2
         * @param	vertex3 三角面顶点3
         * @return  返回是否相交
         */
        static intersectsSphereAndTriangle(sphere: BoundSphere, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3): boolean;
        /**
         * 空间中点和平面是否相交
         * @param	plane  平面
         * @param	point  点
         * @return  碰撞状态
         */
        static intersectsPlaneAndPoint(plane: Plane, point: Vector3): number;
        /**
         * 空间中平面和平面是否相交
         * @param	plane1 平面1
         * @param	plane2 平面2
         * @return  是否相交
         */
        static intersectsPlaneAndPlane(plane1: Plane, plane2: Plane): boolean;
        /**
         * 空间中平面和平面是否相交
         * @param	plane1 平面1
         * @param	plane2 平面2
         * @param	line   相交线
         * @return  是否相交
         */
        static intersectsPlaneAndPlaneRL(plane1: Plane, plane2: Plane, line: Ray): boolean;
        /**
         * 空间中平面和包围盒是否相交
         * @param	plane 平面
         * @param   box  包围盒
         * @return  碰撞状态
         */
        static intersectsPlaneAndBox(plane: Plane, box: BoundBox): number;
        /**
         * 空间中平面和包围球是否相交
         * @param	plane 平面
         * @param   sphere 包围球
         * @return  碰撞状态
         */
        static intersectsPlaneAndSphere(plane: Plane, sphere: BoundSphere): number;
        /**
         * 空间中包围盒和包围盒是否相交
         * @param	box1 包围盒1
         * @param   box2 包围盒2
         * @return  是否相交
         */
        static intersectsBoxAndBox(box1: BoundBox, box2: BoundBox): boolean;
        /**
         * 空间中包围盒和包围球是否相交
         * @param	box 包围盒
         * @param   sphere 包围球
         * @return  是否相交
         */
        static intersectsBoxAndSphere(box: BoundBox, sphere: BoundSphere): boolean;
        /**
         * 空间中包围球和包围球是否相交
         * @param	sphere1 包围球1
         * @param   sphere2 包围球2
         * @return  是否相交
         */
        static intersectsSphereAndSphere(sphere1: BoundSphere, sphere2: BoundSphere): boolean;
        /**
         * 空间中包围盒是否包含另一个点
         * @param	box 包围盒
         * @param   point 点
         * @return  位置关系:0 不想交,1 包含, 2 相交
         */
        static boxContainsPoint(box: BoundBox, point: Vector3): number;
        /**
         * 空间中包围盒是否包含另一个包围盒
         * @param	box1 包围盒1
         * @param   box2 包围盒2
         * @return  位置关系:0 不想交,1 包含, 2 相交
         */
        static boxContainsBox(box1: BoundBox, box2: BoundBox): number;
        /**
         * 空间中包围盒是否包含另一个包围球
         * @param	box 包围盒
         * @param   sphere 包围球
         * @return  位置关系:0 不想交,1 包含, 2 相交
         */
        static boxContainsSphere(box: BoundBox, sphere: BoundSphere): number;
        /**
         * 空间中包围球是否包含另一个点
         * @param	sphere 包围球
         * @param   point 点
         * @return  位置关系:0 不想交,1 包含, 2 相交
         */
        static sphereContainsPoint(sphere: BoundSphere, point: Vector3): number;
        /**
         * 空间中包围球是否包含另一个三角面
         * @param	sphere
         * @param	vertex1 三角面顶点1
         * @param	vertex2 三角面顶点2
         * @param	vertex3 三角面顶点3
         * @return  返回空间位置关系
         */
        static sphereContainsTriangle(sphere: BoundSphere, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3): number;
        /**
         * 空间中包围球是否包含另一包围盒
         * @param	sphere 包围球
         * @param   box 包围盒
         * @return  位置关系:0 不想交,1 包含, 2 相交
         */
        static sphereContainsBox(sphere: BoundSphere, box: BoundBox): number;
        /**
         * 空间中包围球是否包含另一包围球
         * @param	sphere1 包围球
         * @param   sphere2 包围球
         * @return  位置关系:0 不想交,1 包含, 2 相交
         */
        static sphereContainsSphere(sphere1: BoundSphere, sphere2: BoundSphere): number;
        /**
         * 空间中点与三角面的最近点
         * @param	point 点
         * @param	vertex1 三角面顶点1
         * @param	vertex2	三角面顶点2
         * @param	vertex3 三角面顶点3
         * @param	out 最近点
         */
        static closestPointPointTriangle(point: Vector3, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3, out: Vector3): void;
        /**
         * 空间中平面与一点的最近点
         * @param	plane 平面
         * @param	point 点
         * @param	out 最近点
         */
        static closestPointPlanePoint(plane: Plane, point: Vector3, out: Vector3): void;
        /**
         * 空间中包围盒与一点的最近点
         * @param	box 包围盒
         * @param	point 点
         * @param	out 最近点
         */
        static closestPointBoxPoint(box: BoundBox, point: Vector3, out: Vector3): void;
        /**
         * 空间中包围球与一点的最近点
         * @param	sphere 包围球
         * @param	point 点
         * @param	out 最近点
         */
        static closestPointSpherePoint(sphere: BoundSphere, point: Vector3, out: Vector3): void;
        /**
         * 空间中包围球与包围球的最近点
         * @param	sphere1 包围球1
         * @param	sphere2 包围球2
         * @param	out 最近点
         */
        static closestPointSphereSphere(sphere1: BoundSphere, sphere2: BoundSphere, out: Vector3): void;
    }
    /**
     * <code>ContainmentType</code> 类用于定义空间物体位置关系。
     */
    class ContainmentType {
        /**不相交*/
        static Disjoint: number;
        /**包含*/
        static Contains: number;
        /**相交*/
        static Intersects: number;
    }
    /**
     * 裁剪接口
     */
    interface IBoundsCell {
        bounds: Bounds;
        id: number;
        shadowCullPass(): boolean;
    }
    /**
     * 平面。
     */
    class Plane {
        /**平面与其他几何体相交类型*/
        static PlaneIntersectionType_Back: number;
        static PlaneIntersectionType_Front: number;
        static PlaneIntersectionType_Intersecting: number;
        /** 平面的向量*/
        normal: Vector3;
        /** 平面到坐标系原点的距离*/
        distance: number;
        /**
         * 创建一个 <code>Plane</code> 实例。
         * @param	normal 平面的向量
         * @param	d  平面到原点的距离
         */
        constructor(normal?: Vector3, d?: number);
        /**
         * 通过三个点创建一个平面。
         * @param	point0 第零个点
         * @param	point1 第一个点
         * @param	point2 第二个点
         */
        static createPlaneBy3P(point0: Vector3, point1: Vector3, point2: Vector3, out: Plane): void;
        /**
         * 更改平面法线向量的系数，使之成单位长度。
         */
        normalize(): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): Plane;
    }
    /**
         * <code>Rand</code> 类用于通过32位无符号整型随机种子创建随机数。
         */
    class Rand {
        /**
         * 通过无符号32位整形，获取32位浮点随机数。
         * @param 无符号32位整形随机数。
         * @return 32位浮点随机数。
         */
        static getFloatFromInt(v: number): number;
        /**
         * 通过无符号32位整形，获取无符号8位字节随机数。
         * @param 无符号32位整形随机数。
         * @return 无符号8位字节随机数。
         */
        static getByteFromInt(v: number): number;
        /**获取随机种子。*/
        seeds: Uint32Array;
        /**
         * 获取随机种子。
         * @return 随机种子。
         */
        get seed(): number;
        /**
         * 设置随机种子。
         * @param	seed 随机种子。
         */
        set seed(seed: number);
        /**
         * 创建一个 <code>Rand</code> 实例。
         * @param	seed  32位无符号整型随机种子。
         */
        constructor(seed: number);
        /**
         * 获取无符号32位整形随机数。
         * @return 无符号32位整形随机数。
         */
        getUint(): number;
        /**
         * 获取0到1之间的浮点随机数。
         * @return 0到1之间的浮点随机数。
         */
        getFloat(): number;
        /**
         * 获取-1到1之间的浮点随机数。
         * @return -1到1之间的浮点随机数。
         */
        getSignedFloat(): number;
    }
    /**
         * <code>Rand</code> 类用于通过128位整型种子创建随机数,算法来自:https://github.com/AndreasMadsen/xorshift。
         */
    class RandX {
        /**基于时间种子的随机数。*/
        static defaultRand: RandX;
        /**
         * 创建一个 <code>Rand</code> 实例。
         * @param	seed  随机种子。
         */
        constructor(seed: any[]);
        /**
         * 通过2x32位的数组，返回64位的随机数。
         * @return 64位的随机数。
         */
        randomint(): any[];
        /**
         * 返回[0,1)之间的随机数。
         * @return
         */
        random(): number;
    }
    /**
         * <code>Ray</code> 类用于创建射线。
         */
    class Ray {
        /**原点*/
        origin: Vector3;
        /**方向*/
        direction: Vector3;
        /**
         * 创建一个 <code>Ray</code> 实例。
         * @param	origin 射线的起点
         * @param	direction  射线的方向
         */
        constructor(origin: Vector3, direction: Vector3);
        /**
         * 射线上的某点
         * @param t
         * @param out
         */
        at(t: number, out: Vector3): void;
    }
    /**
     * <code>Viewport</code> 类用于创建视口。
     */
    class Viewport {
        static _tempViewport: Viewport;
        /**X轴坐标*/
        x: number;
        /**Y轴坐标*/
        y: number;
        /**宽度*/
        width: number;
        /**高度*/
        height: number;
        /**最小深度*/
        minDepth: number;
        /**最大深度*/
        maxDepth: number;
        /**
         * 创建一个 <code>Viewport</code> 实例。
         * @param	x x坐标。
         * @param	y y坐标。
         * @param	width 宽度。
         * @param	height 高度。
         */
        constructor(x?: number, y?: number, width?: number, height?: number);
        /**
         * 投影一个三维向量到视口空间。
         * @param	source 三维向量。
         * @param	matrix 变换矩阵。
         * @param	out x、y、z为视口空间坐标,透视投影下w为相对于变换矩阵的z轴坐标。
         */
        project(source: Vector3, matrix: Matrix4x4, out: Vector4): void;
        /**
         * 反变换一个三维向量。
         * @param	source 源三维向量。
         * @param	matrix 变换矩阵。
         * @param	out 输出三维向量。
         */
        unprojectFromMat(source: Vector3, matrix: Matrix4x4, out: Vector3): void;
        /**
         * 反变换一个三维向量。
         * @param	source 源三维向量。
         * @param	projection  透视投影矩阵。
         * @param	view 视图矩阵。
         * @param	world 世界矩阵,可设置为null。
         * @param   out 输出向量。
         */
        unprojectFromWVP(source: Vector3, projection: Matrix4x4, view: Matrix4x4, world: Matrix4x4, out: Vector3): void;
        set(x: number, y: number, width: number, height: number): void;
        /**
         * 克隆
         * @param	out
         */
        cloneTo(out: Viewport): void;
    }
    /**
     * <code>CharacterController</code> 类用于创建角色控制器。
     */
    class CharacterController extends PhysicsColliderComponent {
        onUpdate(): void;
        /**
         * 胶囊半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * 高度。
         */
        get height(): number;
        set height(value: number);
        /**
         *
         */
        get minDistance(): number;
        set minDistance(value: number);
        /**
         * 碰撞偏移
         */
        get centerOffset(): Vector3;
        set centerOffset(value: Vector3);
        /**
         * 重力。
         */
        get gravity(): Vector3;
        set gravity(value: Vector3);
        /**
        * 碰撞偏移。
        */
        get skinWidth(): number;
        set skinWidth(value: number);
        /**
         * 最大坡度。
         */
        get maxSlope(): number;
        set maxSlope(value: number);
        /**
         * 角色行走的脚步高度，表示可跨越的最大高度。
         */
        get stepHeight(): number;
        set stepHeight(value: number);
        /**
         * 角色的Up轴。
         */
        get upAxis(): Vector3;
        set upAxis(value: Vector3);
        /**
         * 角色位置
         */
        get position(): Vector3;
        set position(v: Vector3);
        /**
         * 推动力大小
         */
        get pushForce(): number;
        set pushForce(value: number);
        /**
         * 起跳速度
         */
        get jumpSpeed(): number;
        set jumpSpeed(value: number);
        /**
         * 创建一个 <code>CharacterController</code> 实例。
         * @param stepheight 角色脚步高度。
         * @param upAxis 角色Up轴
         * @param collisionGroup 所属碰撞组。
         * @param canCollideWith 可产生碰撞的碰撞组。
         */
        constructor();
        /**
         * 获得速度
         * @returns
         */
        getVerticalVel(): number;
        /**
         * 通过指定移动向量移动角色。
         * @param	movement 移动向量。
         */
        move(movement: Vector3): void;
        /**
         * 跳跃。
         * @param velocity 跳跃速度。
         */
        jump(velocity?: Vector3): void;
    }
    /**
     * <code>Collision</code> 类用于创建物理碰撞信息。
     */
    class Collision {
        /**@readonly*/
        contacts: ContactPoint[];
        /**@readonly*/
        other: PhysicsColliderComponent;
        /**
         * 创建一个 <code>Collision</code> 实例。
         */
        constructor();
    }
    /**
     * <code>ConfigurableConstraint</code>类用于可设置的约束组件
     */
    class ConfigurableConstraint extends ConstraintComponent {
        /**
         * 创建一个<code>ConfigurableConstraint</code>实例	可设置的约束组件
         */
        constructor();
        private _setDriveLinearX;
        private _setDriveLinearY;
        private _setDriveLinearZ;
        private _setAngularXDrive;
        private _setAngularYZDrive;
        private _setAngularSlerpDrive;
        private _setDistanceLimit;
        private _setAngularXLimit;
        private _setSwingLimit;
        private _setTargetTransform;
        /**
         * axis
         */
        private _setAxis;
        private _setTargetVelocirty;
        /**
         * main Axis
         */
        set axis(value: Vector3);
        get axis(): Vector3;
        set secondaryAxis(value: Vector3);
        /**
         * 副轴
         */
        get secondaryAxis(): Vector3;
        /**
         * X Motion
         */
        set XMotion(value: D6Axis);
        get XMotion(): D6Axis;
        /**
         * Y Motion
         */
        set YMotion(value: D6Axis);
        get YMotion(): D6Axis;
        /**
         * Z Motion
         */
        set ZMotion(value: D6Axis);
        get ZMotion(): D6Axis;
        /**
         * X 角度motion
         */
        set angularXMotion(value: D6Axis);
        get angularXMotion(): D6Axis;
        /**
         * Y 角度motion
         */
        set angularYMotion(value: D6Axis);
        get angularYMotion(): D6Axis;
        /**
         * Z 角度motion
         */
        set angularZMotion(value: D6Axis);
        get angularZMotion(): D6Axis;
        set distanceLimit(value: number);
        get distanceLimit(): number;
        set distanceBounciness(value: number);
        get distanceBounciness(): number;
        set distanceBounceThreshold(value: number);
        get distanceBounceThreshold(): number;
        set distanceSpring(value: number);
        get distanceSpring(): number;
        set distanceDamper(value: number);
        get distanceDamper(): number;
        /**-180 ---- 180 */
        set angularXMaxLimit(value: number);
        get angularXMaxLimit(): number;
        set angularXMinLimit(value: number);
        get angularXMinLimit(): number;
        set AngleXLimitBounceness(value: number);
        get AngleXLimitBounceness(): number;
        set AngleXLimitBounceThreshold(value: number);
        get AngleXLimitBounceThreshold(): number;
        set AngleXLimitSpring(value: number);
        get AngleXLimitSpring(): number;
        set AngleXLimitDamp(value: number);
        get AngleXLimitDamp(): number;
        set AngleYLimit(value: number);
        get AngleYLimit(): number;
        set AngleZLimit(value: number);
        get AngleZLimit(): number;
        set AngleYZLimitBounciness(value: number);
        get AngleYZLimitBounciness(): number;
        set AngleYZLimitBounceThreshold(value: number);
        get AngleYZLimitBounceThreshold(): number;
        set AngleYZLimitSpring(value: number);
        get AngleYZLimitSpring(): number;
        set AngleYZLimitDamping(value: number);
        get AngleYZLimitDamping(): number;
        set targetPosition(value: Vector3);
        get targetPosition(): Vector3;
        set targetRotation(value: Vector3);
        get targetRotation(): Vector3;
        set targetPositionVelocity(value: Vector3);
        get targetPositionVelocity(): Vector3;
        set targetAngularVelocity(value: Vector3);
        get targetAngularVelocity(): Vector3;
        set XDriveSpring(value: number);
        get XDriveSpring(): number;
        set YDriveSpring(value: number);
        get YDriveSpring(): number;
        set ZDriveSpring(value: number);
        get ZDriveSpring(): number;
        set XDriveDamp(value: number);
        get XDriveDamp(): number;
        set YDriveDamp(value: number);
        get YDriveDamp(): number;
        set ZDriveDamp(value: number);
        get ZDriveDamp(): number;
        set XDriveForceLimit(value: number);
        get XDriveForceLimit(): number;
        set YDriveForceLimit(value: number);
        get YDriveForceLimit(): number;
        set ZDriveForceLimit(value: number);
        get ZDriveForceLimit(): number;
        get angularXDriveForceLimit(): number;
        set angularXDriveForceLimit(value: number);
        get angularXDriveForce(): number;
        set angularXDriveForce(value: number);
        get angularXDriveDamp(): number;
        set angularXDriveDamp(value: number);
        get angularYZDriveForceLimit(): number;
        set angularYZDriveForceLimit(value: number);
        get angularYZDriveForce(): number;
        set angularYZDriveForce(value: number);
        get angularYZDriveDamp(): number;
        set angularYZDriveDamp(value: number);
        get angularSlerpDriveForceLimit(): number;
        set angularSlerpDriveForceLimit(value: number);
        get angularSlerpDriveForce(): number;
        set angularSlerpDriveForce(value: number);
        get angularSlerpDriveDamp(): number;
        set angularSlerpDriveDamp(value: number);
        _initAllConstraintInfo(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        /**
        * create joint
        */
        protected _initJoint(): void;
    }
    /**
     * <code>ConstraintComponent</code> 类用于创建约束的父类。
     */
    class ConstraintComponent extends Component {
        protected _physicsManager: IPhysicsManager;
        protected _connectCollider: PhysicsColliderComponent;
        protected _breakForce: number;
        protected _breakTorque: number;
        protected _ownColliderLocalPos: Vector3;
        protected _connectColliderLocalPos: Vector3;
        /**
         * instance joint
         */
        initJoint(): void;
        protected _initJoint(): void;
        set connectedBody(value: PhysicsColliderComponent);
        get connectedBody(): PhysicsColliderComponent;
        get ownBody(): PhysicsColliderComponent;
        set ownBody(value: PhysicsColliderComponent);
        /**
         * 获得收到的总力
         */
        get currentForce(): Vector3;
        /**
         * 获取的总力矩
         */
        get currentTorque(): Vector3;
        /**
         * 设置最大承受力
         * @param value 最大承受力
         */
        get breakForce(): number;
        set breakForce(value: number);
        /**
         * 设置最大承受力矩
         * @param value 最大承受力矩
         */
        get breakTorque(): number;
        set breakTorque(value: number);
        /**
         * 设置锚点
         */
        set anchor(value: Vector3);
        get anchor(): Vector3;
        /**
         * 设置链接锚点位置
         */
        set connectAnchor(value: Vector3);
        get connectAnchor(): Vector3;
        /**
         * 是否碰撞关节之间的内容
         */
        get enableCollison(): boolean;
        set enableCollison(value: boolean);
        /**
         * 创建一个 <code>ConstraintComponent</code> 实例。
         */
        constructor();
        protected _onAdded(): void;
        /**
         * 设置迭代的次数，次数越高，越精确
         * @param overideNumIterations
         */
        setOverrideNumSolverIterations(overideNumIterations: number): void;
        /**
         * 设置约束是否可用
         * @param enable
         */
        setConstraintEnabled(enable: boolean): void;
        protected _onDestroy(): void;
    }
    class FixedConstraint extends ConstraintComponent {
        /**
         * 创建一个<code>FixedConstraint</code>实例
         */
        constructor();
        protected _onEnable(): void;
        protected _onDisable(): void;
    }
    class HingeConstraint extends ConstraintComponent {
        /**
        * 创建一个<code>HingeConstraint</code>铰链实例
        */
        constructor();
        /**
         * create joint
         */
        protected _initJoint(): void;
        /**
         * overrid it
         */
        protected _onEnable(): void;
        /**
         * overrid it
         */
        protected _onDisable(): void;
        /**
        * set Hinge Rotation Axis,value by local rigibody0
        */
        set Axis(value: Vector3);
        get Axis(): Vector3;
        /**
         * set limitLower
         * @param lowerLimit
         */
        set lowerLimit(value: number);
        get lowerLimit(): number;
        /**
         * set uperLimit
         * @param lowerLimit
         */
        set uperLimit(value: number);
        get uperLimit(): number;
        /**
         * @param value
         */
        set bounceness(value: number);
        get bounceness(): number;
        /**
         * @param value
         */
        set bouncenMinVelocity(value: number);
        get bouncenMinVelocity(): number;
        /**
         * @param value
         */
        set contactDistance(value: number);
        get contactDistance(): number;
        /**
         * @param value
         */
        set limit(value: boolean);
        get limit(): boolean;
        /**
         * @param value
         */
        set motor(value: boolean);
        get motor(): boolean;
        /**
         * @param value
         */
        set freeSpin(value: boolean);
        get freeSpin(): boolean;
        /**
         * set the target velocity for the drive model.
         * @param velocity the drive target velocity
         */
        set targetVelocity(velocity: number);
        get targetVelocity(): number;
        /**
         * The current angle in degrees of the joint relative to its rest position.
         */
        getAngle(): number;
        /**
         * The angular velocity of the joint in degrees per second.
         */
        getVelocity(): Vector3;
    }
    class SpringConstraint extends ConstraintComponent {
        protected _onAdded(): void;
        /**
         * set spring min Distance
         */
        set minDistance(value: number);
        get minDistance(): number;
        /**
         * set spring max Distance
         */
        set maxDistance(value: number);
        get maxDistance(): number;
        /**
         * set sprint default length
         * Set the error tolerance of the joint.
         */
        set tolerance(value: number);
        get tolerance(): number;
        /**
         * set spring stifness
         */
        set spring(value: number);
        get spring(): number;
        /**
         * set damping in spring
         */
        set damping(value: number);
        get damping(): number;
    }
    /**
     * <code>ContactPoint</code> 类用于创建物理碰撞信息。
     */
    class ContactPoint {
        /**碰撞器A。*/
        _colliderA: ICollider;
        /**碰撞器B。*/
        _colliderB: ICollider;
        /**距离。*/
        distance: number;
        /**法线。*/
        normal: Vector3;
        /**碰撞器A的碰撞点。*/
        positionOnA: Vector3;
        /**碰撞器B的碰撞点。*/
        positionOnB: Vector3;
        /**
         * 创建一个 <code>ContactPoint</code> 实例。
         */
        constructor();
    }
    /**
     * <code>HitResult</code> 类用于实现射线检测或形状扫描的结果。
     */
    class HitResult {
        /** 是否成功。 */
        succeeded: boolean;
        /** 发生碰撞的碰撞组件。*/
        collider: ICollider;
        /** 碰撞点。*/
        point: Vector3;
        /** 碰撞法线。*/
        normal: Vector3;
        /** 碰撞分数。 */
        hitFraction: number;
        /**
         * 创建一个 <code>HitResult</code> 实例。
         */
        constructor();
    }
    /**
     * <code>PhysicsCollider</code> 类用于创建物理碰撞器。
     */
    class PhysicsCollider extends PhysicsColliderComponent {
        /**
         * @override
         * @interanl
         */
        _collider: IStaticCollider;
        /**
         * @override
         * @interanl
         */
        protected _initCollider(): void;
        constructor();
        /**
         * 是否为触发器。
         */
        get isTrigger(): boolean;
        set isTrigger(value: boolean);
    }
    /**
     * Describes how physics materials of the colliding objects are combined.
     */
    enum PhysicsCombineMode {
        /** Averages the friction/bounce of the two colliding materials. */
        Average = 0,
        /** Uses the smaller friction/bounce of the two colliding materials. */
        Minimum = 1,
        /** Multiplies the friction/bounce of the two colliding materials. */
        Multiply = 2,
        /** Uses the larger friction/bounce of the two colliding materials. */
        Maximum = 3
    }
    enum PhysicsForceMode {
        Force = 0,
        Impulse = 1
    }
    /**
     * <code>PhysicsColliderComponent</code> 类用于创建物理组件的父类。
     */
    class PhysicsColliderComponent extends Component {
        get collider(): ICollider;
        /**
         * 弹力。也叫Bounciness
         */
        get restitution(): number;
        set restitution(value: number);
        /**
         * 摩擦力。
         */
        get friction(): number;
        set friction(value: number);
        /**
         * 滚动摩擦力。
         */
        get rollingFriction(): number;
        set rollingFriction(value: number);
        /**
         * 动态摩擦力
         */
        get dynamicFriction(): number;
        set dynamicFriction(value: number);
        /**
         * 静态摩擦力
         */
        get staticFriction(): number;
        set staticFriction(value: number);
        /**
         * 摩擦力模式
         */
        set frictionCombine(value: PhysicsCombineMode);
        get frictionCombine(): PhysicsCombineMode;
        /**
         * 弹力模式
         */
        set restitutionCombine(value: PhysicsCombineMode);
        get restitutionCombine(): PhysicsCombineMode;
        /**
         * 碰撞形状。
         */
        get colliderShape(): Physics3DColliderShape;
        set colliderShape(value: Physics3DColliderShape);
        /**
         * 所属碰撞组。
         */
        get collisionGroup(): number;
        set collisionGroup(value: number);
        /**
         * 可碰撞的碰撞组,基于位运算。
         */
        get canCollideWith(): number;
        set canCollideWith(value: number);
        constructor();
        initCollider(): void;
        protected _initCollider(): void;
        protected _onAdded(): void;
        protected _onEnable(): void;
        protected _onDisable(): void;
        protected _onDestroy(): void;
    }
    /**
     * <code>PhysicsSettings</code> 类用于创建物理配置信息。
     */
    class PhysicsSettings {
        /**标志集合。*/
        flags: number;
        /**物理引擎在一帧中用于补偿减速的最大次数。*/
        maxSubSteps: number;
        /**物理模拟器帧的间隔时间。*/
        fixedTimeStep: number;
        /**是否开启连续碰撞检测 */
        enableCCD: boolean;
        /**连续碰撞检测阈值 */
        ccdThreshold: number;
        /**连续碰撞检测球半径 */
        ccdSphereRadius: number;
    }
    /**
     * <code>PhysicsUpdateList</code> 类用于实现物理更新队列。
     */
    class PhysicsUpdateList extends SingletonList<ICollider> {
        /**
         * 创建一个新的 <code>PhysicsUpdateList</code> 实例。
         */
        constructor();
    }
    /**
     * <code>Rigidbody3D</code> 类用于创建刚体碰撞器。
     */
    class Rigidbody3D extends PhysicsColliderComponent {
        /**
         * 质量。
         */
        get mass(): number;
        set mass(value: number);
        /**
         * 是否为运动物体，如果为true仅可通过transform属性移动物体,而非其他力相关属性。
         */
        get isKinematic(): boolean;
        set isKinematic(value: boolean);
        /**
         * 刚体的线阻力。
         */
        get linearDamping(): number;
        set linearDamping(value: number);
        /**
         * 刚体的角阻力。
         */
        get angularDamping(): number;
        set angularDamping(value: number);
        /**
         * 重力。
         */
        get gravity(): Vector3;
        set gravity(value: Vector3);
        /**
         * 每个轴的线性运动缩放因子,如果某一轴的值为0表示冻结在该轴的线性运动。
         */
        get linearFactor(): Vector3;
        set linearFactor(value: Vector3);
        /**
         * 线速度
         */
        get linearVelocity(): Vector3;
        set linearVelocity(value: Vector3);
        /**
         * 每个轴的角度运动缩放因子,如果某一轴的值为0表示冻结在该轴的角度运动。
         */
        get angularFactor(): Vector3;
        set angularFactor(value: Vector3);
        /**
         * 角速度。
         */
        get angularVelocity(): Vector3;
        set angularVelocity(value: Vector3);
        /**
         * 刚体睡眠的线速度阈值。
         */
        get sleepThreshold(): number;
        set sleepThreshold(value: number);
        /**
         * 直接设置物理位置
         */
        set position(pos: Vector3);
        set orientation(q: Quaternion);
        /**
         * 是否触发器
         */
        get trigger(): boolean;
        set trigger(value: boolean);
        /**
         * 碰撞检测模式
         */
        get collisionDetectionMode(): number;
        set collisionDetectionMode(value: number);
        constructor();
        protected _onAdded(): void;
        protected _onDestroy(): void;
        /**
         * 应用作用力。
         * @param	force 作用力。
         * @param	localOffset 偏移,如果为null则为中心点
         */
        applyForce(force: Vector3, localOffset?: Vector3): void;
        /**
         * 应用扭转力。
         * @param	torque 扭转力。
         */
        applyTorque(torque: Vector3): void;
        /**
         * 应用冲量。
         * @param	impulse 冲量。
         * @param   localOffset 偏移,如果为null则为中心点。
         */
        applyImpulse(impulse: Vector3, localOffset?: Vector3): void;
        /**
         * 应用扭转冲量。
         * @param	torqueImpulse
         */
        applyTorqueImpulse(torqueImpulse: Vector3): void;
        /**
         * 唤醒刚体。
         */
        wakeUp(): void;
        /**
         * @deprecated
         * 刚体睡眠的线速度阈值。
         */
        get sleepLinearVelocity(): number;
        set sleepLinearVelocity(value: number);
        /**
         * @deprecated
         * 刚体睡眠的角速度阈值。
         */
        get sleepAngularVelocity(): number;
        set sleepAngularVelocity(value: number);
        /**
         * @deprecated
         * 应用作用力
         * @param fx
         * @param fy
         * @param fz
         * @param localOffset
         */
        applyForceXYZ(fx: number, fy: number, fz: number, localOffset?: Vector3): void;
    }
    /**
     * <code>BoxColliderShape</code> 类用于创建盒子形状碰撞器。
     */
    class BoxColliderShape extends Physics3DColliderShape {
        /**
         * 创建一个新的 <code>BoxColliderShape</code> 实例。
         * @param sizeX 盒子X轴尺寸。
         * @param sizeY 盒子Y轴尺寸。
         * @param sizeZ 盒子Z轴尺寸。
         */
        constructor(sizeX?: number, sizeY?: number, sizeZ?: number);
        protected _createShape(): void;
        /**
         * Box size
         */
        get size(): Vector3;
        set size(value: Vector3);
        /**
         * @inheritDoc
         * @override
         */
        clone(): any;
        cloneTo(destObject: any): void;
        /**
         * @description
         * X轴尺寸。
         */
        get sizeX(): number;
        set sizeX(value: number);
        /**
         * @description
         * Y轴尺寸。
         */
        get sizeY(): number;
        set sizeY(value: number);
        /**
         * @description
         * Z轴尺寸。
         */
        get sizeZ(): number;
        set sizeZ(value: number);
    }
    /**
     * <code>CapsuleColliderShape</code> 类用于创建胶囊形状碰撞器。
     */
    class CapsuleColliderShape extends Physics3DColliderShape {
        _shape: ICapsuleColliderShape;
        /**
         * 半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * 长度。
         */
        get length(): number;
        set length(value: number);
        /**
         * 方向。
         */
        get orientation(): number;
        set orientation(value: number);
        /**
         * 创建一个新的 <code>CapsuleColliderShape</code> 实例。
         * @param 半径。
         * @param 高(包含半径)。
         * @param orientation 胶囊体方向。
         */
        constructor(radius?: number, length?: number, orientation?: number);
        /**
         * @override
         */
        protected _createShape(): void;
        /**
         * @inheritDoc
         * @override
         */
        clone(): any;
        /**
         * @inheritDoc
         * @override
         */
        cloneTo(destObject: CapsuleColliderShape): void;
    }
    /**
     * <code>CompoundColliderShape</code> 类用于创建组合碰撞器。
     */
    class CompoundColliderShape extends Physics3DColliderShape {
        /**
         * 创建一个新的 <code>CompoundColliderShape</code> 实例。
         */
        constructor();
        /**
         * 设置物理shape数组
         * IDE
         */
        set shapes(value: any[]);
        get shapes(): any[];
        /**
         * 添加子碰撞器形状。
         * @param	shape 子碰撞器形状。
         */
        addChildShape(shape: any): void;
        /**
         * 移除子碰撞器形状。
         * @param	shape 子碰撞器形状。
         */
        removeChildShape(shape: any): void;
        /**
         * 清空子碰撞器形状。
         */
        clearChildShape(): void;
        /**
         * 获取子形状数量。
         * @return
         */
        getChildShapeCount(): number;
        /**
         * @inheritDoc
         * @override
         */
        cloneTo(destObject: any): void;
        /**
         * @inheritDoc
         * @override
         */
        clone(): any;
        /**
         * @inheritDoc
         * @override
         */
        destroy(): void;
    }
    /**
     * <code>ConeColliderShape</code> 类用于创建圆锥碰撞器。
     */
    class ConeColliderShape extends Physics3DColliderShape {
        /**
         * 半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * 高度。
         */
        get height(): number;
        set height(value: number);
        /**
         * 方向。
         */
        get orientation(): number;
        set orientation(value: number);
        /**
         * 创建一个新的 <code>ConeColliderShape</code> 实例。
         * @param height 高。
         * @param radius 半径。
         */
        constructor(radius?: number, height?: number, orientation?: number);
        /**
         * 克隆
         * @inheritDoc
         * @override
         * @returns 克隆的ConeColliderShape实例
         */
        clone(): any;
        /**
         * 克隆
         * @inheritDoc
         * @override
         * @returns 克隆的ConeColliderShape实例
         */
        cloneTo(destObject: ConeColliderShape): void;
    }
    /**
     * <code>CylinderColliderShape</code> 类用于创建圆柱碰撞器。
     */
    class CylinderColliderShape extends Physics3DColliderShape {
        /**
         * 半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * 高度。
         */
        get height(): number;
        set height(value: number);
        /**
         * 方向。
         */
        get orientation(): number;
        set orientation(value: number);
        /**
         * 创建一个新的 <code>CylinderColliderShape</code> 实例。
         * @param height 高。
         * @param radius 半径。
         */
        constructor(radius?: number, height?: number, orientation?: number);
        /**
         * @inheritDoc
         * @override
         */
        clone(): any;
        /**
         * 克隆
         * @inheritDoc
         * @override
         * @returns 克隆的ConeColliderShape实例
         */
        cloneTo(destObject: CylinderColliderShape): void;
    }
    /**
     * 高度场数据
     */
    interface heightFieldData {
        /** 排*/
        numRows: number;
        /** 列*/
        numCols: number;
        /** 高度数据*/
        heightData: Float32Array;
        /** 镶嵌标志 0和1 分别表示地形三角形朝向左还是朝右*/
        flag: Uint8Array;
        /** 高度Scale*/
        scale: Vector3;
    }
    /**
     * 此类描述高度场物理碰撞
     */
    class HeightFieldColliderShape extends Physics3DColliderShape {
        /**
         * 实例化一个高度场碰撞体
         * @param heightFieldData
         */
        constructor(heightFieldData: heightFieldData);
    }
    /**
     * <code>MeshColliderShape</code> 类用于创建网格碰撞器。
     */
    class MeshColliderShape extends Physics3DColliderShape {
        _shape: IMeshColliderShape;
        /**
         * 网格。
         */
        get mesh(): Mesh;
        set mesh(value: Mesh);
        private _changeShape;
        /**
         * 是否使用凸多边形。
         */
        get convexVertexMax(): number;
        set convexVertexMax(value: number);
        /**
         * 是否使用凸多边形。
         */
        get convex(): boolean;
        set convex(value: boolean);
        /**
         * 创建一个新的 <code>MeshColliderShape</code> 实例。
         */
        constructor();
        /**
         * @override
         */
        protected _createShape(): void;
        /**
         * @inheritDoc
         * @override
         */
        cloneTo(destObject: any): void;
        /**
         * @inheritDoc
         * @override
         */
        clone(): any;
    }
    /**
     * <code>ColliderShape</code> 类用于创建形状碰撞器的父类，该类为抽象类。
     */
    class Physics3DColliderShape implements IClone {
        /** 形状方向_X轴正向 */
        static SHAPEORIENTATION_UPX: number;
        /** 形状方向_Y轴正向 */
        static SHAPEORIENTATION_UPY: number;
        /** 形状方向_Z轴正向 */
        static SHAPEORIENTATION_UPZ: number;
        _shape: IColliderShape;
        /**
         * Shape的本地偏移。
         */
        get localOffset(): Vector3;
        set localOffset(value: Vector3);
        /**
         * 创建一个新的 <code>ColliderShape</code> 实例。
         */
        constructor();
        protected _createShape(): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return 克隆副本。
         */
        clone(): any;
        /**
         * 销毁。
         */
        destroy(): void;
    }
    /**
     * <code>SphereColliderShape</code> 类用于创建球形碰撞器。
     */
    class SphereColliderShape extends Physics3DColliderShape {
        /**
         * 半径。
         */
        get radius(): number;
        set radius(value: number);
        /**
         * 创建一个新的 <code>SphereColliderShape</code> 实例。
         * @param radius 半径。
         */
        constructor(radius?: number);
        /**
         * @inheritDoc
         * @override
         */
        clone(): any;
    }
    interface IRenderEngine3DOBJFactory {
        createTransform(owner: Sprite3D): Transform3D;
        createBounds(min: Vector3, max: Vector3): any;
        createRenderElement(): IRenderElement;
        createSkinRenderElement(): IRenderElement;
        createInstanceRenderElement(): IRenderElement;
        createBaseRenderQueue(isTransparent: boolean): IRenderQueue;
        createVertexBuffer3D(byteLength: number, bufferUsage: BufferUsage, canRead: boolean): VertexBuffer3D;
        createIndexBuffer3D(indexType: IndexFormat, indexCount: number, bufferUsage: BufferUsage, canRead: boolean): IndexBuffer3D;
        createSceneRenderManager(): ISceneRenderManager;
        createCullPass(): ICullPass;
        createSortPass(): ISortPass;
        createShadowCullInfo(): IShadowCullInfo;
        createCameraCullInfo(): ICameraCullInfo;
        createRenderGeometry(mode: MeshTopology, drayType: DrawType): IRenderGeometryElement;
        createBaseRenderNode(): IBaseRenderNode;
        createRenderContext3D(): IRenderContext3D;
    }
    class Laya3DRender {
        static renderOBJCreate: IRenderEngine3DOBJFactory;
    }
    class BaseRenderNode implements IBaseRenderNode {
        /**@interanl */
        boundsChange: boolean;
    }
    class BaseRenderQueue implements IRenderQueue {
        /** @interanl */
        _isTransparent: boolean;
        /**sort function*/
        _sortPass: ISortPass;
        /** context*/
        _context: IRenderContext3D;
        _batch: RenderElementBatch;
        set sortPass(value: ISortPass);
        constructor(isTransparent: boolean);
        set context(value: RenderContext3D);
        addRenderElement(renderelement: RenderElement): void;
        clear(): void;
        renderQueue(context: RenderContext3D): number;
        private _batchQueue;
        private _sort;
        destroy(): void;
    }
    /**
     * camera裁剪数据
     */
    class CameraCullInfo implements ICameraCullInfo {
        /**位置 */
        position: Vector3;
        /**是否遮挡剔除 */
        useOcclusionCulling: Boolean;
        /**锥体包围盒 */
        boundFrustum: BoundFrustum;
        /**遮挡标记 */
        cullingMask: number;
        /**静态标记 */
        staticMask: number;
    }
    class CullPassBase implements ICullPass {
        protected _cullList: FastSinglelist<BaseRender>;
        get cullList(): FastSinglelist<BaseRender>;
        /**
         * TODO
         * 视距与包围提裁剪
         * @param context
         * @param render
         * @returns
         */
        static cullDistanceVolume(context: RenderContext3D, render: BaseRender): boolean;
        cullByCameraCullInfo(cameraCullInfo: ICameraCullInfo, renderManager: ISceneRenderManager): void;
        cullByShadowCullInfo(cullInfo: IShadowCullInfo, renderManager: ISceneRenderManager): void;
        cullingSpotShadow(cameraCullInfo: ICameraCullInfo, renderManager: ISceneRenderManager): void;
    }
    class InstanceRenderElementOBJ extends RenderElementOBJ {
        private _updateData;
        private _updateDataNum;
        drawCount: number;
        updateNums: number;
        /**
         * 增加UpdateBuffer
         * @param vb
         * @param length 每个instance属性的数据长度
         */
        addUpdateBuffer(vb: VertexBuffer3D, length: number): void;
        /**
         *
         * @param index index of Buffer3D
         * @param length length of array
         */
        getUpdateData(index: number, length: number): Float32Array;
        constructor();
        /**
         * draw geometry
         * @param shaderIns
         */
        drawGeometry(shaderIns: ShaderInstance): void;
        clear(): void;
    }
    class QuickSort implements ISortPass {
        private elementArray;
        private isTransparent;
        /**
         * 快速排序
         * @param elements
         * @param isTransparent
         * @param left
         * @param right
         */
        sort(elements: SingletonList<RenderElement>, isTransparent: boolean, left: number, right: number): void;
    }
    class RenderContext3DOBJ implements IRenderContext3D {
        destTarget: IRenderTarget;
        viewPort: Viewport;
        scissor: Vector4;
        invertY: boolean;
        pipelineMode: PipelineMode;
        configShaderData: ShaderData;
        cameraShaderData: ShaderData;
        sceneID: number;
        sceneShaderData: ShaderData;
        cameraUpdateMark: number;
        globalShaderData: ShaderData;
        constructor();
        end(): void;
        /**设置IRenderContext */
        applyContext(cameraUpdateMark: number): void;
        drawRenderElement(renderelemt: RenderElementOBJ): void;
    }
    class RenderElementOBJ implements IRenderElement {
        _geometry: IRenderGeometryElement;
        _shaderInstances: SingletonList<ShaderInstance>;
        _materialShaderData: ShaderData;
        _renderShaderData: ShaderData;
        _transform: Transform3D;
        _isRender: boolean;
        _owner: IBaseRenderNode;
        _invertFront: boolean;
        constructor();
        _addShaderInstance(shader: ShaderInstance): void;
        _clearShaderInstance(): void;
        /**
         * render RenderElement
         * @param renderqueue
         */
        _render(context: IRenderContext3D): void;
        drawGeometry(shaderIns: ShaderInstance): void;
        _destroy(): void;
    }
    class RenderGeometryElementOBJ implements IRenderGeometryElement {
        /**
         * index format
         */
        get indexFormat(): IndexFormat;
        set indexFormat(value: IndexFormat);
        /**
         * Mesh Topology mode
         */
        get mode(): MeshTopology;
        set mode(value: MeshTopology);
    }
    class SceneRenderManagerOBJ implements ISceneRenderManager {
        _motionRenders: SingletonList<BaseRender>;
        constructor();
        get list(): SingletonList<BaseRender>;
        set list(value: SingletonList<BaseRender>);
        addRenderObject(object: BaseRender): void;
        removeRenderObject(object: BaseRender): void;
        removeMotionObject(object: BaseRender): void;
        updateMotionObjects(): void;
        addMotionObject(object: BaseRender): void;
        destroy(): void;
    }
    class ShadowCullInfo implements IShadowCullInfo {
        position: Vector3;
        cullPlanes: Plane[];
        cullSphere: BoundSphere;
        cullPlaneCount: number;
        direction: Vector3;
    }
    class SkinRenderElementOBJ extends RenderElementOBJ {
        skinnedData: Float32Array[];
        constructor();
        /** 更新数据并且 */
        drawGeometry(shaderIns: ShaderInstance): void;
    }
    class WebGLRenderEngine3DFactory implements IRenderEngine3DOBJFactory {
        createTransform(owner: Sprite3D): Transform3D;
        createBounds(min: Vector3, max: Vector3): any;
        createRenderElement(): IRenderElement;
        createSkinRenderElement(): IRenderElement;
        createInstanceRenderElement(): InstanceRenderElementOBJ;
        createBaseRenderQueue(isTransparent: boolean): IRenderQueue;
        createVertexBuffer3D(byteLength: number, bufferUsage: BufferUsage, canRead?: boolean): VertexBuffer3D;
        createIndexBuffer3D(indexType: IndexFormat, indexCount: number, bufferUsage?: BufferUsage, canRead?: boolean): IndexBuffer3D;
        createSceneRenderManager(): ISceneRenderManager;
        createCullPass(): ICullPass;
        createSortPass(): ISortPass;
        createShadowCullInfo(): IShadowCullInfo;
        createCameraCullInfo(): ICameraCullInfo;
        createRenderGeometry(mode: MeshTopology, drayType: DrawType): IRenderGeometryElement;
        createBaseRenderNode(): IBaseRenderNode;
        createRenderContext3D(): IRenderContext3D;
    }
    /**
     * <code>Mesh</code> 类用于创建文件网格数据模板。
     */
    class Mesh extends Resource implements IClone {
        static MESH_INSTANCEBUFFER_TYPE_NORMAL: number;
        static MESH_INSTANCEBUFFER_TYPE_SIMPLEANIMATOR: number;
        /**@interanl */
        _triangleMesh: any;
        /**
         * 加载网格模板。
         * @param url 模板地址。
         * @param complete 完成回调。
         */
        static load(url: string, complete: Handler): void;
        morphTargetData: MorphTargetData;
        /**
         * 网格的全局默认绑定动作逆矩阵。
         */
        get inverseAbsoluteBindPoses(): Matrix4x4[];
        /**
         * 获取顶点个数。
         */
        get vertexCount(): number;
        /**
         * 获取索引个数。
         */
        get indexCount(): number;
        /**
         * SubMesh的个数。
         */
        get subMeshCount(): number;
        /**
         * 边界。
         */
        get bounds(): Bounds;
        set bounds(value: Bounds);
        /**
         * 索引格式。
         */
        get indexFormat(): IndexFormat;
        /**
         * 设置indexformat
         */
        set indexFormat(value: IndexFormat);
        /**
         * 创建一个 <code>Mesh</code> 实例,禁止使用。
         * @param isReadable 是否可读。
         */
        constructor(isReadable?: boolean);
        /**
         * @inheritDoc
         * @override
         */
        protected _disposeResource(): void;
        /**
         * 根据获取子网格。
         * @param index 索引。
         */
        getSubMesh(index: number): SubMesh;
        /**
         * 拷贝并填充位置数据至数组。
         * @param positions 位置数组。
         * @remark 该方法为拷贝操作，比较耗费性能。
         */
        getPositions(positions: Vector3[]): void;
        /**
         * 设置位置数据。
         * @param positions 位置。
         */
        setPositions(positions: Vector3[]): void;
        /**
         * 拷贝并填充颜色数据至数组。
         * @param colors 颜色数组。
         * @remark 该方法为拷贝操作，比较耗费性能。
         */
        getColors(colors: Color[]): void;
        /**
         * 设置颜色数据。
         * @param colors  颜色。
         */
        setColors(colors: Color[]): void;
        /**
         * 拷贝并填充纹理坐标数据至数组。
         * @param uvs 纹理坐标数组。
         * @param channel 纹理坐标通道。
         * @remark 该方法为拷贝操作，比较耗费性能。
         */
        getUVs(uvs: Vector2[], channel?: number): void;
        /**
         * 设置纹理坐标数据。
         * @param uvs 纹理坐标。
         * @param channel 纹理坐标通道。
         */
        setUVs(uvs: Vector2[], channel?: number): void;
        /**
         * 拷贝并填充法线数据至数组。
         * @param normals 法线数组。
         * @remark 该方法为拷贝操作，比较耗费性能。
         */
        getNormals(normals: Vector3[]): void;
        /**
         * 设置法线数据。
         * @param normals 法线。
         */
        setNormals(normals: Vector3[]): void;
        /**
         * 拷贝并填充切线数据至数组。
         * @param tangents 切线。
         */
        getTangents(tangents: Vector4[]): void;
        /**
         * 设置切线数据。
         * @param tangents 切线。
         */
        setTangents(tangents: Vector4[]): void;
        /**
        * 获取骨骼权重。
        * @param boneWeights 骨骼权重。
        */
        getBoneWeights(boneWeights: Vector4[]): void;
        /**
        * 拷贝并填充骨骼权重数据至数组。
        * @param boneWeights 骨骼权重。
        */
        setBoneWeights(boneWeights: Vector4[]): void;
        /**
        * 获取骨骼索引。
        * @param boneIndices 骨骼索引。
        */
        getBoneIndices(boneIndices: Vector4[]): void;
        /**
        * 拷贝并填充骨骼索引数据至数组。
        * @param boneWeights 骨骼索引。
        */
        setBoneIndices(boneIndices: Vector4[]): void;
        /**
         * 将Mesh标记为不可读,可减少内存，标记后不可再调用相关读取方法。
         */
        markAsUnreadbale(): void;
        /**
         * 获取顶点声明。
         */
        getVertexDeclaration(): VertexDeclaration;
        /**
        * 拷贝并获取顶点数据的副本。
        * @return 顶点数据。
        */
        getVertices(): ArrayBuffer;
        /**
        * 设置顶点数据。
        * @param vertices 顶点数据。
        */
        setVertices(vertices: ArrayBuffer): void;
        /**
         * 拷贝并获取网格索引的副本。
         * @return 网格索引。
         */
        getIndices(): Uint8Array | Uint16Array | Uint32Array;
        /**
         * 设置网格索引。
         * @param indices 网格索引。
         */
        setIndices(indices: Uint8Array | Uint16Array | Uint32Array): void;
        /**
         * 从模型位置数据生成包围盒。
         */
        calculateBounds(): void;
        /**
         * 获得Corve模型
         */
        getCorveMesh(): Mesh;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * <code>Mesh</code> 类用于创建文件网格数据模板。
     */
    class MeshUtil {
        /**
         * 获得mesh的宏
         * @param mesh Mesh
         * @param out define
         */
        static getMeshDefine(mesh: Mesh, out: Array<ShaderDefine>): void;
    }
    class MorphTarget {
        name: string;
        fullWeight: number;
        data: Float32Array;
        constructor();
    }
    class MorphTargetChannel {
        name: string;
        targetCount: number;
        constructor();
        getTargetByIndex(index: number): MorphTarget;
        addTarget(target: MorphTarget): void;
    }
    class MorphTargetData {
        private targets;
        private channels;
        vertexCount: number;
        /**
         * // todo 移除
         * // 改为 从 VertexDeclaration 中获取
         * morph target attribute element count
         */
        elementCount: number;
        vertexDec: VertexDeclaration;
        bounds: Bounds;
        constructor();
        addMorphChannel(channel: MorphTargetChannel): void;
        getMorphChannel(name: string): MorphTargetChannel;
        getMorphChannelbyIndex(index: number): MorphTargetChannel;
        get channelCount(): number;
        initData(): void;
        destroy(): void;
        clone(): MorphTargetData;
    }
    /**
     * <code>PrimitiveMesh</code> 类用于创建简单网格。
     */
    class PrimitiveMesh {
        static __init__(): void;
        /**
         * 创建Box网格。
         * @param long 半径
         * @param height 垂直层数
         * @param width 水平层数
         * @return
         */
        static createBox(long?: number, height?: number, width?: number): Mesh;
        /**
         * 创建一个胶囊体模型
         * @param radius 半径
         * @param height 高度
         * @param stacks 水平层数,一般设为垂直层数的一半
         * @param slices 垂直层数
         */
        static createCapsule(radius?: number, height?: number, stacks?: number, slices?: number): Mesh;
        /**
         * 创建一个圆锥体模型
         * @param radius 半径
         * @param height 高度
         * @param slices 分段数
         */
        static createCone(radius?: number, height?: number, slices?: number): Mesh;
        /**
         * 创建一个圆柱体模型
         * @param radius 半径
         * @param height 高度
         * @param slices 垂直层数
         */
        static createCylinder(radius?: number, height?: number, slices?: number): Mesh;
        /**
         * 创建一个平面模型
         * @param long  长
         * @param width 宽
         */
        static createPlane(long?: number, width?: number, stacks?: number, slices?: number): Mesh;
        /**
         * 创建一个四边形模型
         * @param long  长
         * @param width 宽
         */
        static createQuad(long?: number, width?: number): Mesh;
        /**
         * 创建一个球体模型
         * @param radius 半径
         * @param stacks 水平层数
         * @param slices 垂直层数
         */
        static createSphere(radius?: number, stacks?: number, slices?: number): Mesh;
    }
    /**
     * <code>SkyBox</code> 类用于创建天空盒。
     */
    class SkyBox extends GeometryElement {
        static instance: SkyBox;
        /**
         * 创建一个 <code>SkyBox</code> 实例。
         */
        constructor();
    }
    /**
     * <code>SkyDome</code> 类用于创建天空盒。
     */
    class SkyDome extends GeometryElement {
        static instance: SkyDome;
        /**
         * 获取堆数。
         */
        get stacks(): number;
        /**
         * 获取层数。
         */
        get slices(): number;
        /**
         * 创建一个 <code>SkyDome</code> 实例。
         * @param stacks 堆数。
         * @param slices 层数。
         */
        constructor(stacks?: number, slices?: number);
    }
    /**
     * <code>SkyRenderer</code> 类用于实现天空渲染器。
     */
    class SkyRenderer {
        private _renderData;
        static SUNLIGHTDIRECTION: number;
        static SUNLIGHTDIRCOLOR: number;
        static __init__(): void;
        /**
         * 材质。
         */
        get material(): Material;
        set material(value: Material);
        /**
         * 网格。
         */
        get mesh(): GeometryElement;
        set mesh(value: GeometryElement);
        /**
         * 创建一个新的 <code>SkyRenderer</code> 实例。
         */
        constructor();
    }
    /**
     * <code>SubMesh</code> 类用于创建子网格数据模板。
     */
    class SubMesh extends GeometryElement {
        /**
         * 获取索引数量。
         */
        get indexCount(): number;
        /**
         * 创建一个 <code>SubMesh</code> 实例。
         * @param	mesh  网格数据模板。
         */
        constructor(mesh: Mesh);
        /**
         * 拷贝并获取子网格索引数据的副本。
         */
        getIndices(): Uint16Array | Uint32Array;
        /**
         * 设置子网格索引。
         * @param indices
         */
        setIndices(indices: Uint16Array): void;
        /**
         * {@inheritDoc GeometryElement.destroy}
         * @override
         */
        destroy(): void;
    }
    class BlinnPhongShaderInit {
        static init(): void;
    }
    class PBRShaderLib {
        /**
         * emission
         */
        static DEFINE_EMISSION: ShaderDefine;
        /**
         * clear coat
         */
        static DEFINE_CLEARCOAT: ShaderDefine;
        static DEFINE_CLEARCOAT_NORMAL: ShaderDefine;
        /**
         * anisotropy
         */
        static DEFINE_ANISOTROPY: ShaderDefine;
        /**
         * ior
         */
        static DEFINE_IOR: ShaderDefine;
        /**
         * iridescence
         */
        static DEFINE_IRIDESCENCE: ShaderDefine;
        /**
         * sheen
         */
        static DEFINE_SHEEN: ShaderDefine;
        /**
         * transmission
         */
        static DEFINE_TRANSMISSION: ShaderDefine;
        /**
         * thick / volume
         */
        static DEFINE_THICKNESS: ShaderDefine;
        static init(): void;
    }
    class PBRStandardShaderInit {
        static init(): void;
    }
    class ACESShaderLib {
        static init(): void;
    }
    class BlitScreenShaderInit {
        static init(): void;
        private static lutBuilderInit;
    }
    /**
     * ParticleShuriKen Shader init
     */
    class ParticleShuriKenShaderInit {
        static init(): void;
    }
    class SkyBoxShaderInit {
        static init(): void;
    }
    class SkyPanoramicShaderInit {
        static init(): void;
    }
    class SkyProceduralShaderInit {
        static init(): void;
    }
    class TrailShaderInit {
        static init(): void;
    }
    class UnlitShaderInit {
        static init(): void;
    }
    /**
     * Shadow Light enum
     */
    enum ShadowLightType {
        /**直射光 */
        DirectionLight = 0,
        /**聚光 */
        SpotLight = 1,
        /**点光 */
        PointLight = 2
    }
    /**
     * <code>TextMesh</code> 类用于创建文本网格。
     */
    class TextMesh {
        private _text;
        private _fontSize;
        private _color;
        /**
         * 获取文本。
         * @return 文本。
         */
        get text(): string;
        /**
         * 设置文本。
         * @param value 文本。
         */
        set text(value: string);
        /**
         * 获取字体尺寸。
         * @param  value 字体尺寸。
         */
        get fontSize(): number;
        /**
         * 设置字体储存。
         * @return 字体尺寸。
         */
        set fontSize(value: number);
        /**
         * 获取颜色。
         * @return 颜色。
         */
        get color(): Color;
        /**
         * 设置颜色。
         * @param 颜色。
         */
        set color(value: Color);
        /**
         * 创建一个新的 <code>TextMesh</code> 实例。
         */
        constructor();
    }
    /**
     * <code>Physics</code> 类用于简单物理检测。
     */
    class Physics3DUtils {
        /**默认碰撞组 */
        static COLLISIONFILTERGROUP_DEFAULTFILTER: number;
        /**静态碰撞组 */
        static COLLISIONFILTERGROUP_STATICFILTER: number;
        /**运动学刚体碰撞组 */
        static COLLISIONFILTERGROUP_KINEMATICFILTER: number;
        /**碎片碰撞组 */
        static COLLISIONFILTERGROUP_DEBRISFILTER: number;
        /**传感器触发器*/
        static COLLISIONFILTERGROUP_SENSORTRIGGER: number;
        /**字符过滤器 */
        static COLLISIONFILTERGROUP_CHARACTERFILTER: number;
        /**自定义过滤1 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER1: number;
        /**自定义过滤2 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER2: number;
        /**自定义过滤3 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER3: number;
        /**自定义过滤4 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER4: number;
        /**自定义过滤5 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER5: number;
        /**自定义过滤6 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER6: number;
        /**自定义过滤7 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER7: number;
        /**自定义过滤8 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER8: number;
        /**自定义过滤9 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER9: number;
        /**自定义过滤10*/
        static COLLISIONFILTERGROUP_CUSTOMFILTER10: number;
        /**所有过滤 */
        static COLLISIONFILTERGROUP_ALLFILTER: number;
        /**PHYSX默认分组 */
        static PHYSXDEFAULTMASKVALUE: number;
    }
    /**
     * <code>Picker</code> 类用于创建拾取。
     */
    class Picker {
        private static _tempVector30;
        private static _tempVector31;
        private static _tempVector32;
        private static _tempVector33;
        private static _tempVector34;
        /**
         * 创建一个 <code>Picker</code> 实例。
         */
        constructor();
        /**
         * 计算鼠标生成的射线。
         * @param	point 鼠标位置。
         * @param	viewPort 视口。
         * @param	projectionMatrix 透视投影矩阵。
         * @param	viewMatrix 视图矩阵。
         * @param	world 世界偏移矩阵。
         * @return  out  输出射线。
         */
        static calculateCursorRay(point: Vector2, viewPort: Viewport, projectionMatrix: Matrix4x4, viewMatrix: Matrix4x4, world: Matrix4x4, out: Ray): void;
        /**
         * 计算射线和三角形碰撞并返回碰撞距离。
         * @param	ray 射线。
         * @param	vertex1 顶点1。
         * @param	vertex2 顶点2。
         * @param	vertex3 顶点3。
         * @return   射线距离三角形的距离，返回Number.NaN则不相交。
         */
        static rayIntersectsTriangle(ray: Ray, vertex1: Vector3, vertex2: Vector3, vertex3: Vector3): number;
        /**
         * 检测射线和平面的交点
         * @param ray
         * @param plane
         * @returns
         */
        static rayPlaneIntersection(ray: Ray, plane: Plane): Vector3;
    }
    /**
     *
     */
    class Size {
        /**
         * 全局场景的屏幕大小
         */
        static get fullScreen(): Size;
        private _width;
        private _height;
        /**
         * 宽度
         */
        get width(): number;
        /**
         * 高度
         */
        get height(): number;
        /**
         * 创建Size实例
         * @param width 宽度
         * @param height 高度
         */
        constructor(width: number, height: number);
    }
    /**
     * <code>Utils3D</code> 类用于创建3D工具。
     */
    class Utils3D {
        private static _tempVector3_0;
        private static _tempVector3_1;
        private static _tempVector3_2;
        private static _tempArray16_0;
        private static _tempArray16_1;
        private static _tempArray16_2;
        private static _tempArray16_3;
        /**
         *通过数平移、旋转、缩放值计算到结果矩阵数组,骨骼动画专用。
         * @param tx left矩阵数组。
         * @param ty left矩阵数组的偏移。
         * @param tz right矩阵数组。
         * @param qx right矩阵数组的偏移。
         * @param qy 输出矩阵数组。
         * @param qz 输出矩阵数组的偏移。
         * @param qw 输出矩阵数组的偏移。
         * @param sx 输出矩阵数组的偏移。
         * @param sy 输出矩阵数组的偏移。
         * @param sz 输出矩阵数组的偏移。
         * @param outArray 结果矩阵数组。
         * @param outOffset 结果矩阵数组的偏移。
         */
        private static _rotationTransformScaleSkinAnimation;
        static _tempV0: Vector3;
        static _tempV1: Vector3;
        /**
         * 将顶点进行billboard转换
         */
        static billboardTrans(v0: Vector3, cameraDir: Vector3, cameraUp: Vector3, out: Vector3): void;
        /**
         * 判断P点是否在ABC组成的三角形中
         * https://mathworld.wolfram.com/BarycentricCoordinates.html
         * @param A
         * @param B
         * @param C
         * @param P
         * @returns
         */
        static PointinTriangle(A: Vector3, B: Vector3, C: Vector3, P: Vector3): boolean;
        /**
         * 根据四元数旋转三维向量。
         * @param	source 源三维向量。
         * @param	rotation 旋转四元数。
         * @param	out 输出三维向量。
         */
        static transformVector3ArrayByQuat(sourceArray: Float32Array, sourceOffset: number, rotation: Quaternion, outArray: Float32Array, outOffset: number): void;
        /**
         *通过数组数据计算矩阵乘法。
         * @param leftArray left矩阵数组。
         * @param leftOffset left矩阵数组的偏移。
         * @param rightArray right矩阵数组。
         * @param rightOffset right矩阵数组的偏移。
         * @param outArray 输出矩阵数组。
         * @param outOffset 输出矩阵数组的偏移。
         */
        static mulMatrixByArray(leftArray: Float32Array, leftOffset: number, rightArray: Float32Array, rightOffset: number, outArray: Float32Array, outOffset: number): void;
        /**
         *通过数组数据计算矩阵乘法,rightArray和outArray不能为同一数组引用。
         * @param leftArray left矩阵数组。
         * @param leftOffset left矩阵数组的偏移。
         * @param rightArray right矩阵数组。
         * @param rightOffset right矩阵数组的偏移。
         * @param outArray 结果矩阵数组。
         * @param outOffset 结果矩阵数组的偏移。
         */
        static mulMatrixByArrayFast(leftArray: Float32Array, leftOffset: number, rightArray: Float32Array, rightOffset: number, outArray: Float32Array, outOffset: number): void;
        /**
         *通过数组数据计算矩阵乘法,rightArray和outArray不能为同一数组引用。
         * @param leftArray left矩阵数组。
         * @param leftOffset left矩阵数组的偏移。
         * @param rightMatrix right矩阵。
         * @param outArray 结果矩阵数组。
         * @param outOffset 结果矩阵数组的偏移。
         */
        static mulMatrixByArrayAndMatrixFast(leftArray: Float32Array, leftOffset: number, rightMatrix: Matrix4x4, outArray: Float32Array, outOffset: number): void;
        /**
         *通过数平移、旋转、缩放值计算到结果矩阵数组。
         * @param tX left矩阵数组。
         * @param tY left矩阵数组的偏移。
         * @param tZ right矩阵数组。
         * @param qX right矩阵数组的偏移。
         * @param qY 输出矩阵数组。
         * @param qZ 输出矩阵数组的偏移。
         * @param qW 输出矩阵数组的偏移。
         * @param sX 输出矩阵数组的偏移。
         * @param sY 输出矩阵数组的偏移。
         * @param sZ 输出矩阵数组的偏移。
         * @param outArray 结果矩阵数组。
         * @param outOffset 结果矩阵数组的偏移。
         */
        static createAffineTransformationArray(tX: number, tY: number, tZ: number, rX: number, rY: number, rZ: number, rW: number, sX: number, sY: number, sZ: number, outArray: Float32Array, outOffset: number): void;
        /**
         * 通过矩阵转换一个三维向量数组到另外一个三维向量数组。
         * @param	source 源三维向量所在数组。
         * @param	sourceOffset 源三维向量数组偏移。
         * @param	transform  变换矩阵。
         * @param	result 输出三维向量所在数组。
         * @param	resultOffset 输出三维向量数组偏移。
         */
        static transformVector3ArrayToVector3ArrayCoordinate(source: Float32Array, sourceOffset: number, transform: Matrix4x4, result: Float32Array, resultOffset: number): void;
        /**
         * 通过矩阵转换一个三维向量数组到另外一个归一化的三维向量数组。
         * @param source 源三维向量所在数组。
         * @param sourceOffset 源三维向量数组偏移。
         * @param transform 变换矩阵。
         * @param result 输出三维向量所在数组。
         * @param resultOffset 输出三维向量数组偏移。
         */
        static transformVector3ArrayToVector3ArrayNormal(source: Float32Array, sourceOffset: number, transform: Matrix4x4, result: Float32Array, resultOffset: number): void;
        /**
         * 获取URL版本字符。
         * @param	url
         * @return
         */
        static getURLVerion(url: string): string;
        /**
         * 四元数旋转矩阵
         * @param source 源数据
         * @param rotation 旋转四元数Array
         * @param out 输出数据
         */
        static transformQuat(source: Vector3, rotation: Float32Array, out: Vector3): void;
        /**
         * 修改四元数权重
         * @param f 元数据
         * @param weight 权重
         * @param e 目标数据
         */
        static quaternionWeight(f: Quaternion, weight: number, e: Quaternion): void;
        /**
         * @interanl
         * @param rootSprite parentNode
         * @param invPath PathArray
         * @returns
         */
        static _getNodeByHierarchyPath(rootSprite: Node, invPath: number[]): Node;
        static _getParentNodeByHierarchyPath(rootSprite: Node, path: number[]): Node;
        /**
         * 将RenderTexture转换为Base64
         * @param rendertexture 渲染Buffer
         * @returns
         */
        static uint8ArrayToArrayBuffer(rendertexture: RenderTexture): String;
    }
    /**
     * @author miner
     * 类用于创建WebXR摄像机。
     */
    class WebXRCamera extends Camera {
        /**
         * WebXRSessionManager
         */
        private _webXRManager;
        /**
         * override client
         */
        private _clientWidth;
        /**
         * override client
         */
        private _clientHeight;
        /**
         * 自定义渲染场景的渲染目标。
         */
        get renderTarget(): RenderTexture;
        /**
         * 渲染
         * @override
         * @param shader
         * @param replacementTag
         */
        render(shader?: Shader3D, replacementTag?: string): void;
        /**
         * null function
         */
        protected _calculateProjectionMatrix(): void;
        /**
         * destroy
         */
        destroy(): void;
    }
    /**
     * @author miner
     * 此类用来管理XRCamera
     */
    class WebXRCameraManager {
        /**
         * reference Quaternin
         */
        private _referenceQuaternion;
        /**
         * reference Position
         */
        private _referencedPosition;
        /**
         * WebXR Session Manager
         */
        private _webXRSessionManager;
        /**
         * first Frame Flag
         */
        private _firstFrame;
        /**
         * WebXR RenderTexture
         */
        private _XRRenderTexture;
        /**
         * WebXRCamera Array
         */
        private _rigCameras;
        /**
         * Reference position
         */
        private _position;
        /**
         * parent
         */
        owner: any;
        get position(): Vector3;
        set position(newPosition: Vector3);
        set rotationQuaternion(value: Quaternion);
        get rotationQuaternion(): Quaternion;
        get rigCameras(): WebXRCamera[];
        /**
         * 用来创建XRCamera管理类
         * @param camera
         * @param manager
         */
        constructor(camera: any, manager?: WebXRSessionManager);
        /**
         * updateFrame by WebXR Session
         */
        _updateFromXRSession(): void;
        /**
         * update number of WebXRCamera
         * @param viewCount
         */
        private _updateNumberOfRigCameras;
        /**
         * TODO:update of Reference Space
         */
        private _updateReferenceSpace;
        /**
         * destroy
         */
        destroy(): void;
    }
    class WebXRCameraInfo {
        /**depth far */
        depthFar: number;
        /**depth near */
        depthNear: number;
        /**camera */
        camera: any;
    }
    /**
     * 类用来管理WebXR
     * @author miner
     */
    class WebXRExperienceHelper {
        static glInstance: any;
        /**
         * single XRManager
         */
        static xr_Manager: WebXRSessionManager;
        /**
         * support webXR
         */
        static supported: boolean;
        /**
         * default WebLayer option
         * XRWebGLLayerInit
         */
        static canvasOptions: {
            antialias: boolean;
            depth: boolean;
            stencil: boolean;
            alpha: boolean;
            multiview: boolean;
            framebufferScaleFactor: number;
        };
        /**
         * 支持XRSession模式
         * @param sessionMode XRSessionMode = "inline" | "immersive-vr" | "immersive-ar";
         * @returns
         */
        static supportXR(sessionMode: string): Promise<boolean>;
        /**
         * 申请WewXR交互
         * @param sessionMode XRSessionMode
         * @param referenceSpaceType referenceType = "viewer" | "local" | "local-floor" | "unbounded";
         * @param cameraInfo WebXRCameraInfo webXRCamera设置
         * @returns Promise<WebXRSessionManager>
         */
        static enterXRAsync(sessionMode: string, referenceSpaceType: string, cameraInfo: WebXRCameraInfo): Promise<WebXRSessionManager>;
        /**
         * config WebXRCameraManager
         * @param camera Camera
         * @param manager WebXRSessionManager
         * @returns
         */
        static setWebXRCamera(camera: Camera, manager: WebXRSessionManager): WebXRCameraManager;
        /**
         * config WebXRInputManager
         * @param sessionManager WebXRSessionManager
         * @param cameraManager WebXRCameraManager
         * @returns
         */
        static setWebXRInput(sessionManager: WebXRSessionManager, cameraManager: WebXRCameraManager): WebXRInputManager;
    }
    /**
     * 类用来描述gamepad Axis
     */
    class AxiGamepad extends EventDispatcher {
        static EVENT_OUTPUT: string;
        /**
         * 轴设备名字
         */
        handness: string;
        /**
         * 轴数量
         */
        axisLength: number;
        /**
         * axis Array
         */
        private axisData;
        /**
         * destroy
         */
        destroy(): void;
    }
    /**
     * 类用来描述gamepad Button
     */
    class ButtonGamepad extends EventDispatcher {
        static EVENT_TOUCH_ENTER: string;
        static EVENT_TOUCH_STAY: string;
        static EVENT_TOUCH_OUT: string;
        static EVENT_PRESS_ENTER: string;
        static EVENT_PRESS_STAY: string;
        static EVENT_PRESS_OUT: string;
        static EVENT_PRESS_VALUE: string;
        /**
         * The id of the gamepad
         */
        handness: string;
        /**
        * The index of the gamepad
        */
        index: number;
        /**
         * front touch state
         */
        private lastTouch;
        private lastPress;
        private lastPressValue;
        /**
         * current touch state
         */
        private touch;
        private press;
        private pressValue;
        /**
         * 类用于创建Button对象
         * @param handness 设备名称
         * @param index button缩影
         */
        constructor(handness: string, index: number);
        /**
         * destroy
         */
        destroy(): void;
    }
    /**
     * @author miner
     * 类用来描述输入设备
     */
    class WebXRInput extends EventDispatcher {
        static HANDNESS_LEFT: string;
        static HANDNESS_RIGHT: string;
        static EVENT_FRAMEUPDATA_WEBXRINPUT: string;
        private static tempQua;
        /**
         * 预处理Button事件
         */
        private preButtonEventList;
        /**
         * 预处理axis事件
         */
        private preAxisEventList;
        lastXRPose: any;
        /**
         * handMode
         */
        handness: string;
        /**
         * input Ray
         */
        ray: Ray;
        /**
         * hand Pos
         */
        position: Vector3;
        /**
         * hand Rotate
         */
        rotation: Quaternion;
        /**
         * lastRayPos
         */
        _lastXRPose: any;
        /**
         * gamepad Button info
         */
        gamepadButton: Array<ButtonGamepad>;
        /**
         * gamepad axis Info
         */
        gamepadAxis: AxiGamepad;
        constructor(handness: string);
        /**
         * handle gamepad Event
         */
        private _handleProcessGamepad;
        /**
         * add button event
         * @param index button索引
         * @param type 事件类型
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         */
        addButtonEvent(index: number, type: string, caller: any, listener: Function): void;
        /**
         * add axis event
         * @param index axis索引
         * @param type 事件类型
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         */
        addAxisEvent(index: number, type: string, caller: any, listener: Function): void;
        /**
         * remove axis event
         * @param index axis索引
         * @param type 事件类型
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         */
        offAxisEvent(index: number, type: string, caller: any, listener: Function): void;
        /**
         * remove Button event
         * @param index axis索引
         * @param type 事件类型
         * @param caller 事件侦听函数的执行域。
         * @param listener 事件侦听函数。
         */
        offButtonEvent(index: number, type: string, caller: any, listener: Function): void;
        /**
         * 销毁
         */
        destroy(): void;
    }
    /**
     * @author miner
     * 类用来管理输入设备
     * The path of the CDN the sample will fetch controller models from：
     * MeshSource https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0.9/dist/profiles/
     */
    class WebXRInputManager {
        static tempVec: Vector3;
        static tempVec1: Vector3;
        /**
         * Session Manager
         */
        private webXRSessionManager;
        /**
         * webXRCamera Manager
         */
        private webXRCameraManager;
        /**
         * array of XRInput
         */
        private controllers;
        /**
         * bind of XRInput Node Render
         */
        private controllerHandMesh;
        /**
         * bind of XRInput Ray Render
         */
        private controllerLineRender;
        /**
         * line Color
         */
        private lineColor;
        /**
         * Ray length
         */
        private rayLength;
        /**
         * 类用于创建WebXRInput管理类
         * @param webxrManager WebXR Session manager
         * @param webXRCamera WebXR Manager
         */
        constructor(webxrManager: WebXRSessionManager, webXRCamera: WebXRCameraManager);
        /**
         * 更新输入挂点
         * @param xrInput
         */
        private _updataMeshRender;
        /**
         * WebXRInput帧循环
         * @param xrFrame
         */
        private _updateFromXRFrame;
        /**
         * 绑定输入设备渲染节点
         * @param meshSprite 渲染挂点
         * @param handness 设备名称left/right
         */
        bindMeshNode(meshSprite: Sprite3D, handness: string): void;
        /**
         * 绑定输入设备射线
         * @param lineSprite 线
         * @param handness 设备名称left/right
         */
        bindRayNode(lineSprite: PixelLineSprite3D, handness: string): void;
        /**
         * 获得输入设备
         * @param handness 设备名称left/right
         * @returns
         */
        getController(handness: string): WebXRInput;
    }
    /**
     * @author miner
     * 类用来创建WebXRRenderTexture
     */
    class WebXRRenderTexture extends RenderTexture {
        /**update mask */
        frameLoop: number;
        /**
         * 创建WebXRFrameBuffer
         * @param frameBuffer
         */
        constructor();
        /**
         * set frameBuffer
         */
        set frameBuffer(value: any);
        /**
         * No glframeBuffer create
         * @param width
         * @param height
         */
        protected _create(width: number, height: number): void;
    }
    /**
     * Manages an XRSession to work with layaAir engine
     * @author miner
     */
    class WebXRSessionManager extends EventDispatcher {
        static EVENT_MANAGER_END: string;
        static EVENT_FRAME_LOOP: string;
        /**
         * Underlying xr session
         */
        session: any;
        /**
         * XRReferenceSpace TODO
         */
        viewerReferenceSpace: any;
        /** baseRefernceSpace */
        baseReferenceSpace: any;
        /** Current XR  XRFrame*/
        currentFrame: any;
        /** WebXR timestamp updated every frame */
        currentTimestamp: number;
        /**默认高度补偿,在init失败后使用 */
        defaultHeightCompensation: number;
        /**
         * XRReferenceSpace
         */
        private _referenceSpace;
        /** "inline" | "immersive-vr" | "immersive-ar"*/
        private _sessionMode;
        /** session enable state */
        private _sessionEnded;
        /**WebXR Base Layer */
        private _baseLayer;
        /**web XRSystem */
        private _xrNavigator;
        /**
        * The current reference space used in this session.
        * @returns XRReferenceSpace;
        */
        get referenceSpace(): any;
        /**
         * set 参考空间
         */
        set referenceSpace(newReferenceSpace: any);
        /**
        * The mode for the managed XR session
        */
        get sessionMode(): any;
        /**
         * Stops the xrSession and restores the render loop
         */
        exitXR(): void;
        /**
         * Initializes the xr layer for the session
         * @param xrSession
         * @param gl
         * @returns
         */
        initializeXRGL(xrSession: any, gl: WebGLRenderingContext): Promise<boolean>;
        /**
         * 浏览器是否支持WebXR
         * @returns WebXR
         */
        initializeAsync(): Promise<void>;
        /**
         * Sessiopn模式是否支持
         * @param sessionMode "inline" | "immersive-vr" | "immersive-ar"
         * @returns A Promise that resolves to true if supported and false if not
         */
        isSessionSupportedAsync(sessionMode: string): Promise<boolean>;
        /**
         * 初始化Session
         * @param xrSessionMode xrsessionMode
         * @param xrSessionInit any initInfo
         * @returns
         */
        initializeSessionAsync(xrSessionMode?: string, xrSessionInit?: {}): Promise<any>;
        /**
         * Resets the reference space to the one started the session
         */
        resetReferenceSpace(): void;
        /**
         * Starts rendering to the xr layer
         */
        runXRRenderLoop(): void;
        endXRRenderLoop(): void;
        /**
         * Update
         * @param xrFrame
         */
        private _updateByXrFrame;
        /**
        * Sets the reference space on the xr session
        * @param referenceSpaceType space to set
        * @returns a promise that will resolve once the reference space has been set
        */
        setReferenceSpaceTypeAsync(referenceSpaceType?: string): Promise<any>;
        /**
        * Updates the render state of the session
        * @param state state to set
        * @returns a promise that resolves once the render state has been updated
        */
        updateRenderStateAsync(state: any): any;
        /**
         * The current frame rate as reported by the device
         */
        get currentFrameRate(): number | undefined;
        /**
        * A list of supported frame rates (only available in-session!
        */
        get supportedFrameRates(): Float32Array | undefined;
        /**
         * Set the framerate of the session.
         * @param rate the new framerate. This value needs to be in the supportedFrameRates array
         * @returns a promise that resolves once the framerate has been set
         */
        updateTargetFrameRate(rate: number): Promise<void>;
        destroy(): void;
    }
    /**
     * 使用前可用<code>supported</code>查看浏览器支持。
     */
    class Geolocation {
        private static navigator;
        private static position;
        /**
         * 由于权限被拒绝造成的地理信息获取失败。
         */
        static PERMISSION_DENIED: number;
        /**
         * 由于内部位置源返回了内部错误导致地理信息获取失败。
         */
        static POSITION_UNAVAILABLE: number;
        /**
         * 信息获取所用时长超出<code>timeout</code>所设置时长。
         */
        static TIMEOUT: number;
        /**
         * 是否支持。
         */
        static supported: boolean;
        /**
         * 如果<code>enableHighAccuracy</code>为true，并且设备能够提供一个更精确的位置，则会获取最佳可能的结果。
         * 请注意,这可能会导致较慢的响应时间或增加电量消耗（如使用GPS）。
         * 另一方面，如果设置为false，将会得到更快速的响应和更少的电量消耗。
         * 默认值为false。
         */
        static enableHighAccuracy: boolean;
        /**
         * 表示允许设备获取位置的最长时间。默认为Infinity，意味着getCurentPosition()直到位置可用时才会返回信息。
         */
        static timeout: number;
        /**
         * 表示可被返回的缓存位置信息的最大时限。
         * 如果设置为0，意味着设备不使用缓存位置，并且尝试获取实时位置。
         * 如果设置为Infinity，设备必须返回缓存位置而无论其时限。
         */
        static maximumAge: number;
        constructor();
        /**
         * 获取设备当前位置。
         * @param	onSuccess	带有唯一<code>Position</code>参数的回调处理器。
         * @param	onError		可选的。带有错误信息的回调处理器。错误代码为Geolocation.PERMISSION_DENIED、Geolocation.POSITION_UNAVAILABLE和Geolocation.TIMEOUT之一。
         */
        static getCurrentPosition(onSuccess: Handler, onError?: Handler): void;
        /**
         * 监视设备当前位置。回调处理器在设备位置改变时被执行。
         * @param	onSuccess	带有唯一<code>Position</code>参数的回调处理器。
         * @param	onError		可选的。带有错误信息的回调处理器。错误代码为Geolocation.PERMISSION_DENIED、Geolocation.POSITION_UNAVAILABLE和Geolocation.TIMEOUT之一。
         */
        static watchPosition(onSuccess: Handler, onError: Handler): number;
        /**
         * 移除<code>watchPosition</code>安装的指定处理器。
         * @param	id
         */
        static clearWatch(id: number): void;
    }
    class GeolocationInfo {
        private pos;
        private coords;
        /**
         * 设置设备经纬度
         * @param pos
         */
        setPosition(pos: any): void;
        /**
         * 获取设备当前地理坐标的纬度
         */
        get latitude(): number;
        /**
         * 获取设备当前地理坐标的经度
         */
        get longitude(): number;
        /**
         * 获取设备当前地理坐标的高度
         */
        get altitude(): number;
        /**
         * 获取设备当前地理坐标的精度
         */
        get accuracy(): number;
        /**
         * 获取设备当前地理坐标的高度精度
         */
        get altitudeAccuracy(): number;
        /**
         * 获取设备当前行进方向
         */
        get heading(): number;
        /**
         * 获取设备当前的速度
         */
        get speed(): number;
        /**
         * 获取设备得到当前位置的时间
         */
        get timestamp(): number;
    }
    /**
     * Media用于捕捉摄像头和麦克风。可以捕捉任意之一，或者同时捕捉两者。<code>getCamera</code>前可以使用<code>supported()</code>检查当前浏览器是否支持。
     * <b>NOTE:</b>
     * <p>目前Media在移动平台只支持Android，不支持IOS。只可在FireFox完整地使用，Chrome测试时无法捕捉视频。</p>
     */
    class Media {
        constructor();
        /**
         * 检查浏览器兼容性。
         */
        static supported(): boolean;
        /**
         * 获取用户媒体。
         * @param	options	简单的可选项可以使<code>{ audio:true, video:true }</code>表示同时捕捉两者。详情见<i>https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia</i>。
         * @param	onSuccess 获取成功的处理器，唯一参数返回媒体的Blob地址，可以将其传给Video。
         * @param	onError	获取失败的处理器，唯一参数是Error。
         */
        static getMedia(options: any, onSuccess: Handler, onError: Handler): void;
    }
    /**
         * 加速度x/y/z的单位均为m/s²。
         * 在硬件（陀螺仪）不支持的情况下，alpha、beta和gamma值为null。
         *
         * @author Survivor
         */
    class AccelerationInfo {
        /**
         * x轴上的加速度值。
         */
        x: number;
        /**
         * y轴上的加速度值。
         */
        y: number;
        /**
         * z轴上的加速度值。
         */
        z: number;
        constructor();
    }
    /**
     * Accelerator.instance获取唯一的Accelerator引用，请勿调用构造函数。
     *
     * <p>
     * listen()的回调处理器接受四个参数：
     * <ol>
     * <li><b>acceleration</b>: 表示用户给予设备的加速度。</li>
     * <li><b>accelerationIncludingGravity</b>: 设备受到的总加速度（包含重力）。</li>
     * <li><b>rotationRate</b>: 设备的自转速率。</li>
     * <li><b>interval</b>: 加速度获取的时间间隔（毫秒）。</li>
     * </ol>
     * </p>
     * <p>
     * <b>NOTE</b><br/>
     * 如，rotationRate的alpha在apple和moz文档中都是z轴旋转角度，但是实测是x轴旋转角度。为了使各属性表示的值与文档所述相同，实际值与其他属性进行了对调。
     * 其中：
     * <ul>
     * <li>alpha使用gamma值。</li>
     * <li>beta使用alpha值。</li>
     * <li>gamma使用beta。</li>
     * </ul>
     * 目前孰是孰非尚未可知，以此为注。
     * </p>
     */
    class Accelerator extends EventDispatcher {
        /**
         * Accelerator的唯一引用。
         */
        private static _instance;
        static get instance(): Accelerator;
        private static acceleration;
        private static accelerationIncludingGravity;
        private static rotationRate;
        constructor();
        protected onStartListeningToType(type: string): this;
        private onDeviceOrientationChange;
        private static transformedAcceleration;
        /**
         * 把加速度值转换为视觉上正确的加速度值。依赖于Browser.window.orientation，可能在部分低端机无效。
         * @param	acceleration
         * @return
         */
        static getTransformedAcceleration(acceleration: AccelerationInfo): AccelerationInfo;
    }
    /**
     * 使用Gyroscope.instance获取唯一的Gyroscope引用，请勿调用构造函数。
     *
     * <p>
     * listen()的回调处理器接受两个参数：
     * <code>function onOrientationChange(absolute:Boolean, info:RotationInfo):void</code>
     * <ol>
     * <li><b>absolute</b>: 指示设备是否可以提供绝对方位数据（指向地球坐标系），或者设备决定的任意坐标系。关于坐标系参见<i>https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Orientation_and_motion_data_explained</i>。</li>
     * <li><b>info</b>: <code>RotationInfo</code>类型参数，保存设备的旋转值。</li>
     * </ol>
     * </p>
     *
     * <p>
     * 浏览器兼容性参见：<i>http://caniuse.com/#search=deviceorientation</i>
     * </p>
     */
    class Gyroscope extends EventDispatcher {
        private static info;
        /**
         * Gyroscope的唯一引用。
         */
        private static _instance;
        /**
         * 获得默认值
         */
        static get instance(): Gyroscope;
        /**
         * 实例化一个Gyroscope
         * @param singleton
         */
        constructor(singleton: number);
        protected onStartListeningToType(type: string): this;
        private onDeviceOrientationChange;
    }
    /**
         * 保存旋转信息的类。请勿修改本类的属性。
         * @author Survivor
         */
    class RotationInfo {
        /**
         * <p>
         * 指示设备是否可以提供绝对方位数据（指向地球坐标系），或者设备决定的任意坐标系。
         * 关于坐标系参见<i>https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Orientation_and_motion_data_explained</i>。
         * </p>
         * 需要注意的是，IOS环境下，该值始终为false。即使如此，你依旧可以从<code>alpha</code>中取得正确的值。
         */
        absolute: boolean;
        /**
         * Z轴旋转角度，其值范围从0至360。
         * 若<code>absolute</code>为true或者在IOS中，alpha值是从北方到当前设备方向的角度值。
         */
        alpha: number;
        /**
         * X轴旋转角度, 其值范围从-180至180。代表设备从前至后的运动。
         */
        beta: number;
        /**
         * Y轴旋转角度，其值范围从-90至90。代表设备从左至右的运动。
         */
        gamma: number;
        /**
         * 罗盘数据的精确度（角度）。仅IOS可用。
         */
        compassAccuracy: number;
        constructor();
    }
    /**
     * Shake只能在支持此操作的设备上有效。
     *
     */
    class Shake extends EventDispatcher {
        private throushold;
        private shakeInterval;
        private callback;
        private lastX;
        private lastY;
        private lastZ;
        private lastMillSecond;
        constructor();
        private static _instance;
        static get instance(): Shake;
        /**
         * 开始响应设备摇晃。
         * @param	throushold	响应的瞬时速度阈值，轻度摇晃的值约在5~10间。
         * @param	timeout		设备摇晃的响应间隔时间。
         * @param	callback	在设备摇晃触发时调用的处理器。
         */
        start(throushold: number, interval: number): void;
        /**
         * 停止响应设备摇晃。
         */
        stop(): void;
        private onShake;
        private isShaked;
    }
    /**
     * 动画播放完毕后调度。
     * @eventType Event.COMPLETE
     */
    /**
     * 播放到某标签后调度。
     * @eventType Event.LABEL
     */
    /**
     * <p> <code>Animation</code> 是Graphics动画类。实现了基于Graphics的动画创建、播放、控制接口。</p>
     * <p>本类使用了动画模版缓存池，它以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。</p>
     * <p>动画模版缓存池，以key-value键值对存储，key可以自定义，也可以从指定的配置文件中读取，value为对应的动画模版，是一个Graphics对象数组，每个Graphics对象对应一个帧图像，动画的播放实质就是定时切换Graphics对象。</p>
     * <p>使用set source、loadImages(...)、loadAtlas(...)、loadAnimation(...)方法可以创建动画模版。使用play(...)可以播放指定动画。</p>
     * @example <caption>以下示例代码，创建了一个 <code>Text</code> 实例。</caption>
     * package
     * {
     * 	import laya.display.Animation;
     * 	import laya.net.Loader;
     * 	import laya.utils.Handler;
     * 	public class Animation_Example
     * 	{
     * 		public function Animation_Example()
     * 		{
     * 			Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     * 			Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     * 			init();//初始化
     * 		}
     * 		private function init():void
     * 		{
     * 			var animation:Animation = new Animation();//创建一个 Animation 类的实例对象 animation 。
     * 			animation.loadAtlas("resource/ani/fighter.json");//加载图集并播放
     * 			animation.x = 200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
     * 			animation.y = 200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
     * 			animation.interval = 50;//设置 animation 对象的动画播放间隔时间，单位：毫秒。
     * 			animation.play();//播放动画。
     * 			Laya.stage.addChild(animation);//将 animation 对象添加到显示列表。
     * 		}
     * 	}
     * }
     *
     * @example
     * Animation_Example();
     * function Animation_Example(){
     *     Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     *     Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *     init();//初始化
     * }
     * function init()
     * {
     *     var animation = new Laya.Animation();//创建一个 Animation 类的实例对象 animation 。
     *     animation.loadAtlas("resource/ani/fighter.json");//加载图集并播放
     *     animation.x = 200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
     *     animation.y = 200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
     *     animation.interval = 50;//设置 animation 对象的动画播放间隔时间，单位：毫秒。
     *     animation.play();//播放动画。
     *     Laya.stage.addChild(animation);//将 animation 对象添加到显示列表。
     * }
     *
     * @example
     * import Animation = laya.display.Animation;
     * class Animation_Example {
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         this.init();
     *     }
     *     private init(): void {
     *         var animation:Animation = new Laya.Animation();//创建一个 Animation 类的实例对象 animation 。
     *         animation.loadAtlas("resource/ani/fighter.json");//加载图集并播放
     *         animation.x = 200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
     *         animation.y = 200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
     *         animation.interval = 50;//设置 animation 对象的动画播放间隔时间，单位：毫秒。
     *         animation.play();//播放动画。
     *         Laya.stage.addChild(animation);//将 animation 对象添加到显示列表。
     *     }
     * }
     * new Animation_Example();
     */
    class Animation extends AnimationBase {
        /**
         * <p>动画模版缓存池，以key-value键值对存储，key可以自定义，也可以从指定的配置文件中读取，value为对应的动画模版，是一个Graphics对象数组，每个Graphics对象对应一个帧图像，动画的播放实质就是定时切换Graphics对象。</p>
         * <p>使用loadImages(...)、loadAtlas(...)、loadAnimation(...)、set source方法可以创建动画模版。使用play(...)可以播放指定动画。</p>
         */
        static framesMap: any;
        /**@private */
        protected _frames: any[];
        private _source;
        private _autoPlay;
        /**
         * 创建一个新的 <code>Animation</code> 实例。
         */
        constructor();
        /** @inheritDoc
         *  @override
         */
        destroy(destroyChild?: boolean): void;
        /**
         * <p>开始播放动画。会在动画模版缓存池中查找key值为name的动画模版，存在则用此动画模版初始化当前序列帧， 如果不存在，则使用当前序列帧。</p>
         * <p>play(...)方法被设计为在创建实例后的任何时候都可以被调用，调用后就处于播放状态，当相应的资源加载完毕、调用动画帧填充方法(set frames)或者将实例显示在舞台上时，会判断是否处于播放状态，如果是，则开始播放。</p>
         * <p>配合wrapMode属性，可设置动画播放顺序类型。</p>
         * @param	start	（可选）指定动画播放开始的索引(int)或帧标签(String)。帧标签可以通过addLabel(...)和removeLabel(...)进行添加和删除。
         * @param	loop	（可选）是否循环播放。
         * @param	name	（可选）动画模板在动画模版缓存池中的key，也可认为是动画名称。如果name为空，则播放当前动画序列帧；如果不为空，则在动画模版缓存池中寻找key值为name的动画模版，如果存在则用此动画模版初始化当前序列帧并播放，如果不存在，则仍然播放当前动画序列帧；如果没有当前动画的帧数据，则不播放，但该实例仍然处于播放状态。
         * @override
         */
        play(start?: any, loop?: boolean, name?: string): void;
        /**@private */
        protected _setFramesFromCache(name: string, showWarn?: boolean): boolean;
        /**@private */
        private _copyLabels;
        /**@private
        *  @override
        */
        protected _frameLoop(): void;
        /**@private
         * @override
        */
        protected _displayToIndex(value: number): void;
        /**
         * 当前动画的帧图像数组。本类中，每个帧图像是一个Graphics对象，而动画播放就是定时切换Graphics对象的过程。
         */
        get frames(): any[];
        set frames(value: any[]);
        /**
         * <p>动画数据源。</p>
         * <p>类型如下：<br/>
         * 1. LayaAir IDE动画文件路径：使用此类型需要预加载所需的图集资源，否则会创建失败，如果不想预加载或者需要创建完毕的回调，请使用loadAnimation(...)方法；<br/>
         * 2. 图集路径：使用此类型创建的动画模版不会被缓存到动画模版缓存池中，如果需要缓存或者创建完毕的回调，请使用loadAtlas(...)方法；<br/>
         * 3. 图片路径集合：使用此类型创建的动画模版不会被缓存到动画模版缓存池中，如果需要缓存，请使用loadImages(...)方法。</p>
         * @param value	数据源。比如：图集："xx/a1.atlas"；图片集合："a1.png,a2.png,a3.png"；LayaAir IDE动画"xx/a1.ani"。
         */
        get source(): string;
        set source(value: string);
        /**
         * 是否自动播放，默认为false。如果设置为true，则动画被创建并添加到舞台后自动播放。
         */
        set autoPlay(value: boolean);
        get autoPlay(): boolean;
        /**
         * 停止动画播放，并清理对象属性。之后可存入对象池，方便对象复用。
         * @override
         */
        clear(): AnimationBase;
        /**
         * <p>根据指定的动画模版初始化当前动画序列帧。选择动画模版的过程如下：1. 动画模版缓存池中key为cacheName的动画模版；2. 如果不存在，则加载指定的图片集合并创建动画模版。注意：只有指定不为空的cacheName，才能将创建好的动画模版以此为key缓存到动画模版缓存池，否则不进行缓存。</p>
         * <p>动画模版缓存池是以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。</p>
         * <p>因为返回值为Animation对象本身，所以可以使用如下语法：loadImages(...).loadImages(...).play(...);。</p>
         * @param	urls		图片路径集合。需要创建动画模版时，会以此为数据源。参数形如：[url1,url2,url3,...]。
         * @param	cacheName	（可选）动画模板在动画模版缓存池中的key。如果此参数不为空，表示使用动画模版缓存池。如果动画模版缓存池中存在key为cacheName的动画模版，则使用此模版。否则，创建新的动画模版，如果cacheName不为空，则以cacheName为key缓存到动画模版缓存池中，如果cacheName为空，不进行缓存。
         * @return 	返回Animation对象本身。
         */
        loadImages(urls: any[], cacheName?: string): Animation;
        /**
         * <p>根据指定的动画模版初始化当前动画序列帧。选择动画模版的过程如下：1. 动画模版缓存池中key为cacheName的动画模版；2. 如果不存在，则加载指定的图集并创建动画模版。</p>
         * <p>注意：只有指定不为空的cacheName，才能将创建好的动画模版以此为key缓存到动画模版缓存池，否则不进行缓存。</p>
         * <p>动画模版缓存池是以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。</p>
         * <p>因为返回值为Animation对象本身，所以可以使用如下语法：loadAtlas(...).loadAtlas(...).play(...);。</p>
         * @param	url			图集路径。需要创建动画模版时，会以此为数据源。
         * @param	loaded		（可选）使用指定图集初始化动画完毕的回调。
         * @param	cacheName	（可选）动画模板在动画模版缓存池中的key。如果此参数不为空，表示使用动画模版缓存池。如果动画模版缓存池中存在key为cacheName的动画模版，则使用此模版。否则，创建新的动画模版，如果cacheName不为空，则以cacheName为key缓存到动画模版缓存池中，如果cacheName为空，不进行缓存。
         * @return 	返回动画本身。
         */
        loadAtlas(url: string, loaded?: Handler, cacheName?: string): Animation;
        /**
         * <p>加载并解析由LayaAir IDE制作的动画文件，此文件中可能包含多个动画。默认帧率为在IDE中设计的帧率，如果调用过set interval，则使用此帧间隔对应的帧率。加载后创建动画模版，并缓存到动画模版缓存池，key "url#动画名称" 对应相应动画名称的动画模板，key "url#" 对应动画模版集合的默认动画模版。</p>
         * <p>注意：如果调用本方法前，还没有预加载动画使用的图集，请将atlas参数指定为对应的图集路径，否则会导致动画创建失败。</p>
         * <p>动画模版缓存池是以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。</p>
         * <p>因为返回值为Animation对象本身，所以可以使用如下语法：loadAnimation(...).loadAnimation(...).play(...);。</p>
         * @param	url 	动画文件路径。可由LayaAir IDE创建并发布。
         * @param	loaded	（可选）使用指定动画资源初始化动画完毕的回调。
         * @param	atlas	（可选）动画用到的图集地址（可选）。
         * @return 	返回动画本身。
         * @deprecated
         */
        loadAnimation(url: string, loaded?: Handler, atlas?: string): Animation;
        /**@private */
        private _loadAnimationData;
        /**
         * <p>创建动画模板，多个动画可共享同一份动画模板，而不必每次都创建一份新的，从而节省创建Graphics集合的开销。</p>
         * @param	url			图集路径或者图片路径数组。如果是图集路径，需要相应图集已经被预加载，如果没有预加载，会导致创建失败。
         * @param	name		动画模板在动画模版缓存池中的key。如果不为空，则以此为key缓存动画模板，否则不缓存。
         * @return	动画模板。
         */
        static createFrames(url: string | string[], name: string): any[];
        /**
         * <p>从动画模版缓存池中清除指定key值的动画数据。</p>
         * <p>开发者在调用创建动画模版函数时，可以手动指定此值。而如果是由LayaAir IDE创建的动画集，解析后的key格式为："url#"：表示动画集的默认动画模版，如果以此值为参数，会清除整个动画集数据；"url#aniName"：表示相应名称的动画模版。</p>
         * @param key 动画模板在动画模版缓存池中的key。
         */
        static clearCache(key: string): void;
    }
    /**
     * 动画播放完毕后调度。
     * @eventType Event.COMPLETE
     */
    /**
     * 播放到某标签后调度。
     * @eventType Event.LABEL
     */
    /**
     * <p>动画基类，提供了基础的动画播放控制方法和帧标签事件相关功能。</p>
     * <p>可以继承此类，但不要直接实例化此类，因为有些方法需要由子类实现。</p>
     */
    class AnimationBase extends Sprite {
        /**动画播放顺序类型：正序播放。 */
        static WRAP_POSITIVE: number;
        /**动画播放顺序类型：逆序播放。 */
        static WRAP_REVERSE: number;
        /**动画播放顺序类型：pingpong播放(当按指定顺序播放完结尾后，如果继续播放，则会改变播放顺序)。 */
        static WRAP_PINGPONG: number;
        /**是否循环播放，调用play(...)方法时，会将此值设置为指定的参数值。*/
        loop: boolean;
        /**播放顺序类型：AnimationBase.WRAP_POSITIVE为正序播放(默认值)，AnimationBase.WRAP_REVERSE为倒序播放，AnimationBase.WRAP_PINGPONG为pingpong播放(当按指定顺序播放完结尾后，如果继续播发，则会改变播放顺序)。*/
        wrapMode: number;
        /**@private 播放间隔(单位：毫秒)。*/
        protected _interval: number;
        /**@private */
        protected _index: number;
        /**@private */
        protected _count: number;
        /**@private */
        protected _isPlaying: boolean;
        /**@private */
        protected _labels: any;
        /**是否是逆序播放*/
        protected _isReverse: boolean;
        /**@private */
        protected _frameRateChanged: boolean;
        /**@private */
        protected _actionName: string;
        /**@private */
        private _controlNode;
        /**
         * 可以继承此类，但不要直接实例化此类，因为有些方法需要由子类实现。
         */
        constructor();
        /**
         * <p>开始播放动画。play(...)方法被设计为在创建实例后的任何时候都可以被调用，当相应的资源加载完毕、调用动画帧填充方法(set frames)或者将实例显示在舞台上时，会判断是否正在播放中，如果是，则进行播放。</p>
         * <p>配合wrapMode属性，可设置动画播放顺序类型。</p>
         * @param	start	（可选）指定动画播放开始的索引(int)或帧标签(String)。帧标签可以通过addLabel(...)和removeLabel(...)进行添加和删除。
         * @param	loop	（可选）是否循环播放。
         * @param	name	（可选）动画名称。
         */
        play(start?: any, loop?: boolean, name?: string): void;
        /**
         * <p>动画播放的帧间隔时间(单位：毫秒)。默认值依赖于Config.animationInterval=50，通过Config.animationInterval可以修改默认帧间隔时间。</p>
         * <p>要想为某动画设置独立的帧间隔时间，可以使用set interval，注意：如果动画正在播放，设置后会重置帧循环定时器的起始时间为当前时间，也就是说，如果频繁设置interval，会导致动画帧更新的时间间隔会比预想的要慢，甚至不更新。</p>
         */
        get interval(): number;
        set interval(value: number);
        /**@private */
        protected _getFrameByLabel(label: string): number;
        /**@private */
        protected _frameLoop(): void;
        /**@private */
        protected _resumePlay(): void;
        /**
         * 停止动画播放。
         */
        stop(): void;
        /**
         * 是否正在播放中。
         */
        get isPlaying(): boolean;
        /**
         * 增加一个帧标签到指定索引的帧上。当动画播放到此索引的帧时会派发Event.LABEL事件，派发事件是在完成当前帧画面更新之后。
         * @param	label	帧标签名称
         * @param	index	帧索引
         */
        addLabel(label: string, index: number): void;
        /**
         * 删除指定的帧标签。
         * @param	label 帧标签名称。注意：如果为空，则删除所有帧标签！
         */
        removeLabel(label: string): void;
        /**@private */
        private _removeLabelFromList;
        /**
         * 将动画切换到指定帧并停在那里。
         * @param	position 帧索引或帧标签
         */
        gotoAndStop(position: any): void;
        /**
         * 动画当前帧的索引。
         */
        get index(): number;
        set index(value: number);
        /**
         * @private
         * 显示到某帧
         * @param value 帧索引
         */
        protected _displayToIndex(value: number): void;
        /**
         * 当前动画中帧的总数。
         */
        get count(): number;
        /**
         * 停止动画播放，并清理对象属性。之后可存入对象池，方便对象复用。
         * @return 返回对象本身
         */
        clear(): AnimationBase;
    }
    /**
     * <code>BitmapFont</code> 是位图字体类，用于定义位图字体信息。
     * 字体制作及使用方法，请参考文章
     * @see http://ldc2.layabox.com/doc/?nav=ch-js-1-2-5
     */
    class BitmapFont extends Resource {
        texture: Texture;
        dict: Record<string, BMGlyph>;
        padding: any[];
        /**当前位图字体字号，使用时，如果字号和设置不同，并且autoScaleSize=true，则按照设置字号比率进行缩放显示。*/
        fontSize: number;
        /**表示是否根据实际使用的字体大小缩放位图字体大小。*/
        autoScaleSize: boolean;
        tint: boolean;
        maxWidth: number;
        lineHeight: number;
        letterSpacing: number;
        /**
         * 通过指定位图字体文件路径，加载位图字体文件，加载完成后会自动解析。
         * @param	path		位图字体文件的路径。
         * @param	complete	加载并解析完成的回调。
         */
        static loadFont(path: string, complete: Handler): void;
        constructor();
        /**
         * 解析字体文件。
         * @param	xml			字体文件XML。
         * @param	texture		字体的纹理。
         */
        parseFont(xml: XML, texture: Texture): void;
        /**
         * 销毁位图字体，调用Text.unregisterBitmapFont 时，默认会销毁。
         */
        protected _disposeResource(): void;
        /**
         * 获取指定文本内容的宽度。
         * @param	text 文本内容。
         * @return  宽度。
         */
        getTextWidth(text: string, fontSize?: number): number;
        /**
         * 获取最大字符宽度。
         */
        getMaxWidth(fontSize?: number): number;
        /**
         * 获取最大字符高度。
         */
        getMaxHeight(fontSize?: number): number;
    }
    interface BMGlyph {
        x?: number;
        y?: number;
        width?: number;
        height?: number;
        advance?: number;
        texture?: Texture;
    }
    /**
     * 透明命令
     */
    class AlphaCmd {
        static ID: string;
        /**
         * 透明度
         */
        alpha: number;
        /**@private */
        static create(alpha: number): AlphaCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
    }
    /**
     * 裁剪命令
     */
    class ClipRectCmd {
        static ID: string;
        /**
         * X 轴偏移量。
         */
        x: number;
        /**
         * Y 轴偏移量。
         */
        y: number;
        /**
         * 宽度。
         */
        width: number;
        /**
         * 高度。
         */
        height: number;
        /**@private */
        static create(x: number, y: number, width: number, height: number): ClipRectCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
    }
    /**
     * 绘制圆形
     */
    class DrawCircleCmd {
        static ID: string;
        /**
         * 圆点X 轴位置。
         */
        x: number;
        /**
         * 圆点Y 轴位置。
         */
        y: number;
        /**
         * 半径。
         */
        radius: number;
        /**
         * 填充颜色，或者填充绘图的渐变对象。
         */
        fillColor: any;
        /**
         * （可选）边框颜色，或者填充绘图的渐变对象。
         */
        lineColor: any;
        /**
         * （可选）边框宽度。
         */
        lineWidth: number;
        /**
         * 位置和大小是否是百分比
         */
        percent: boolean;
        /**@private */
        static create(x: number, y: number, radius: number, fillColor: any, lineColor: any, lineWidth: number): DrawCircleCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    /**
     * 绘制曲线
     */
    class DrawCurvesCmd {
        static ID: string;
        /**
         * 开始绘制的 X 轴位置。
         */
        x: number;
        /**
         * 开始绘制的 Y 轴位置。
         */
        y: number;
        /**
         * 线段的点集合，格式[controlX, controlY, anchorX, anchorY...]。
         */
        points: number[] | null;
        /**
         * 线段颜色，或者填充绘图的渐变对象。
         */
        lineColor: any;
        /**
         * （可选）线段宽度。
         */
        lineWidth: number;
        /**@private */
        static create(x: number, y: number, points: any[], lineColor: any, lineWidth: number): DrawCurvesCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    class DrawEllipseCmd {
        static ID: string;
        /**
         * 圆点X 轴位置。
         */
        x: number;
        /**
         * 圆点Y 轴位置。
         */
        y: number;
        /**
         * 横向半径。
         */
        width: number;
        /**
         * 纵向半径。
         */
        height: number;
        /**
         * 填充颜色，或者填充绘图的渐变对象。
         */
        fillColor: any;
        /**
         * （可选）边框颜色，或者填充绘图的渐变对象。
         */
        lineColor: any;
        /**
         * （可选）边框宽度。
         */
        lineWidth: number;
        /**
         * 位置和大小是否是百分比
         */
        percent: boolean;
        /**@private */
        static create(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number, percent?: boolean): DrawEllipseCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    /**
     * 绘制图片
     */
    class DrawImageCmd {
        static ID: string;
        /**
         * 纹理。
         */
        texture: Texture | null;
        /**
         * （可选）X轴偏移量。
         */
        x: number;
        /**
         * （可选）Y轴偏移量。
         */
        y: number;
        /**
         * （可选）宽度。
         */
        width: number;
        /**
         * （可选）高度。
         */
        height: number;
        /** （可选）绘图颜色 */
        color: number;
        /**@private */
        static create(texture: Texture, x: number, y: number, width: number, height: number, color: string): DrawImageCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
    }
    /**
     * 绘制单条曲线
     */
    class DrawLineCmd {
        static ID: string;
        /**
         * X轴开始位置。
         */
        fromX: number;
        /**
         * Y轴开始位置。
         */
        fromY: number;
        /**
         * X轴结束位置。
         */
        toX: number;
        /**
         * Y轴结束位置。
         */
        toY: number;
        /**
         * 颜色。
         */
        lineColor: string;
        /**
         * （可选）线条宽度。
         */
        lineWidth: number;
        /**
         * 位置是否是百分比
         */
        percent: boolean;
        /**@private */
        static create(fromX: number, fromY: number, toX: number, toY: number, lineColor: string, lineWidth: number): DrawLineCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    /**
     * 绘制连续曲线
     */
    class DrawLinesCmd {
        static ID: string;
        /**
         * 开始绘制的X轴位置。
         */
        x: number;
        /**
         * 开始绘制的Y轴位置。
         */
        y: number;
        /**
         * 线段的点集合。格式:[x1,y1,x2,y2,x3,y3...]。
         */
        points: number[] | null;
        /**
         * 线段颜色，或者填充绘图的渐变对象。
         */
        lineColor: any;
        /**
         * （可选）线段宽度。
         */
        lineWidth: number;
        /**@private */
        static create(x: number, y: number, points: any[], lineColor: any, lineWidth: number): DrawLinesCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
    }
    /**
     * 绘制粒子
     * @private
     */
    class DrawParticleCmd {
        static ID: string;
        private _templ;
        /**@private */
        static create(_temp: any): DrawParticleCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
    }
    /**
     * 根据路径绘制矢量图形
     */
    class DrawPathCmd {
        static ID: string;
        /**
         * 开始绘制的 X 轴位置。
         */
        x: number;
        /**
         * 开始绘制的 Y 轴位置。
         */
        y: number;
        /**
         * 路径集合，路径支持以下格式：[["moveTo",x,y],["lineTo",x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]]。
         */
        paths: any[] | null;
        /**
         * （可选）刷子定义，支持以下设置{fillStyle:"#FF0000"}。
         */
        brush: any;
        /**
         * （可选）画笔定义，支持以下设置{strokeStyle,lineWidth,lineJoin:"bevel|round|miter",lineCap:"butt|round|square",miterLimit}。
         */
        pen: any;
        /**@private */
        static create(x: number, y: number, paths: any[], brush: any, pen: any): DrawPathCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    /**
     * 绘制扇形
     */
    class DrawPieCmd {
        static ID: string;
        /**
         * 开始绘制的 X 轴位置。
         */
        x: number;
        /**
         * 开始绘制的 Y 轴位置。
         */
        y: number;
        /**
         * 扇形半径。
         */
        radius: number;
        /**
         * 填充颜色，或者填充绘图的渐变对象。
         */
        fillColor: any;
        /**
         * （可选）边框颜色，或者填充绘图的渐变对象。
         */
        lineColor: any;
        /**
         * （可选）边框宽度。
         */
        lineWidth: number;
        private _startAngle;
        private _endAngle;
        /**@private */
        static create(x: number, y: number, radius: number, startAngle: number, endAngle: number, fillColor: any, lineColor: any, lineWidth: number): DrawPieCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
        /**
         * 开始角度。
         */
        get startAngle(): number;
        set startAngle(value: number);
        /**
         * 结束角度。
         */
        get endAngle(): number;
        set endAngle(value: number);
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    /**
     * 绘制多边形
     */
    class DrawPolyCmd {
        static ID: string;
        /**
         * 开始绘制的 X 轴位置。
         */
        x: number;
        /**
         * 开始绘制的 Y 轴位置。
         */
        y: number;
        /**
         * 多边形的点集合。
         */
        points: number[] | null;
        /**
         * 填充颜色，或者填充绘图的渐变对象。
         */
        fillColor: any;
        /**
         * （可选）边框颜色，或者填充绘图的渐变对象。
         */
        lineColor: any;
        /**
         * 可选）边框宽度。
         */
        lineWidth: number;
        /**@private */
        static create(x: number, y: number, points: any[], fillColor: any, lineColor: any, lineWidth: number): DrawPolyCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
    }
    /**
     * 绘制矩形
     */
    class DrawRectCmd {
        static ID: string;
        /**
         * 开始绘制的 X 轴位置。
         */
        x: number;
        /**
         * 开始绘制的 Y 轴位置。
         */
        y: number;
        /**
         * 矩形宽度。
         */
        width: number;
        /**
         * 矩形高度。
         */
        height: number;
        /**
         * 填充颜色，或者填充绘图的渐变对象。
         */
        fillColor: any;
        /**
         * （可选）边框颜色，或者填充绘图的渐变对象。
         */
        lineColor: any;
        /**
         * （可选）边框宽度。
         */
        lineWidth: number;
        /**
         * 位置和大小是否是百分比
         */
        percent: boolean;
        /**@private */
        static create(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number, percent?: boolean): DrawRectCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    class DrawRoundRectCmd {
        static ID: string;
        /**
         * 圆点X 轴位置。
         */
        x: number;
        /**
         * 圆点Y 轴位置。
         */
        y: number;
        /**
         * 横向半径。
         */
        width: number;
        /**
         * 纵向半径。
         */
        height: number;
        /**
         * 左上圆角
         */
        lt: number;
        /**
         * 右上圆角
         */
        rt: number;
        /**
         * 左下圆角
         */
        lb: number;
        /**
         * 右下圆角
         */
        rb: number;
        /**
         * 填充颜色，或者填充绘图的渐变对象。
         */
        fillColor: any;
        /**
         * （可选）边框颜色，或者填充绘图的渐变对象。
         */
        lineColor: any;
        /**
         * （可选）边框宽度。
         */
        lineWidth: number;
        /**
         * 位置和大小是否是百分比
         */
        percent: boolean;
        /**@private */
        static create(x: number, y: number, width: number, height: number, lt: number, rt: number, lb: number, rb: number, fillColor: any, lineColor: any, lineWidth: number, percent?: boolean): DrawRoundRectCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    /**
     * 绘制单个贴图
     */
    class DrawTextureCmd {
        static ID: string;
        /**
         * 纹理。
         */
        texture: Texture | null;
        /**
         * （可选）X轴偏移量。
         */
        x: number;
        /**
         * （可选）Y轴偏移量。
         */
        y: number;
        /**
         * （可选）宽度。
         */
        width: number;
        /**
         * （可选）高度。
         */
        height: number;
        /**
         * （可选）矩阵信息。
         */
        matrix: Matrix | null;
        /**
         * （可选）透明度。
         */
        alpha: number;
        /**
         * （可选）颜色滤镜。
         */
        color: number;
        /**
         * （可选）混合模式。
         */
        blendMode: string | null;
        uv: number[] | null;
        /**@private */
        static create(texture: Texture, x: number, y: number, width: number, height: number, matrix: Matrix | null, alpha: number, color: string | null, blendMode: string | null, uv?: number[]): DrawTextureCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
    }
    /**
     * 根据坐标集合绘制多个贴图
     */
    class DrawTexturesCmd {
        static ID: string;
        /**
         * 纹理。
         */
        texture: Texture;
        /**
         * 绘制次数和坐标。
         */
        pos: ArrayLike<number>;
        /** 附加顶点色 */
        colors: number[];
        /**@private */
        static create(texture: Texture, pos: any[], colors: number[]): DrawTexturesCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
    }
    /**
     * 绘制三角形命令
     */
    class DrawTrianglesCmd {
        static ID: string;
        /**
         * 纹理。
         */
        texture: Texture | null;
        /**
         * X轴偏移量。
         */
        x: number;
        /**
         * Y轴偏移量。
         */
        y: number;
        /**
         * 顶点数组。
         */
        vertices: Float32Array;
        /**
         * UV数据。
         */
        uvs: Float32Array;
        /**
         * 顶点索引。
         */
        indices: Uint16Array;
        /**
         * 缩放矩阵。
         */
        matrix: Matrix | null;
        /**
         * alpha
         */
        alpha: number;
        /**
         * blend模式
         */
        blendMode: string | null;
        /**
         * 颜色变换
         */
        color: number | null;
        /**@private */
        static create(texture: Texture, x: number, y: number, vertices: Float32Array, uvs: Float32Array, indices: Uint16Array, matrix: Matrix | null, alpha: number, color: string | number, blendMode: string | null): DrawTrianglesCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    /**
     * 绘制文字
     */
    class FillTextCmd {
        static ID: string;
        /**
         * 开始绘制文本的 x 坐标位置（相对于画布）。
         */
        x: number;
        /**
         * 开始绘制文本的 y 坐标位置（相对于画布）。
         */
        y: number;
        private _text;
        private _wordText;
        private _font;
        private _color;
        private _strokeColor;
        private _stroke;
        private _align;
        private _fontObj;
        set text(value: string);
        get text(): string;
        set strokeColor(value: string);
        get strokeColor(): string;
        set stroke(value: number);
        get stroke(): number;
        set align(value: number);
        get align(): number;
        static create(text: string | WordText | null, x: number, y: number, font: string, color: string | null, align: string, stroke: number, strokeColor: string | null): FillTextCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
        /**
         * 定义字号和字体，比如"20px Arial"。
         */
        get font(): string;
        set font(value: string);
        /**
         * 定义文本颜色，比如"#ff0000"。
         */
        get color(): string;
        set color(value: string);
    }
    /**
     * 填充贴图
     */
    class FillTextureCmd {
        static ID: string;
        /**
         * 纹理。
         */
        texture: Texture;
        /**
         * X轴偏移量。
         */
        x: number;
        /**
         * Y轴偏移量。
         */
        y: number;
        /**
         * （可选）宽度。
         */
        width: number;
        /**
         * （可选）高度。
         */
        height: number;
        /**
         * （可选）填充类型 repeat|repeat-x|repeat-y|no-repeat
         */
        type?: string;
        /**
         * （可选）贴图纹理偏移
         */
        offset?: Point;
        /**
         * 位置和大小是否是百分比
         */
        percent: boolean;
        /** （可选）绘图颜色 */
        color: number;
        /**@private */
        static create(texture: Texture, x: number, y: number, width: number, height: number, type: string, offset: Point, color: string): FillTextureCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
        getBoundPoints(sp?: {
            width: number;
            height?: number;
        }): number[];
    }
    /**
     * 恢复命令，和save配套使用
     */
    class RestoreCmd {
        static ID: string;
        /**@private */
        static create(): RestoreCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
    }
    /**
     * 旋转命令
     */
    class RotateCmd {
        static ID: string;
        /**
         * 旋转角度，以弧度计。
         */
        angle: number;
        /**
         * （可选）水平方向轴心点坐标。
         */
        pivotX: number;
        /**
         * （可选）垂直方向轴心点坐标。
         */
        pivotY: number;
        /**@private */
        static create(angle: number, pivotX: number, pivotY: number): RotateCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
    }
    /**
     * 存储命令，和restore配套使用
     */
    class SaveCmd {
        static ID: string;
        /**@private */
        static create(): SaveCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
    }
    /**
     * 缩放命令
     */
    class ScaleCmd {
        static ID: string;
        /**
         * 水平方向缩放值。
         */
        scaleX: number;
        /**
         * 垂直方向缩放值。
         */
        scaleY: number;
        /**
         * （可选）水平方向轴心点坐标。
         */
        pivotX: number;
        /**
         * （可选）垂直方向轴心点坐标。
         */
        pivotY: number;
        /**@private */
        static create(scaleX: number, scaleY: number, pivotX: number, pivotY: number): ScaleCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
    }
    /**
     * 矩阵命令
     */
    class TransformCmd {
        static ID: string;
        /**
         * 矩阵。
         */
        matrix: Matrix;
        /**
         * （可选）水平方向轴心点坐标。
         */
        pivotX: number;
        /**
         * （可选）垂直方向轴心点坐标。
         */
        pivotY: number;
        /**@private */
        static create(matrix: Matrix, pivotX: number, pivotY: number): TransformCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
    }
    /**
     * 位移命令
     */
    class TranslateCmd {
        static ID: string;
        /**
         * 添加到水平坐标（x）上的值。
         */
        tx: number;
        /**
         * 添加到垂直坐标（y）上的值。
         */
        ty: number;
        /**@private */
        static create(tx: number, ty: number): TranslateCmd;
        /**
         * 回收到对象池
         */
        recover(): void;
        /**@private */
        run(context: Context, gx: number, gy: number): void;
        /**@private */
        get cmdID(): string;
    }
    /**
     * 元素样式
     */
    class SpriteStyle {
        static readonly EMPTY: Readonly<SpriteStyle>;
        /**水平缩放 */
        scaleX: number;
        /**垂直缩放 */
        scaleY: number;
        /**水平倾斜角度 */
        skewX: number;
        /**垂直倾斜角度 */
        skewY: number;
        /**X轴心点 */
        pivotX: number;
        /**Y轴心点 */
        pivotY: number;
        /**旋转角度 */
        rotation: number;
        /**透明度 */
        alpha: number;
        /**滚动区域 */
        scrollRect: Rectangle;
        /**视口 */
        viewport: Rectangle;
        /**点击区域 */
        hitArea: IHitArea;
        /**滑动 */
        dragging: Dragging;
        /**混合模式 */
        blendMode: string;
        constructor();
        /**
         * 重置，方便下次复用
         */
        reset(): SpriteStyle;
        /**
         * 回收
         */
        recover(): void;
        /**
         * 从对象池中创建
         */
        static create(): SpriteStyle;
    }
    /**
     * 文本的样式类
     */
    class TextStyle {
        /**字体*/
        font: string;
        /**字号*/
        fontSize: number;
        /**文字颜色*/
        color: string;
        /**是否为粗体*/
        bold: boolean;
        /**
         * 表示使用此文本格式的文本是否为斜体。
         * @default false
         */
        italic: boolean;
        /**是否显示下划线*/
        underline: boolean;
        /**下划线颜色*/
        underlineColor: string;
        /**
         * <p>表示使用此文本格式的文本段落的水平对齐方式。</p>
         * @default  "left"
         */
        align: string;
        /**
         * <p>表示使用此文本格式的文本段落的垂直对齐方式。</p>
         * @default  "top"
         */
        valign: string;
        /**
         * 图文混排时图片和文字的对齐方式。可选值是top,middle,bottom
         */
        alignItems: string;
        /**
         * <p>垂直行间距（以像素为单位）</p>
         */
        leading: number;
        /**
         * <p>描边宽度（以像素为单位）。</p>
         * 默认值0，表示不描边。
         * @default 0
         */
        stroke: number;
        /**
         * <p>描边颜色，以字符串表示。</p>
         * @default "#000000";
         */
        strokeColor: string;
        strikethrough: boolean;
        constructor();
    }
    /**
     * <p> 动效模板。用于为指定目标对象添加动画效果。每个动效有唯一的目标对象，而同一个对象可以添加多个动效。 当一个动效开始播放时，其他动效会自动停止播放。</p>
     * <p> 可以通过LayaAir IDE创建。 </p>
     */
    class EffectAnimation extends FrameAnimation {
        /**
         * @private
         * 动效开始事件。
         */
        private static EFFECT_BEGIN;
        /**
         * 本实例的目标对象。通过本实例控制目标对象的属性变化。
         * @param v 指定的目标对象。
         */
        set target(v: any);
        get target(): any;
        /**@private */
        private _onOtherBegin;
        /**
         * 设置开始播放的事件。本实例会侦听目标对象的指定事件，触发后播放相应动画效果。
         * @param event
         */
        set playEvent(event: string);
        /**
         * @param start
         * @param loop
         * @param name
         * @override
         */
        play(start?: any, loop?: boolean, name?: string): void;
        /**@private */
        private _recordInitData;
        /**
         * 设置提供数据的类。
         * @param classStr 类路径
         */
        set effectClass(classStr: string);
        /**
         * 设置动画数据。
         * @param uiData
         */
        set effectData(uiData: any);
        /**
         * @override
        */
        protected _displayNodeToFrame(node: any, frame: number, targetDic?: any): void;
    }
    /**
     * 动画播放完毕后调度。
     * @eventType Event.COMPLETE
     */
    /**
     * 播放到某标签后调度。
     * @eventType Event.LABEL
     */
    /**
     * 节点关键帧动画播放类。解析播放IDE内制作的节点动画。
     */
    class FrameAnimation extends AnimationBase {
        /**@private */
        private static _sortIndexFun;
        /**@private */
        protected _usedFrames: any[];
        constructor();
        /**@inheritDoc
         * @override
        */
        clear(): AnimationBase;
        /**
         * @inheritDoc
         * @override
         */
        protected _displayToIndex(value: number): void;
        /**
         * @private
         * 将节点设置到某一帧的状态
         * @param node 节点ID
         * @param frame
         * @param targetDic 节点表
         */
        protected _displayNodeToFrame(node: any, frame: number, targetDic?: any): void;
        /**
         * @private
         * 计算帧数据
         */
        private _calculateDatas;
        /**
         * @private
         * 计算某个节点的帧数据
         */
        protected _calculateKeyFrames(node: any): void;
        /**
         * 重置节点，使节点恢复到动画之前的状态，方便其他动画控制
         */
        resetNodes(): void;
        /**
         * @private
         * 计算节点某个属性的帧数据
         */
        private _calculateNodePropFrames;
        /**
         * @private
         */
        private _dealKeyFrame;
        /**
         * @private
         * 计算两个关键帧直接的帧数据
         */
        private _calculateFrameValues;
    }
    /**
     * Graphics动画解析器
     * @private
     */
    class GraphicAnimation extends FrameAnimation {
        /**@private */
        animationList: any[];
        /**@private */
        animationDic: any;
        /**@private */
        protected _nodeList: any[];
        /**@private */
        protected _nodeDefaultProps: any;
        /**@private */
        protected _gList: any[];
        /**@private */
        protected _nodeIDAniDic: any;
        /**@private */
        protected static _drawTextureCmd: any[];
        /**@private */
        protected static _temParam: any[];
        /**@private */
        private static _I;
        /**@private */
        private static _rootMatrix;
        /**@private */
        private _rootNode;
        /**@private */
        protected _nodeGDic: any;
        /**@private */
        private _parseNodeList;
        /**@private */
        private _calGraphicData;
        /**@private */
        private _createGraphicData;
        /**@private */
        protected _createFrameGraphic(frame: number): any;
        protected _updateNodeGraphic(node: any, frame: number, parentTransfrom: Matrix, g: Graphics, alpha?: number): void;
        protected _updateNodeGraphic2(node: any, frame: number, g: Graphics): void;
        /**
         * @private
         * @override
        */
        protected _calculateKeyFrames(node: any): void;
        /**@private */
        protected getNodeDataByID(nodeID: number): any;
        /**@private */
        protected _getParams(obj: any, params: any[], frame: number, obj2: any): any[];
        /**@private */
        private _getObjVar;
        private static _tempMt;
        /**@private */
        protected _getTextureByUrl(url: string): any;
        /**@private */
        setAniData(uiView: any, aniName?: string): void;
        parseByData(aniData: any): any;
        /**@private */
        setUpAniData(uiView: any): void;
        /**@private */
        protected _clear(): void;
        static parseAnimationByData(animationObject: any): any;
        static parseAnimationData(aniData: any): any;
    }
    /**
     * <code>Graphics</code> 类用于创建绘图显示对象。Graphics可以同时绘制多个位图或者矢量图，还可以结合save，restore，transform，scale，rotate，translate，alpha等指令对绘图效果进行变化。
     * Graphics以命令流方式存储，可以通过cmds属性访问所有命令流。Graphics是比Sprite更轻量级的对象，合理使用能提高应用性能(比如把大量的节点绘图改为一个节点的Graphics命令集合，能减少大量节点创建消耗)。
     * @see laya.display.Sprite#graphics
     */
    class Graphics {
        /**
         * add global Uniform Data Map
         * @param propertyID
         * @param propertyKey
         * @param uniformtype
         */
        static add2DGlobalUniformData(propertyID: number, propertyKey: string, uniformtype: ShaderDataType): void;
        /**@private */
        private _cmds;
        /**@private */
        protected _vectorgraphArray: any[] | null;
        /**@private */
        private _graphicBounds;
        private _material;
        constructor();
        /**
         * <p>销毁此对象。</p>
         */
        destroy(): void;
        /**
         * <p>清空绘制命令。</p>
         * @param recoverCmds 是否回收绘图指令数组，设置为true，则对指令数组进行回收以节省内存开销，建议设置为true进行回收，但如果手动引用了数组，不建议回收
         */
        clear(recoverCmds?: boolean): void;
        /**@private */
        _clearBoundsCache(onSizeChanged?: boolean): void;
        /**@private */
        private _initGraphicBounds;
        /**
         * 命令流。存储了所有绘制命令。
         */
        get cmds(): any[];
        set cmds(value: any[]);
        /**
         * 保存到命令流。
         */
        addCmd(cmd: any): any;
        removeCmd(cmd: any): void;
        /**
         * 获取位置及宽高信息矩阵(比较耗CPU，频繁使用会造成卡顿，尽量少用)。
         * @param realSize	（可选）使用图片的真实大小，默认为false
         * @return 位置与宽高组成的 一个 Rectangle 对象。
         */
        getBounds(realSize?: boolean): Rectangle;
        /**
         * @private
         * @param realSize	（可选）使用图片的真实大小，默认为false
         * 获取端点列表。
         */
        getBoundPoints(realSize?: boolean): any[];
        /**
         *
         */
        get material(): Material;
        /**
         *
         */
        set material(value: Material);
        /**
         * 绘制单独图片
         * @param texture		纹理。
         * @param x 		（可选）X轴偏移量。
         * @param y 		（可选）Y轴偏移量。
         * @param width		（可选）宽度。
         * @param height	（可选）高度。
         * @param color	 	 （可选）颜色
         */
        drawImage(texture: Texture, x?: number, y?: number, width?: number, height?: number, color?: string): DrawImageCmd | null;
        /**
         * 绘制纹理，相比drawImage功能更强大，性能会差一些
         * @param texture		纹理。
         * @param x 		（可选）X轴偏移量。
         * @param y 		（可选）Y轴偏移量。
         * @param width		（可选）宽度。
         * @param height	（可选）高度。
         * @param matrix	（可选）矩阵信息。
         * @param alpha		（可选）透明度。
         * @param color		（可选）颜色滤镜。
         * @param blendMode （可选）混合模式。
         */
        drawTexture(texture: Texture | null, x?: number, y?: number, width?: number, height?: number, matrix?: Matrix | null, alpha?: number, color?: string | null, blendMode?: string | null, uv?: number[]): DrawTextureCmd | null;
        /**
         * 批量绘制同样纹理。
         * @param texture 纹理。
         * @param pos 绘制次数和坐标。
         * @param colors 图片颜色数组。
         */
        drawTextures(texture: Texture, pos: any[], colors?: number[]): DrawTexturesCmd | null;
        /**
         * 绘制一组三角形
         * @param texture	纹理。
         * @param x			X轴偏移量。
         * @param y			Y轴偏移量。
         * @param vertices  顶点数组。
         * @param indices	顶点索引。
         * @param uvData	UV数据。
         * @param matrix	缩放矩阵。
         * @param alpha		alpha
         * @param color		颜色变换
         * @param blendMode	blend模式
         */
        drawTriangles(texture: Texture, x: number, y: number, vertices: Float32Array, uvs: Float32Array, indices: Uint16Array, matrix?: Matrix | null, alpha?: number, color?: string | number, blendMode?: string | null): DrawTrianglesCmd;
        /**
         * 用 texture 填充。
         * @param texture		纹理。
         * @param x			X轴偏移量。
         * @param y			Y轴偏移量。
         * @param width		（可选）宽度。
         * @param height	（可选）高度。
         * @param type		（可选）填充类型 repeat|repeat-x|repeat-y|no-repeat
         * @param offset	（可选）贴图纹理偏移
         * @param color	 	 （可选）颜色
         *
         */
        fillTexture(texture: Texture, x: number, y: number, width?: number, height?: number, type?: string, offset?: Point | null, color?: string): FillTextureCmd | null;
        /**
         * 设置剪裁区域，超出剪裁区域的坐标不显示。
         * @param x X 轴偏移量。
         * @param y Y 轴偏移量。
         * @param width 宽度。
         * @param height 高度。
         */
        clipRect(x: number, y: number, width: number, height: number): ClipRectCmd;
        /**
         * 在画布上绘制文本。
         * @param text 在画布上输出的文本。
         * @param x 开始绘制文本的 x 坐标位置（相对于画布）。
         * @param y 开始绘制文本的 y 坐标位置（相对于画布）。
         * @param font 定义字号和字体，比如"20px Arial"。
         * @param color 定义文本颜色，比如"#ff0000"。
         * @param textAlign 文本对齐方式，可选值："left"，"center"，"right"。
         */
        fillText(text: string | WordText, x: number, y: number, font: string, color: string, textAlign: string): FillTextCmd;
        /**
         * 在画布上绘制“被填充且镶边的”文本。
         * @param text			在画布上输出的文本。
         * @param x				开始绘制文本的 x 坐标位置（相对于画布）。
         * @param y				开始绘制文本的 y 坐标位置（相对于画布）。
         * @param font			定义字体和字号，比如"20px Arial"。
         * @param fillColor		定义文本颜色，比如"#ff0000"。
         * @param textAlign		文本对齐方式，可选值："left"，"center"，"right"。
         * @param lineWidth		镶边线条宽度。
         * @param borderColor	定义镶边文本颜色。
         */
        fillBorderText(text: string | WordText, x: number, y: number, font: string, fillColor: string, textAlign: string, lineWidth: number, borderColor: string): FillTextCmd;
        /**
         * 在画布上绘制文本（没有填色）。文本的默认颜色是黑色。
         * @param text		在画布上输出的文本。
         * @param x			开始绘制文本的 x 坐标位置（相对于画布）。
         * @param y			开始绘制文本的 y 坐标位置（相对于画布）。
         * @param font		定义字体和字号，比如"20px Arial"。
         * @param color		定义文本颜色，比如"#ff0000"。
         * @param lineWidth	线条宽度。
         * @param textAlign	文本对齐方式，可选值："left"，"center"，"right"。
         */
        strokeText(text: string | WordText, x: number, y: number, font: string, color: string, lineWidth: number, textAlign: string): FillTextCmd;
        /**
         * 设置透明度。
         * @param value 透明度。
         */
        alpha(alpha: number): AlphaCmd;
        /**
         * 替换绘图的当前转换矩阵。
         * @param mat 矩阵。
         * @param pivotX	（可选）水平方向轴心点坐标。
         * @param pivotY	（可选）垂直方向轴心点坐标。
         */
        transform(matrix: Matrix, pivotX?: number, pivotY?: number): TransformCmd;
        /**
         * 旋转当前绘图。(推荐使用transform，性能更高)
         * @param angle		旋转角度，以弧度计。
         * @param pivotX	（可选）水平方向轴心点坐标。
         * @param pivotY	（可选）垂直方向轴心点坐标。
         */
        rotate(angle: number, pivotX?: number, pivotY?: number): RotateCmd;
        /**
         * 缩放当前绘图至更大或更小。(推荐使用transform，性能更高)
         * @param scaleX	水平方向缩放值。
         * @param scaleY	垂直方向缩放值。
         * @param pivotX	（可选）水平方向轴心点坐标。
         * @param pivotY	（可选）垂直方向轴心点坐标。
         */
        scale(scaleX: number, scaleY: number, pivotX?: number, pivotY?: number): ScaleCmd;
        /**
         * 重新映射画布上的 (0,0) 位置。
         * @param x 添加到水平坐标（x）上的值。
         * @param y 添加到垂直坐标（y）上的值。
         */
        translate(tx: number, ty: number): TranslateCmd;
        /**
         * 保存当前环境的状态。
         */
        save(): SaveCmd;
        /**
         * 返回之前保存过的路径状态和属性。
         */
        restore(): RestoreCmd;
        /**
         * @private
         * 替换文本颜色。
         * @param color 颜色。
         */
        replaceTextColor(color: string): void;
        /**
         * 加载并显示一个图片。
         * @param url		图片地址。
         * @param x			（可选）显示图片的x位置。
         * @param y			（可选）显示图片的y位置。
         * @param width		（可选）显示图片的宽度，设置为0表示使用图片默认宽度。
         * @param height	（可选）显示图片的高度，设置为0表示使用图片默认高度。
         * @param complete	（可选）加载完成回调。
         */
        loadImage(url: string, x?: number, y?: number, width?: number, height?: number, complete?: Function | null): void;
        /**
         * 绘制一条线。
         * @param fromX		X轴开始位置。
         * @param fromY		Y轴开始位置。
         * @param toX		X轴结束位置。
         * @param toY		Y轴结束位置。
         * @param lineColor	颜色。
         * @param lineWidth	（可选）线条宽度。
         */
        drawLine(fromX: number, fromY: number, toX: number, toY: number, lineColor: string, lineWidth?: number): DrawLineCmd;
        /**
         * 绘制一系列线段。
         * @param x			开始绘制的X轴位置。
         * @param y			开始绘制的Y轴位置。
         * @param points	线段的点集合。格式:[x1,y1,x2,y2,x3,y3...]。
         * @param lineColor	线段颜色，或者填充绘图的渐变对象。
         * @param lineWidth	（可选）线段宽度。
         */
        drawLines(x: number, y: number, points: any[], lineColor: any, lineWidth?: number): DrawLinesCmd | null;
        /**
         * 绘制一系列曲线。
         * @param x			开始绘制的 X 轴位置。
         * @param y			开始绘制的 Y 轴位置。
         * @param points	线段的点集合，格式[controlX, controlY, anchorX, anchorY...]。
         * @param lineColor	线段颜色，或者填充绘图的渐变对象。
         * @param lineWidth	（可选）线段宽度。
         */
        drawCurves(x: number, y: number, points: any[], lineColor: any, lineWidth?: number): DrawCurvesCmd;
        /**
         * 绘制矩形。
         * @param x			开始绘制的 X 轴位置。
         * @param y			开始绘制的 Y 轴位置。
         * @param width		矩形宽度。
         * @param height	矩形高度。
         * @param fillColor	填充颜色，或者填充绘图的渐变对象。
         * @param lineColor	（可选）边框颜色，或者填充绘图的渐变对象。
         * @param lineWidth	（可选）边框宽度。
         * @param percent 位置和大小是否是百分比值。
         */
        drawRect(x: number, y: number, width: number, height: number, fillColor: any, lineColor?: any, lineWidth?: number, percent?: boolean): DrawRectCmd;
        /**
         * 绘制圆角矩形
         * @param x             开始绘制的 X 轴位置。
         * @param y             开始绘制的 Y 轴位置。
         * @param width         圆角矩形宽度。
         * @param height        圆角矩形高度。
         * @param lt            左上圆角
         * @param rt            右上圆角
         * @param lb            左下圆角
         * @param rb            右下圆角
         * @param fillColor     填充颜色，或者填充绘图的渐变对象。
         * @param lineColor     （可选）边框颜色，或者填充绘图的渐变对象。
         * @param lineWidth     （可选）边框宽度。
         * @param percent       （可选）位置和大小是否是百分比值。
         * @returns
         */
        drawRoundRect(x: number, y: number, width: number, height: number, lt: number, rt: number, lb: number, rb: number, fillColor: any, lineColor?: any, lineWidth?: number, percent?: boolean): any;
        /**
         * 绘制圆形。
         * @param x			圆点X 轴位置。
         * @param y			圆点Y 轴位置。
         * @param radius	半径。
         * @param fillColor	填充颜色，或者填充绘图的渐变对象。
         * @param lineColor	（可选）边框颜色，或者填充绘图的渐变对象。
         * @param lineWidth	（可选）边框宽度。
         */
        drawCircle(x: number, y: number, radius: number, fillColor: any, lineColor?: any, lineWidth?: number): DrawCircleCmd;
        /**
         * 绘制椭圆形
         * @param x         圆点X 轴位置。
         * @param y         圆点Y 轴位置。
         * @param width     横向半径。
         * @param height    纵向半径。
         * @param fillColor 填充颜色，或者填充绘图的渐变对象。
         * @param lineColor （可选）边框颜色，或者填充绘图的渐变对象。
         * @param lineWidth （可选）边框宽度。
         * @param percent   （可选）位置和大小是否是百分比值。
         */
        drawEllipse(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number, percent?: boolean): DrawEllipseCmd;
        /**
         * 绘制扇形。
         * @param x				开始绘制的 X 轴位置。
         * @param y				开始绘制的 Y 轴位置。
         * @param radius		扇形半径。
         * @param startAngle	开始角度。
         * @param endAngle		结束角度。
         * @param fillColor		填充颜色，或者填充绘图的渐变对象。
         * @param lineColor		（可选）边框颜色，或者填充绘图的渐变对象。
         * @param lineWidth		（可选）边框宽度。
         */
        drawPie(x: number, y: number, radius: number, startAngle: number, endAngle: number, fillColor: any, lineColor?: any, lineWidth?: number): DrawPieCmd;
        /**
         * 绘制多边形。
         * @param x			开始绘制的 X 轴位置。
         * @param y			开始绘制的 Y 轴位置。
         * @param points	多边形的点集合。
         * @param fillColor	填充颜色，或者填充绘图的渐变对象。
         * @param lineColor	（可选）边框颜色，或者填充绘图的渐变对象。
         * @param lineWidth	（可选）边框宽度。
         */
        drawPoly(x: number, y: number, points: any[], fillColor: any, lineColor?: any, lineWidth?: number): DrawPolyCmd;
        /**
         * 绘制路径。
         * @param x		开始绘制的 X 轴位置。
         * @param y		开始绘制的 Y 轴位置。
         * @param paths	路径集合，路径支持以下格式：[["moveTo",x,y],["lineTo",x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]]。
         * @param brush	（可选）刷子定义，支持以下设置{fillStyle:"#FF0000"}。
         * @param pen	（可选）画笔定义，支持以下设置{strokeStyle,lineWidth,lineJoin:"bevel|round|miter",lineCap:"butt|round|square",miterLimit}。
         */
        drawPath(x: number, y: number, paths: any[], brush?: any, pen?: any): DrawPathCmd;
        /**
         * @private
         * 绘制带九宫格的图片
         * @param	texture
         * @param	x
         * @param	y
         * @param	width
         * @param	height
         * @param	sizeGrid
         * @param	color
         */
        draw9Grid(texture: Texture, x: number, y: number, width: number, height: number, sizeGrid: any[], color?: string): void;
    }
    /**
     * @private
     * Graphic bounds数据类
     */
    class GraphicsBounds {
        /**@private */
        private _temp;
        /**@private */
        private _bounds;
        /**@private */
        private _rstBoundPoints;
        /**@private */
        private _cacheBoundsType;
        /**
         * 销毁
         */
        destroy(): void;
        /**
         * 创建
         */
        static create(): GraphicsBounds;
        /**
         * 重置数据
         */
        reset(): void;
        /**
         * 获取位置及宽高信息矩阵(比较耗CPU，频繁使用会造成卡顿，尽量少用)。
         * @param realSize	（可选）使用图片的真实大小，默认为false
         * @return 位置与宽高组成的 一个 Rectangle 对象。
         */
        getBounds(realSize?: boolean): Rectangle;
        /**
         * @private
         * @param realSize	（可选）使用图片的真实大小，默认为false
         * 获取端点列表。
         */
        getBoundPoints(realSize?: boolean): any[];
        private _getCmdPoints;
        private _switchMatrix;
    }
    /**
     * 用户输入一个或多个文本字符时后调度。
     * @eventType Event.INPUT
     * */
    /**
     * 文本发生变化后调度。
     * @eventType Event.CHANGE
     * */
    /**
     * 用户在输入框内敲回车键后，将会调度 <code>enter</code> 事件。
     * @eventType Event.ENTER
     * */
    /**
     * 显示对象获得焦点后调度。
     * @eventType Event.FOCUS
     * */
    /**
     * 显示对象失去焦点后调度。
     * @eventType Event.BLUR
     * */
    /**
     * <p><code>Input</code> 类用于创建显示对象以显示和输入文本。</p>
     * <p>Input 类封装了原生的文本输入框，由于不同浏览器的差异，会导致此对象的默认文本的位置与用户点击输入时的文本的位置有少许的偏差。</p>
     */
    class Input extends Text {
        /** 常规文本域。*/
        static TYPE_TEXT: string;
        /** password 类型用于密码域输入。*/
        static TYPE_PASSWORD: string;
        /** email 类型用于应该包含 e-mail 地址的输入域。*/
        static TYPE_EMAIL: string;
        /** url 类型用于应该包含 URL 地址的输入域。*/
        static TYPE_URL: string;
        /** number 类型用于应该包含数值的输入域。*/
        static TYPE_NUMBER: string;
        /**
         * <p>range 类型用于应该包含一定范围内数字值的输入域。</p>
         * <p>range 类型显示为滑动条。</p>
         * <p>您还能够设定对所接受的数字的限定。</p>
         */
        static TYPE_RANGE: string;
        /**  选取日、月、年。*/
        static TYPE_DATE: string;
        /** month - 选取月、年。*/
        static TYPE_MONTH: string;
        /** week - 选取周和年。*/
        static TYPE_WEEK: string;
        /** time - 选取时间（小时和分钟）。*/
        static TYPE_TIME: string;
        /** datetime - 选取时间、日、月、年（UTC 时间）。*/
        static TYPE_DATE_TIME: string;
        /** datetime-local - 选取时间、日、月、年（本地时间）。*/
        static TYPE_DATE_TIME_LOCAL: string;
        /**
         * <p>search 类型用于搜索域，比如站点搜索或 Google 搜索。</p>
         * <p>search 域显示为常规的文本域。</p>
         */
        static TYPE_SEARCH: string;
        /**@private */
        protected static input: HTMLInputElement;
        /**@private */
        protected static area: HTMLTextAreaElement;
        /**@private */
        protected static inputElement: HTMLInputElement | HTMLTextAreaElement;
        /**@private */
        protected static inputContainer: HTMLDivElement;
        /**@private */
        protected static confirmButton: any;
        /**@private */
        protected static promptStyleDOM: any;
        protected _focus: boolean;
        protected _multiline: boolean;
        protected _editable: boolean;
        protected _restrict: string;
        protected _restrictPattern: any;
        protected _maxChars: number;
        private _type;
        /**@private */
        static IOS_IFRAME: boolean;
        static isAppUseNewInput: boolean;
        /**创建一个新的 <code>Input</code> 类实例。*/
        constructor();
        private static _popupInputMethod;
        private static _createInputElement;
        private static _initInput;
        private static _processInputting;
        private static _stopEvent;
        /**
         * 设置光标位置和选取字符。
         * @param	startIndex	光标起始位置。
         * @param	endIndex	光标结束位置。
         */
        setSelection(startIndex: number, endIndex: number): void;
        /**表示是否是多行输入框。*/
        get multiline(): boolean;
        set multiline(value: boolean);
        /**
         * 获取对输入框的引用实例。
         */
        get nativeInput(): HTMLInputElement | HTMLTextAreaElement;
        private _onUnDisplay;
        private _onMouseDown;
        /**
         * 在输入期间，如果 Input 实例的位置改变，调用_syncInputTransform同步输入框的位置。
         */
        private _syncInputTransform;
        /**选中当前实例的所有文本。*/
        select(): void;
        /**
         * 表示焦点是否在此实例上。
         */
        get focus(): boolean;
        set focus(value: boolean);
        private _setInputMethod;
        private _focusIn;
        private _setPromptColor;
        /**@private */
        private _focusOut;
        /**@private */
        private _onKeyDown;
        /**
         * 小游戏专用(解决键盘输入框内容和游戏输入框内容不同步的bug)
         * @param value
         */
        miniGameTxt(value: string): void;
        /**@inheritDoc
         * @override
        */
        set text(value: string);
        /**
         * @override
         */
        get text(): string;
        /**@inheritDoc
         * @override
        */
        set_color(value: string): void;
        /**@inheritDoc
         * @override
        */
        set bgColor(value: string);
        get bgColor(): string;
        /**限制输入的字符。*/
        get restrict(): string;
        set restrict(value: string);
        /**
         * 是否可编辑。
         */
        set editable(value: boolean);
        get editable(): boolean;
        /**
         * <p>字符数量限制，默认为10000。</p>
         * <p>设置字符数量限制时，小于等于0的值将会限制字符数量为10000。</p>
         */
        get maxChars(): number;
        set maxChars(value: number);
        /**
         * 设置输入提示符。
         */
        get prompt(): string;
        set prompt(value: string);
        /**
         * 设置输入提示符颜色。
         */
        get promptColor(): string;
        set promptColor(value: string);
        /**
         * <p>输入框类型为Input静态常量之一。</p>
         * <ul>
         * <li>TYPE_TEXT</li>
         * <li>TYPE_PASSWORD</li>
         * <li>TYPE_EMAIL</li>
         * <li>TYPE_URL</li>
         * <li>TYPE_NUMBER</li>
         * <li>TYPE_RANGE</li>
         * <li>TYPE_DATE</li>
         * <li>TYPE_MONTH</li>
         * <li>TYPE_WEEK</li>
         * <li>TYPE_TIME</li>
         * <li>TYPE_DATE_TIME</li>
         * <li>TYPE_DATE_TIME_LOCAL</li>
         * </ul>
         * <p>平台兼容性参见http://www.w3school.com.cn/html5/html_5_form_input_types.asp。</p>
         */
        get type(): string;
        set type(value: string);
    }
    /**
     * 添加到父对象后调度。
     * @eventType Event.ADDED
     */
    /**
     * 被父对象移除后调度。
     * @eventType Event.REMOVED
     */
    /**
     * 加入节点树时调度。
     * @eventType Event.DISPLAY
     */
    /**
     * 从节点树移除时调度。
     * @eventType Event.UNDISPLAY
     */
    /**
     *  <code>Node</code> 类是可放在显示列表中的所有对象的基类。该显示列表管理 Laya 运行时中显示的所有对象。使用 Node 类排列显示列表中的显示对象。Node 对象可以有子显示对象。
     */
    class Node extends EventDispatcher {
        static EVENT_SET_ACTIVESCENE: string;
        static EVENT_SET_IN_ACTIVESCENE: string;
        /**@private */
        private _bits;
        /**@private */
        private _hideFlags;
        _url: string;
        _extra: INodeExtra;
        /**节点名称。*/
        name: string;
        /** 节点标签 */
        tag: string;
        /**
         * 如果节点从资源中创建，这里记录是他的url
         */
        get url(): string;
        /**
         * 设置资源的URL
         */
        set url(path: string);
        get hideFlags(): number;
        set hideFlags(value: number);
        /** 是否3D节点，即Scene3D和Sprite3D及其衍生类 */
        get is3D(): boolean;
        /** 是否已经销毁。对象销毁后不能再使用。*/
        get destroyed(): boolean;
        constructor();
        _setBit(type: number, value: boolean): void;
        _getBit(type: number): boolean;
        protected onStartListeningToType(type: string): void;
        bubbleEvent(type: string, data?: any): void;
        hasHideFlag(flag: number): boolean;
        /**
         * <p>销毁此对象。destroy对象默认会把自己从父节点移除，并且清理自身引用关系，等待js自动垃圾回收机制回收。destroy后不能再使用。</p>
         * <p>destroy时会移除自身的事情监听，自身的timer监听，移除子对象及从父节点移除自己。</p>
         * @param destroyChild	（可选）是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
         */
        destroy(destroyChild?: boolean): void;
        /**
         * 销毁时执行
         * 此方法为虚方法，使用时重写覆盖即可
         */
        onDestroy(): void;
        /**
         * 销毁所有子对象，不销毁自己本身。
         */
        destroyChildren(): void;
        /**
         * 添加子节点。
         * @param	node 节点对象
         * @return	返回添加的节点
         */
        addChild<T extends Node>(node: T): T;
        /**
         * 批量增加子节点
         * @param	...args 无数子节点。
         */
        addChildren(...args: any[]): void;
        /**
         * 添加子节点到指定的索引位置。
         * @param	node 节点对象。
         * @param	index 索引位置。
         * @return	返回添加的节点。
         */
        addChildAt(node: Node, index: number): Node;
        /**
         * 根据子节点对象，获取子节点的索引位置。
         * @param	node 子节点。
         * @return	子节点所在的索引位置。
         */
        getChildIndex(node: Node): number;
        /**
         * 根据子节点的名字，获取子节点对象。
         * @param	name 子节点的名字。
         * @return	节点对象。
         */
        getChildByName(name: string): Node;
        /**
         * 根据子节点的索引位置，获取子节点对象。
         * @param	index 索引位置
         * @return	子节点
         */
        getChildAt(index: number): Node;
        /**
         * 设置子节点的索引位置。
         * @param	node 子节点。
         * @param	index 新的索引。
         * @return	返回子节点本身。
         */
        setChildIndex(node: Node, index: number): Node;
        /**
         * 子节点发生改变。
         * @private
         * @param	child 子节点。
         */
        protected _childChanged(child?: Node): void;
        /**
         * 删除子节点。
         * @param	node 子节点
         * @return	被删除的节点
         */
        removeChild(node: Node): Node;
        /**
         * 从父容器删除自己，如已经被删除不会抛出异常。
         * @return 当前节点（ Node ）对象。
         */
        removeSelf(): Node;
        /**
         * 根据子节点名字删除对应的子节点对象，如果找不到不会抛出异常。
         * @param	name 对象名字。
         * @return 查找到的节点（ Node ）对象。
         */
        removeChildByName(name: string): Node;
        /**
         * 根据子节点索引位置，删除对应的子节点对象。
         * @param	index 节点索引位置。
         * @return	被删除的节点。
         */
        removeChildAt(index: number): Node;
        /**
         * 删除指定索引区间的所有子对象。
         * @param	beginIndex 开始索引。
         * @param	endIndex 结束索引。
         * @return 当前节点对象。
         */
        removeChildren(beginIndex?: number, endIndex?: number): Node;
        /**
         * 替换子节点。
         * 将传入的新节点对象替换到已有子节点索引位置处。
         * @param	newNode 新节点。
         * @param	oldNode 老节点。
         * @return	返回新节点。
         */
        replaceChild(newNode: Node, oldNode: Node): Node;
        /**
         * 子对象数量。
         */
        get numChildren(): number;
        /**父节点。*/
        get parent(): Node;
        /**检查本节点是否是某个节点的上层节点
         * @param node
         * @return
         */
        isAncestorOf(node: Node): boolean;
        /**@private */
        protected _setParent(value: Node): void;
        /**表示是否在显示列表中显示。*/
        get displayedInStage(): boolean;
        /**@private */
        private _updateDisplayedInstage;
        /**
         * 设置指定节点对象是否可见(是否在渲染列表中)。
         * @private
         * @param	node 节点。
         * @param	display 是否可见。
         */
        private _displayChild;
        /**
         * 当前容器是否包含指定的 <code>Node</code> 节点对象 。
         * @param	node  指定的 <code>Node</code> 节点对象 。
         * @return	一个布尔值表示是否包含指定的 <code>Node</code> 节点对象 。
         */
        contains(node: Node): boolean;
        /**
         * 定时重复执行某函数。功能同Laya.timer.timerLoop()。
         * @param	delay		间隔时间(单位毫秒)。
         * @param	caller		执行域(this)。
         * @param	method		结束时的回调方法。
         * @param	args		（可选）回调参数。
         * @param	coverBefore	（可选）是否覆盖之前的延迟执行，默认为true。
         * @param	jumpFrame 时钟是否跳帧。基于时间的循环回调，单位时间间隔内，如能执行多次回调，出于性能考虑，引擎默认只执行一次，设置jumpFrame=true后，则回调会连续执行多次
         */
        timerLoop(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean, jumpFrame?: boolean): void;
        /**
         * 定时执行某函数一次。功能同Laya.timer.timerOnce()。
         * @param	delay		延迟时间(单位毫秒)。
         * @param	caller		执行域(this)。
         * @param	method		结束时的回调方法。
         * @param	args		（可选）回调参数。
         * @param	coverBefore	（可选）是否覆盖之前的延迟执行，默认为true。
         */
        timerOnce(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * 定时重复执行某函数(基于帧率)。功能同Laya.timer.frameLoop()。
         * @param	delay		间隔几帧(单位为帧)。
         * @param	caller		执行域(this)。
         * @param	method		结束时的回调方法。
         * @param	args		（可选）回调参数。
         * @param	coverBefore	（可选）是否覆盖之前的延迟执行，默认为true。
         */
        frameLoop(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * 定时执行一次某函数(基于帧率)。功能同Laya.timer.frameOnce()。
         * @param	delay		延迟几帧(单位为帧)。
         * @param	caller		执行域(this)
         * @param	method		结束时的回调方法
         * @param	args		（可选）回调参数
         * @param	coverBefore	（可选）是否覆盖之前的延迟执行，默认为true
         */
        frameOnce(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * 清理定时器。功能同Laya.timer.clearTimer()。
         * @param	caller 执行域(this)。
         * @param	method 结束时的回调方法。
         */
        clearTimer(caller: any, method: Function): void;
        /**
         * <p>延迟运行指定的函数。</p>
         * <p>在控件被显示在屏幕之前调用，一般用于延迟计算数据。</p>
         * @param method 要执行的函数的名称。例如，functionName。
         * @param args 传递给 <code>method</code> 函数的可选参数列表。
         *
         * @see #runCallLater()
         */
        callLater(method: Function, args?: any[]): void;
        /**
         * <p>如果有需要延迟调用的函数（通过 <code>callLater</code> 函数设置），则立即执行延迟调用函数。</p>
         * @param method 要执行的函数名称。例如，functionName。
         * @see #callLater()
         */
        runCallLater(method: Function): void;
        /** @private */
        protected _components: Component[];
        /**@private */
        private _activeChangeScripts;
        _scene: Node;
        /**
         * 获得所属场景。
         * @return	场景。
         */
        get scene(): any;
        /**
         * 获取自身是否激活。
         *   @return	自身是否激活。
         */
        get active(): boolean;
        /**
         * 设置是否激活。
         * @param	value 是否激活。
         */
        set active(value: boolean);
        /**
         * 获取在场景中是否激活。
         *   @return	在场景中是否激活。
         */
        get activeInHierarchy(): boolean;
        /**
         * @private
         */
        protected _onActive(): void;
        /**
         * @private
         */
        protected _onInActive(): void;
        /**
         * @private
         */
        protected _onActiveInScene(): void;
        /**
         * @private
         */
        protected _onInActiveInScene(): void;
        /**
        * 组件被激活后执行，此时所有节点和组件均已创建完毕，次方法只执行一次
        * 此方法为虚方法，使用时重写覆盖即可
        */
        onAwake(): void;
        /**
         * 组件被启用后执行，比如节点被添加到舞台后
         * 此方法为虚方法，使用时重写覆盖即可
         */
        onEnable(): void;
        /**
         * 组件被禁用时执行，比如从节点从舞台移除后
         * 此方法为虚方法，使用时重写覆盖即可
         */
        onDisable(): void;
        _processActive(active: boolean, fromSetter?: boolean): void;
        /**
         * @private
         */
        protected _onAdded(): void;
        /**
         * @private
         */
        protected _onRemoved(): void;
        /**
         * 组件列表发生改变。
         * @private
         */
        protected _componentsChanged?(comp: Component, action: 0 | 1 | 2): void;
        /**
         * 添加组件实例。
         * @param	component 组建实例。
         * @return	组件。
         */
        addComponentInstance(component: Component): Component;
        /**
         * 添加组件。
         * @param	componentType 组件类型。
         * @return	组件。
         */
        addComponent<T extends Component>(componentType: new () => T): T;
        /**
         * 获得组件实例，如果没有则返回为null
         * @param	componentType 组建类型
         * @return	返回组件
         */
        getComponent<T extends Component>(componentType: new () => T): T;
        /**
         * 返回所有组件实例。
         * @return 返回组件实例数组。
         */
        get components(): ReadonlyArray<Component>;
        /**
         * 获得组件实例，如果没有则返回为null
         * @param	componentType 组件类型
         * @return	返回组件数组
         */
        getComponents(componentType: typeof Component): Component[];
        /**
         * 获取timer
         */
        get timer(): Timer;
        /**
         * 反序列化后会调用
         */
        onAfterDeserialize(): void;
    }
    interface INodeExtra {
    }
    /**
     * 场景类，负责场景创建，加载，销毁等功能
     * 场景被从节点移除后，并不会被自动垃圾机制回收，如果想回收，请调用destroy接口，可以通过unDestroyedScenes属性查看还未被销毁的场景列表
     */
    class Scene extends Sprite {
        /**创建后，还未被销毁的场景列表，方便查看还未被销毁的场景列表，方便内存管理，本属性只读，请不要直接修改*/
        static readonly unDestroyedScenes: Set<Scene>;
        /**获取根节点*/
        private static _root;
        /**@private */
        private static _loadPage;
        /**场景被关闭后，是否自动销毁（销毁节点和使用到的资源），默认为false*/
        autoDestroyAtClosed: boolean;
        _scene3D: any;
        /**@private 相对布局组件*/
        protected _widget: Widget;
        /**场景时钟*/
        private _timer;
        /**@private */
        private _viewCreated;
        constructor(createChildren?: boolean);
        /**
         * @private 兼容老项目
         */
        protected createChildren(): void;
        /**
         * 兼容加载模式
         * 加载模式设置uimap
         * @param url uimapJosn的url
         */
        static setUIMap(url: string): void;
        /**
         * @private 兼容老项目
         * 装载场景视图。用于加载模式。
         * @param path 场景地址。
         */
        loadScene(path: string): void;
        /**
         * @private 兼容老项目
         * 通过视图数据创建视图。
         * @param uiView 视图数据信息。
         */
        createView(view: any): void;
        /**
        * 根据IDE内的节点id，获得节点实例
        */
        getNodeByID(id: number): any;
        /**
         * 打开场景。【注意】被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收
         * @param	closeOther	是否关闭其他场景，默认为true（可选）
         * @param	param		打开页面的参数，会传递给onOpened方法（可选）
         */
        open(closeOther?: boolean, param?: any): void;
        /**场景打开完成后，调用此方法（如果有弹出动画，则在动画完成后执行）*/
        onOpened(param: any): void;
        /**
         * 关闭场景
         * 【注意】被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收
         * @param type 关闭的原因，会传递给onClosed函数
         */
        close(type?: string): void;
        /**
         * 关闭完成后，调用此方法（如果有关闭动画，则在动画完成后执行）
         * @param type 如果是点击默认关闭按钮触发，则传入关闭按钮的名字(name)，否则为null。
         */
        onClosed(type?: string): void;
        /**
         * @inheritDoc
         * @override
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @inheritDoc
         * @override
         */
        get_width(): number;
        /**
         * @inheritDoc
         * @override
         */
        get_height(): number;
        /**
         * 场景时钟
         * @override
         */
        get timer(): Timer;
        set timer(value: Timer);
        /**
         * 场景包含的3D场景实例
         */
        get scene3D(): any;
        /**
         * <p>从组件顶边到其内容区域顶边之间的垂直距离（以像素为单位）。</p>
         */
        get top(): number;
        set top(value: number);
        /**
         * <p>从组件底边到其内容区域底边之间的垂直距离（以像素为单位）。</p>
         */
        get bottom(): number;
        set bottom(value: number);
        /**
         * <p>从组件左边到其内容区域左边之间的水平距离（以像素为单位）。</p>
         */
        get left(): number;
        set left(value: number);
        /**
         * <p>从组件右边到其内容区域右边之间的水平距离（以像素为单位）。</p>
         */
        get right(): number;
        set right(value: number);
        /**
         * <p>在父容器中，此对象的水平方向中轴线与父容器的水平方向中心线的距离（以像素为单位）。</p>
         */
        get centerX(): number;
        set centerX(value: number);
        /**
         * <p>在父容器中，此对象的垂直方向中轴线与父容器的垂直方向中心线的距离（以像素为单位）。</p>
         */
        get centerY(): number;
        set centerY(value: number);
        protected _shouldRefreshLayout(): void;
        /**
         * @private
         * @override
        */
        protected _sizeChanged(): void;
        /**
         * 重新排版
         */
        freshLayout(): void;
        /**
         * @private
         * <p>获取对象的布局样式。请不要直接修改此对象</p>
         */
        private _getWidget;
        /**获取场景根容器*/
        static get root(): Sprite;
        /**
         * 加载场景及场景使用到的资源
         * @param	url			场景地址
         * @param	complete	加载完成回调，返回场景实例（可选）
         * @param	progress	加载进度回调（可选）
         */
        static load(url: string, complete?: Handler, progress?: Handler): Promise<Scene>;
        /**
         * 加载并打开场景
         * @param	url			场景地址
         * @param	closeOther	是否关闭其他场景，默认为true（可选），【注意】被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收
         * @param	param		打开页面的参数，会传递给onOpened方法（可选）
         * @param	complete	打开完成回调，返回场景实例（可选）
         * @param	progress	加载进度回调（可选）
         */
        static open(url: string, closeOther?: boolean, param?: any, complete?: Handler, progress?: Handler): Promise<Scene>;
        /**@private */
        private static _onSceneLoaded;
        /**
         * 根据地址，关闭场景（包括对话框）
         * @param	url		场景地址
         * @param	name	如果name不为空，name必须相同才能关闭
         * @return	返回是否关闭成功，如果url找不到，则不成功
         */
        static close(url: string, name?: string): boolean;
        /**
         * 关闭所有场景，不包括对话框，如果关闭对话框，请使用Dialog.closeAll()
         * 【注意】被关闭的场景，如果没有设置autoDestroyAtRemoved=true，则资源可能不能被回收，需要自己手动回收
         */
        static closeAll(): void;
        /**
         * 根据地址，销毁场景（包括对话框）
         * @param	url		场景地址
         * @param	name	如果name不为空，name必须相同才能关闭
         * @return	返回是否销毁成功，如果url找不到，则不成功
         */
        static destroy(url: string, name?: string): boolean;
        /**
         * 销毁当前没有被使用的资源,该函数会忽略lock=true的资源。
         */
        static gc(): void;
        /**
         * 设置loading界面，引擎会在调用open方法后，延迟打开loading界面，在页面添加到舞台之后，关闭loading界面
         * @param	loadPage 	load界面实例
         */
        static setLoadingPage(loadPage: Sprite): void;
        /**
         * 显示loading界面
         * @param	param 打开参数，如果是scene，则会传递给onOpened方法
         * @param	delay 延迟打开时间，默认500毫秒
         */
        static showLoadingPage(param?: any, delay?: number): void;
        private static _showLoading;
        private static _hideLoading;
        /**
         * 隐藏loading界面
         * @param	delay 延迟关闭时间，默认500毫秒
         */
        static hideLoadingPage(delay?: number): void;
    }
    /**在显示对象上按下后调度。
     * @eventType Event.MOUSE_DOWN
     * */
    /**在显示对象抬起后调度。
     * @eventType Event.MOUSE_UP
     * */
    /**鼠标在对象身上进行移动后调度
     * @eventType Event.MOUSE_MOVE
     * */
    /**鼠标经过对象后调度。
     * @eventType Event.MOUSE_OVER
     * */
    /**鼠标离开对象后调度。
     * @eventType Event.MOUSE_OUT
     * */
    /**鼠标点击对象后调度。
     * @eventType Event.CLICK
     * */
    /**开始拖动后调度。
     * @eventType Event.DRAG_START
     * */
    /**拖动中调度。
     * @eventType Event.DRAG_MOVE
     * */
    /**拖动结束后调度。
     * @eventType Event.DRAG_END
     * */
    class Sprite extends Node {
        _ownGraphics: boolean;
        /**
         * <p>鼠标事件与此对象的碰撞检测是否可穿透。碰撞检测发生在鼠标事件的捕获阶段，此阶段引擎会从stage开始递归检测stage及其子对象，直到找到命中的目标对象或者未命中任何对象。</p>
         * <p>穿透表示鼠标事件发生的位置处于本对象绘图区域内时，才算命中，而与对象宽高和值为Rectangle对象的hitArea属性无关。如果sprite.hitArea值是HitArea对象，表示显式声明了此对象的鼠标事件响应区域，而忽略对象的宽高、mouseThrough属性。</p>
         * <p>影响对象鼠标事件响应区域的属性为：width、height、hitArea，优先级顺序为：hitArea(type:HitArea)>hitArea(type:Rectangle)>width/height。</p>
         * @default false	不可穿透，此对象的鼠标响应区域由width、height、hitArea属性决定。</p>
         */
        mouseThrough: boolean;
        /**
         * <p>指定是否自动计算宽高数据。默认值为 false 。</p>
         * <p>Sprite宽高默认为0，并且不会随着绘制内容的变化而变化，如果想根据绘制内容获取宽高，可以设置本属性为true，或者通过getBounds方法获取。设置为true，对性能有一定影响。</p>
         */
        autoSize: boolean;
        /**
         * <p>指定鼠标事件检测是优先检测自身，还是优先检测其子对象。鼠标事件检测发生在鼠标事件的捕获阶段，此阶段引擎会从stage开始递归检测stage及其子对象，直到找到命中的目标对象或者未命中任何对象。</p>
         * <p>如果为false，优先检测子对象，当有子对象被命中时，中断检测，获得命中目标。如果未命中任何子对象，最后再检测此对象；如果为true，则优先检测本对象，如果本对象没有被命中，直接中断检测，表示没有命中目标；如果本对象被命中，则进一步递归检测其子对象，以确认最终的命中目标。</p>
         * <p>合理使用本属性，能减少鼠标事件检测的节点，提高性能。可以设置为true的情况：开发者并不关心此节点的子节点的鼠标事件检测结果，也就是以此节点作为其子节点的鼠标事件检测依据。</p>
         * <p>Stage对象和UI的View组件默认为true。</p>
         * @default false	优先检测此对象的子对象，当递归检测完所有子对象后，仍然没有找到目标对象，最后再检测此对象。
         */
        hitTestPrior: boolean;
        /** 如果节点需要加载相关的皮肤，但放在不同域，这里可以设置 **/
        _skinBaseUrl: string;
        /**
         * @inheritDoc
         * @override
         */
        destroy(destroyChild?: boolean): void;
        constructor();
        get scene(): Scene;
        /**根据zOrder进行重新排序。*/
        updateZOrder(): void;
        /**
         * 设置是否开启自定义渲染，只有开启自定义渲染，才能使用customRender函数渲染。
         */
        set customRenderEnable(b: boolean);
        /**
         * 指定显示对象是否缓存为静态图像，cacheAs时，子对象发生变化，会自动重新缓存，同时也可以手动调用reCache方法更新缓存。
         * 建议把不经常变化的“复杂内容”缓存为静态图像，能极大提高渲染性能。cacheAs有"none"，"normal"和"bitmap"三个值可选。
         * 默认为"none"，不做任何缓存。
         * 当值为"normal"时，canvas模式下进行画布缓存，webgl模式下进行命令缓存。
         * 当值为"bitmap"时，canvas模式下进行依然是画布缓存，webgl模式下使用renderTarget缓存。
         * webgl下renderTarget缓存模式缺点：会额外创建renderTarget对象，增加内存开销，缓存面积有最大2048限制，不断重绘时会增加CPU开销。优点：大幅减少drawcall，渲染性能最高。
         * webgl下命令缓存模式缺点：只会减少节点遍历及命令组织，不会减少drawcall数，性能中等。优点：没有额外内存开销，无需renderTarget支持。
         */
        get cacheAs(): string;
        set cacheAs(value: string);
        /**
         * 更新_cnavas相关的状态
         */
        private _checkCanvasEnable;
        /**设置cacheAs为非空时此值才有效，staticCache=true时，子对象变化时不会自动更新缓存，只能通过调用reCache方法手动刷新。*/
        get staticCache(): boolean;
        set staticCache(value: boolean);
        /**在设置cacheAs的情况下，调用此方法会重新刷新缓存。*/
        reCache(): void;
        getRepaint(): number;
        /**表示显示对象相对于父容器的水平方向坐标值。*/
        get x(): number;
        set x(value: number);
        /**表示显示对象相对于父容器的垂直方向坐标值。*/
        get y(): number;
        set y(value: number);
        /**
         * <p>显示对象的宽度，单位为像素，默认为0。</p>
         * <p>此宽度用于鼠标碰撞检测，并不影响显示对象图像大小。需要对显示对象的图像进行缩放，请使用scale、scaleX、scaleY。</p>
         * <p>可以通过getbounds获取显示对象图像的实际宽度。</p>
         */
        get width(): number;
        set width(value: number);
        set_width(value: number): void;
        get_width(): number;
        /**
         * <p>显示对象的高度，单位为像素，默认为0。</p>
         * <p>此高度用于鼠标碰撞检测，并不影响显示对象图像大小。需要对显示对象的图像进行缩放，请使用scale、scaleX、scaleY。</p>
         * <p>可以通过getbounds获取显示对象图像的实际高度。</p>
         */
        get height(): number;
        set height(value: number);
        set_height(value: number): void;
        get_height(): number;
        get _isWidthSet(): boolean;
        get _isHeightSet(): boolean;
        protected _shouldRefreshLayout(): void;
        /**
         * <p>对象的显示宽度（以像素为单位）。</p>
         */
        get displayWidth(): number;
        /**
         * <p>对象的显示高度（以像素为单位）。</p>
         */
        get displayHeight(): number;
        /**
         * 设置对象bounds大小，如果有设置，则不再通过getBounds计算，合理使用能提高性能。
         * @param	bound bounds矩形区域
         */
        setSelfBounds(bound: Rectangle): void;
        /**
         * <p>获取本对象在父容器坐标系的矩形显示区域。</p>
         * <p><b>注意：</b>计算量较大，尽量少用。</p>
         * @return 矩形区域。
         */
        getBounds(): Rectangle;
        /**
         * 获取本对象在自己坐标系的矩形显示区域。
         * <p><b>注意：</b>计算量较大，尽量少用。</p>
         * @return 矩形区域。
         */
        getSelfBounds(): Rectangle;
        /**
         * 返回此实例中的绘图对象（ <code>Graphics</code> ）的显示区域，不包括子对象。
         * @param realSize	（可选）使用图片的真实大小，默认为false
         * @return 一个 Rectangle 对象，表示获取到的显示区域。
         */
        getGraphicBounds(realSize?: boolean): Rectangle;
        /**
         * @private
         * 获取样式。
         * @return  样式 Style 。
         */
        getStyle(): SpriteStyle;
        /**
         * @private
         * 设置样式。
         * @param	value 样式。
         */
        setStyle(value: SpriteStyle): void;
        /**X轴缩放值，默认值为1。设置为负数，可以实现水平反转效果，比如scaleX=-1。*/
        get scaleX(): number;
        set scaleX(value: number);
        /**Y轴缩放值，默认值为1。设置为负数，可以实现垂直反转效果，比如scaleX=-1。*/
        get scaleY(): number;
        set scaleY(value: number);
        set_scaleX(value: number): void;
        get_scaleX(): number;
        set_scaleY(value: number): void;
        get_scaleY(): number;
        /**旋转角度，默认值为0。以角度为单位。*/
        get rotation(): number;
        set rotation(value: number);
        /**水平倾斜角度，默认值为0。以角度为单位。*/
        get skewX(): number;
        set skewX(value: number);
        /**垂直倾斜角度，默认值为0。以角度为单位。*/
        get skewY(): number;
        set skewY(value: number);
        /**@private */
        protected _adjustTransform(): Matrix;
        /**
         * <p>对象的矩阵信息。通过设置矩阵可以实现节点旋转，缩放，位移效果。</p>
         * <p>矩阵更多信息请参考 <code>Matrix</code></p>
         */
        get transform(): Matrix;
        set transform(value: Matrix);
        get_transform(): Matrix;
        set_transform(value: Matrix): void;
        /**X轴 轴心点的位置，单位为像素，默认为0。轴心点会影响对象位置，缩放中心，旋转中心。*/
        get pivotX(): number;
        set pivotX(value: number);
        /**Y轴 轴心点的位置，单位为像素，默认为0。轴心点会影响对象位置，缩放中心，旋转中心。*/
        get pivotY(): number;
        set pivotY(value: number);
        /**X锚点，值为0-1，设置anchorX值最终通过pivotX值来改变节点轴心点。*/
        get anchorX(): number;
        get_anchorX(): number;
        set anchorX(value: number);
        set_anchorX(value: number): void;
        /**Y锚点，值为0-1，设置anchorY值最终通过pivotY值来改变节点轴心点。*/
        get anchorY(): number;
        get_anchorY(): number;
        set anchorY(value: number);
        set_anchorY(value: number): void;
        /**透明度，值为0-1，默认值为1，表示不透明。更改alpha值会影响drawcall。*/
        get alpha(): number;
        set alpha(value: number);
        /**表示是否可见，默认为true。如果设置不可见，节点将不被渲染。*/
        get visible(): boolean;
        set visible(value: boolean);
        get_visible(): boolean;
        set_visible(value: boolean): void;
        /**指定要使用的混合模式。目前只支持"lighter"。*/
        get blendMode(): string;
        set blendMode(value: string);
        /**绘图对象。封装了绘制位图和矢量图的接口，Sprite所有的绘图操作都通过Graphics来实现的。*/
        get graphics(): Graphics;
        set graphics(value: Graphics);
        setGraphics(value: Graphics, transferOwnership: boolean): void;
        get material(): Material;
        /**
         *
         */
        set material(value: Material);
        /**
         * <p>显示对象的滚动矩形范围，具有裁剪效果(如果只想限制子对象渲染区域，请使用viewport)</p>
         * <p> srollRect和viewport的区别：<br/>
         * 1.srollRect自带裁剪效果，viewport只影响子对象渲染是否渲染，不具有裁剪效果（性能更高）。<br/>
         * 2.设置rect的x,y属性均能实现区域滚动效果，但scrollRect会保持0,0点位置不变。</p>
         */
        get scrollRect(): Rectangle;
        set scrollRect(value: Rectangle);
        /**
         * <p>设置坐标位置。相当于分别设置x和y属性。</p>
         * <p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.pos(...).scale(...);</p>
         * @param	x			X轴坐标。
         * @param	y			Y轴坐标。
         * @param 	speedMode	（可选）是否极速模式，正常是调用this.x=value进行赋值，极速模式直接调用内部函数处理，如果未重写x,y属性，建议设置为急速模式性能更高。
         * @return	返回对象本身。
         */
        pos(x: number, y: number, speedMode?: boolean): Sprite;
        /**
         * <p>设置轴心点。相当于分别设置pivotX和pivotY属性。</p>
         * <p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.pivot(...).pos(50, 100);</p>
         * @param	x X轴心点。
         * @param	y Y轴心点。
         * @return	返回对象本身。
         */
        pivot(x: number, y: number): Sprite;
        /**
         * <p>设置宽高。相当于分别设置width和height属性。</p>
         * <p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.size(...).pos(50, 100);</p>
         * @param	width 宽度值。
         * @param	hegiht 高度值。
         * @return	返回对象本身。
         */
        size(width: number, height: number): Sprite;
        /**
         * <p>设置缩放。相当于分别设置scaleX和scaleY属性。</p>
         * <p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.scale(...).pos(50, 100);</p>
         * @param	scaleX		X轴缩放比例。
         * @param	scaleY		Y轴缩放比例。
         * @param 	speedMode	（可选）是否极速模式，正常是调用this.scaleX=value进行赋值，极速模式直接调用内部函数处理，如果未重写scaleX,scaleY属性，建议设置为急速模式性能更高。
         * @return	返回对象本身。
         */
        scale(scaleX: number, scaleY: number, speedMode?: boolean): Sprite;
        /**
         * <p>设置倾斜角度。相当于分别设置skewX和skewY属性。</p>
         * <p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.skew(...).pos(50, 100);</p>
         * @param	skewX 水平倾斜角度。
         * @param	skewY 垂直倾斜角度。
         * @return	返回对象本身
         */
        skew(skewX: number, skewY: number): Sprite;
        /**
         * 更新、呈现显示对象。由系统调用。
         * @param	context 渲染的上下文引用。
         * @param	x X轴坐标。
         * @param	y Y轴坐标。
         */
        render(ctx: Context, x: number, y: number): void;
        /**
         * <p>绘制 当前<code>Sprite</code> 到 <code>Canvas</code> 上，并返回一个HtmlCanvas。</p>
         * <p>绘制的结果可以当作图片源，再次绘制到其他Sprite里面，示例：</p>
         *
         * var htmlCanvas:HTMLCanvas = sprite.drawToCanvas(100, 100, 0, 0);//把精灵绘制到canvas上面
         * var sp:Sprite = new Sprite();//创建精灵
         * sp.graphics.drawTexture(htmlCanvas.getTexture());//把截图绘制到精灵上
         * Laya.stage.addChild(sp);//把精灵显示到舞台
         *
         * <p>也可以获取原始图片数据，分享到网上，从而实现截图效果，示例：</p>
         *
         * var htmlCanvas:HTMLCanvas = sprite.drawToCanvas(100, 100, 0, 0);//把精灵绘制到canvas上面
         * htmlCanvas.toBase64("image/png",0.9);//打印图片base64信息，可以发给服务器或者保存为图片
         *
         * @param	canvasWidth 画布宽度。
         * @param	canvasHeight 画布高度。
         * @param	x 绘制的 X 轴偏移量。
         * @param	y 绘制的 Y 轴偏移量。
         * @return  HTMLCanvas 对象。
         */
        drawToCanvas(canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number): HTMLCanvas;
        /**
         * 绘制到一个Texture对象
         * @param canvasWidth
         * @param canvasHeight
         * @param offsetX
         * @param offsetY
         */
        drawToTexture(canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number, rt?: RenderTexture2D | null): Texture | RenderTexture2D;
        /**
         * 把当前对象渲染到指定的贴图上。贴图由外部指定，避免每次都创建。
         * @param offx
         * @param offy
         * @param tex 输出渲染结果
         */
        drawToTexture3D(offx: number, offy: number, tex: Texture2D): void;
        /**
         * @private
         * 绘制到画布。
         */
        static drawToCanvas(sprite: Sprite, _renderType: number, canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number): HTMLCanvas;
        static drawtocanvCtx: Context;
        /**
         * @private
         *
         */
        static drawToTexture(sprite: Sprite, _renderType: number, canvasWidth: number, canvasHeight: number, offsetX: number, offsetY: number, rt?: RenderTexture2D | null): Texture | RenderTexture2D;
        /**
         * <p>自定义更新、呈现显示对象。一般用来扩展渲染模式，请合理使用，可能会导致在加速器上无法渲染。</p>
         * <p><b>注意</b>不要在此函数内增加或删除树节点，否则会对树节点遍历造成影响。</p>
         * @param	context  渲染的上下文引用。
         * @param	x X轴坐标。
         * @param	y Y轴坐标。
         */
        customRender(context: Context, x: number, y: number): void;
        /**滤镜集合。可以设置多个滤镜组合。*/
        get filters(): any[];
        set filters(value: any[]);
        /**
         * 把本地坐标转换为相对stage的全局坐标。
         * @param point				本地坐标点。
         * @param createNewPoint	（可选）是否创建一个新的Point对象作为返回值，默认为false，使用输入的point对象返回，减少对象创建开销。
         * @param globalNode		global节点，默认为Laya.stage
         * @return 转换后的坐标的点。
         */
        localToGlobal(point: Point, createNewPoint?: boolean, globalNode?: Sprite | null): Point;
        /**
         * 把stage的全局坐标转换为本地坐标。
         * @param point				全局坐标点。
         * @param createNewPoint	（可选）是否创建一个新的Point对象作为返回值，默认为false，使用输入的point对象返回，减少对象创建开销。
         * @param globalNode		global节点，默认为Laya.stage
         * @return 转换后的坐标的点。
         */
        globalToLocal(point: Point, createNewPoint?: boolean, globalNode?: Sprite | null): Point;
        /**
         * 将本地坐标系坐标转转换到父容器坐标系。
         * @param point 本地坐标点。
         * @return  转换后的点。
         */
        toParentPoint(point: Point): Point;
        /**
         * 将父容器坐标系坐标转换到本地坐标系。
         * @param point 父容器坐标点。
         * @return  转换后的点。
         */
        fromParentPoint(point: Point): Point;
        protected onStartListeningToType(type: string): void;
        /** @private */
        protected _onDisplay(v?: boolean): void;
        /**@private
         * @override
        */
        protected _setParent(value: Node): void;
        /**
         * <p>加载并显示一个图片。相当于加载图片后，设置texture属性</p>
         * <p>注意：2.0改动：多次调用，只会显示一个图片（1.0会显示多个图片）,x,y,width,height参数取消。</p>
         * @param url		图片地址。
         * @param complete	（可选）加载完成回调。
         * @return	返回精灵对象本身。
         */
        loadImage(url: string, complete?: Handler): Sprite;
        /**
         * 根据图片地址创建一个新的 <code>Sprite</code> 对象用于加载并显示此图片。
         * @param	url 图片地址。
         * @return	返回新的 <code>Sprite</code> 对象。
         */
        static fromImage(url: string): Sprite;
        /**cacheAs后，设置自己和父对象缓存失效。*/
        repaint(type?: number): void;
        /**@private
         * @override
        */
        protected _childChanged(child?: Node): void;
        /**cacheAs时，设置所有父对象缓存失效。 */
        parentRepaint(type?: number): void;
        /**对舞台 <code>stage</code> 的引用。*/
        get stage(): Stage;
        /**
         * <p>可以设置一个Rectangle区域作为点击区域，或者设置一个<code>HitArea</code>实例作为点击区域，HitArea内可以设置可点击和不可点击区域。</p>
         * <p>如果不设置hitArea，则根据宽高形成的区域进行碰撞。</p>
         */
        get hitArea(): IHitArea;
        set hitArea(value: IHitArea);
        /**
         * <p>遮罩，可以设置一个对象(支持位图和矢量图)，根据对象形状进行遮罩显示。</p>
         * <p>【注意】遮罩对象坐标系是相对遮罩对象本身的，和Flash机制不同</p>
         */
        get mask(): Sprite;
        set mask(value: Sprite);
        /**
         * 是否接受鼠标事件。
         * 默认为false，如果监听鼠标事件，则会自动设置本对象及父节点的属性 mouseEnable 的值都为 true（如果父节点手动设置为false，则不会更改）。
         * */
        get mouseEnabled(): boolean;
        set mouseEnabled(value: boolean);
        /**
         * 开始拖动此对象。
         * @param area				（可选）拖动区域，此区域为当前对象注册点活动区域（不包括对象宽高），可选。
         * @param hasInertia		（可选）鼠标松开后，是否还惯性滑动，默认为false，可选。
         * @param elasticDistance	（可选）橡皮筋效果的距离值，0为无橡皮筋效果，默认为0，可选。
         * @param elasticBackTime	（可选）橡皮筋回弹时间，单位为毫秒，默认为300毫秒，可选。
         * @param data				（可选）拖动事件携带的数据，可选。
         * @param ratio				（可选）惯性阻尼系数，影响惯性力度和时长。
         */
        startDrag(area?: Rectangle, hasInertia?: boolean, elasticDistance?: number, elasticBackTime?: number, data?: any, ratio?: number): void;
        /**停止拖动此对象。*/
        stopDrag(): void;
        /**
         * 检测某个点是否在此对象内。
         * @param	x 全局x坐标。
         * @param	y 全局y坐标。
         * @return  表示是否在对象内。
         */
        hitTestPoint(x: number, y: number): boolean;
        /**获得相对于本对象上的鼠标坐标信息。*/
        getMousePoint(): Point;
        /**
         * 返回鼠标在此对象坐标系上的 X 轴坐标信息。
         */
        get mouseX(): number;
        /**
         * 返回鼠标在此对象坐标系上的 Y 轴坐标信息。
         */
        get mouseY(): number;
        /**z排序，更改此值，则会按照值的大小对同一容器的所有对象重新排序。值越大，越靠上。默认为0，则根据添加顺序排序。*/
        get zOrder(): number;
        set zOrder(value: number);
        /**
         * 设置一个Texture实例，并显示此图片（如果之前有其他绘制，则会被清除掉）。
         * 等同于graphics.clear();graphics.drawImage()，但性能更高
         * 还可以赋值一个图片地址，则会自动加载图片，然后显示
         */
        get texture(): Texture;
        set texture(value: Texture);
        /**
         * <p>视口大小，视口外的子对象，将不被渲染(如果想实现裁剪效果，请使用srollRect)，合理使用能提高渲染性能。比如由一个个小图片拼成的地图块，viewport外面的小图片将不渲染</p>
         * <p>srollRect和viewport的区别：<br/>
         * 1. srollRect自带裁剪效果，viewport只影响子对象渲染是否渲染，不具有裁剪效果（性能更高）。<br/>
         * 2. 设置rect的x,y属性均能实现区域滚动效果，但scrollRect会保持0,0点位置不变。</p>
         * @default null
         */
        get viewport(): Rectangle;
        set viewport(value: Rectangle);
        set drawCallOptimize(value: boolean);
        get drawCallOptimize(): boolean;
        onAfterDeserialize(): void;
        get cacheGlobal(): boolean;
        CustomMaterial(): void;
        /**
         * 获得相对于stage的全局X轴缩放值（会叠加父亲节点的缩放值）。
         */
        get globalScaleX(): number;
        /**
         * 获得相对于stage的全局Y轴缩放值（会叠加父亲节点的缩放值）。
         */
        get globalScaleY(): number;
    }
    /**
     * @private
     */
    class SpriteConst {
        /** @private */
        static ALPHA: number;
        /** @private */
        static TRANSFORM: number;
        /** @private */
        static BLEND: number;
        /** @private */
        static CANVAS: number;
        /** @private */
        static FILTERS: number;
        /** @private */
        static MASK: number;
        /** @private */
        static CLIP: number;
        /** @private */
        static STYLE: number;
        /** @private */
        static TEXTURE: number;
        /** @private */
        static GRAPHICS: number;
        /** @private */
        static LAYAGL3D: number;
        /** @private */
        static CUSTOM: number;
        /** @private */
        static ONECHILD: number;
        /** @private */
        static HITAREA: number;
        /** @private */
        static CHILDS: number;
        /** @private */
        static REPAINT_NONE: number;
        /** @private */
        static REPAINT_NODE: number;
        /** @private */
        static REPAINT_CACHE: number;
        /** @private */
        static REPAINT_ALL: number;
    }
    /**
     * stage大小经过重新调整时进行调度。
     * @eventType Event.RESIZE
     */
    /**
     * 舞台获得焦点时调度。比如浏览器或者当前标签处于后台，重新切换回来时进行调度。
     * @eventType Event.FOCUS
     */
    /**
     * 舞台失去焦点时调度。比如浏览器或者当前标签被切换到后台后调度。
     * @eventType Event.BLUR
     */
    /**
     * 舞台焦点变化时调度，使用Laya.stage.isFocused可以获取当前舞台是否获得焦点。
     * @eventType Event.FOCUS_CHANGE
     */
    /**
     * 舞台可见性发生变化时调度（比如浏览器或者当前标签被切换到后台后调度），使用Laya.stage.isVisibility可以获取当前是否处于显示状态。
     * @eventType Event.VISIBILITY_CHANGE
     */
    /**
     * 浏览器全屏更改时调度，比如进入全屏或者退出全屏。
     * @eventType Event.FULL_SCREEN_CHANGE
     */
    /**
     * <p> <code>Stage</code> 是舞台类，显示列表的根节点，所有显示对象都在舞台上显示。通过 Laya.stage 单例访问。</p>
     * <p>Stage提供几种适配模式，不同的适配模式会产生不同的画布大小，画布越大，渲染压力越大，所以要选择合适的适配方案。</p>
     * <p>Stage提供不同的帧率模式，帧率越高，渲染压力越大，越费电，合理使用帧率甚至动态更改帧率有利于改进手机耗电。</p>
     */
    class Stage extends Sprite {
        /**应用保持设计宽高不变，不缩放不变形，stage的宽高等于设计宽高。*/
        static SCALE_NOSCALE: string;
        /**应用根据屏幕大小铺满全屏，非等比缩放会变形，stage的宽高等于设计宽高。*/
        static SCALE_EXACTFIT: string;
        /**应用显示全部内容，按照最小比率缩放，等比缩放不变形，一边可能会留空白，stage的宽高等于设计宽高。*/
        static SCALE_SHOWALL: string;
        /**应用按照最大比率缩放显示，宽或高方向会显示一部分，等比缩放不变形，stage的宽高等于设计宽高。*/
        static SCALE_NOBORDER: string;
        /**应用保持设计宽高不变，不缩放不变形，stage的宽高等于屏幕宽高。*/
        static SCALE_FULL: string;
        /**应用保持设计宽度不变，高度根据屏幕比缩放，stage的宽度等于设计高度，高度根据屏幕比率大小而变化*/
        static SCALE_FIXED_WIDTH: string;
        /**应用保持设计高度不变，宽度根据屏幕比缩放，stage的高度等于设计宽度，宽度根据屏幕比率大小而变化*/
        static SCALE_FIXED_HEIGHT: string;
        /**应用保持设计比例不变，全屏显示全部内容(类似showall，但showall非全屏，会有黑边)，根据屏幕长宽比，自动选择使用SCALE_FIXED_WIDTH或SCALE_FIXED_HEIGHT*/
        static SCALE_FIXED_AUTO: string;
        static SCALE_FIXED_AUTO_LAYAME: string;
        static SCALE_FIXED_AUTO_LAYAVERSE: string;
        /**画布水平居左对齐。*/
        static ALIGN_LEFT: string;
        /**画布水平居右对齐。*/
        static ALIGN_RIGHT: string;
        /**画布水平居中对齐。*/
        static ALIGN_CENTER: string;
        /**画布垂直居上对齐。*/
        static ALIGN_TOP: string;
        /**画布垂直居中对齐。*/
        static ALIGN_MIDDLE: string;
        /**画布垂直居下对齐。*/
        static ALIGN_BOTTOM: string;
        /**不更改屏幕。*/
        static SCREEN_NONE: string;
        /**自动横屏。*/
        static SCREEN_HORIZONTAL: string;
        /**自动竖屏。*/
        static SCREEN_VERTICAL: string;
        /**全速模式，以60的帧率运行。*/
        static FRAME_FAST: string;
        /**慢速模式，以30的帧率运行。*/
        static FRAME_SLOW: string;
        /**自动模式，以30的帧率运行，但鼠标活动后会自动加速到60，鼠标不动2秒后降低为30帧，以节省消耗。*/
        static FRAME_MOUSE: string;
        /**休眠模式，以1的帧率运行*/
        static FRAME_SLEEP: string;
        /**当前焦点对象，此对象会影响当前键盘事件的派发主体。*/
        focus: Node;
        /**@private 相对浏览器左上角的偏移，弃用，请使用_canvasTransform。*/
        offset: Point;
        /**帧率类型，支持三种模式：fast-60帧(默认)，slow-30帧，mouse-30帧（鼠标活动后会自动加速到60，鼠标不动2秒后降低为30帧，以节省消耗），sleep-1帧。*/
        private _frameRate;
        /**设计宽度（初始化时设置的宽度Laya.init(width,height)）*/
        designWidth: number;
        /**设计高度（初始化时设置的高度Laya.init(width,height)）*/
        designHeight: number;
        /**画布是否发生翻转。*/
        canvasRotation: boolean;
        /**画布的旋转角度。*/
        canvasDegree: number;
        /**
         * <p>设置是否渲染，设置为false，可以停止渲染，画面会停留到最后一次渲染上，减少cpu消耗，此设置不影响时钟。</p>
         * <p>比如非激活状态，可以设置renderingEnabled=false以节省消耗。</p>
         * */
        renderingEnabled: boolean;
        /**是否启用屏幕适配，可以适配后，在某个时候关闭屏幕适配，防止某些操作导致的屏幕意外改变*/
        screenAdaptationEnabled: boolean;
        /**@private */
        private _screenMode;
        /**@private */
        private _scaleMode;
        /**@private */
        private _alignV;
        /**@private */
        private _alignH;
        /**@private */
        private _bgColor;
        /**@private */
        private _renderCount;
        /**@private */
        private _safariOffsetY;
        /**@private */
        private _frameStartTime;
        /**@private */
        private _previousOrientation;
        /**@private */
        private _isFocused;
        /**@private */
        private _isVisibility;
        /**@private */
        private _globalRepaintSet;
        /**@private */
        private _globalRepaintGet;
        /**使用物理分辨率作为canvas大小，会改进渲染效果，但是会降低性能*/
        useRetinalCanvas: boolean;
        /**场景类，引擎中只有一个stage实例，此实例可以通过Laya.stage访问。*/
        constructor();
        /**
         * @private
         * 在移动端输入时，输入法弹出期间不进行画布尺寸重置。
         */
        private _isInputting;
        /**@inheritDoc @override*/
        set_width(value: number): void;
        /**
         * @inheritDoc
         * @override
         */
        get_width(): number;
        /**@inheritDoc @override */
        set_height(value: number): void;
        /** @override*/
        get_height(): number;
        /**@override*/
        set transform(value: Matrix);
        /**@inheritDoc @override*/
        get transform(): Matrix;
        /**
         * 舞台是否获得焦点。
         */
        get isFocused(): boolean;
        /**
         * 舞台是否处于可见状态(是否进入后台)。
         */
        get isVisibility(): boolean;
        private _needUpdateCanvasSize;
        updateCanvasSize(delay?: boolean): void;
        needUpdateCanvasSize(): void;
        /**
         * 设置屏幕大小，场景会根据屏幕大小进行适配。可以动态调用此方法，来更改游戏显示的大小。
         * @param	screenWidth		屏幕宽度。
         * @param	screenHeight	屏幕高度。
         */
        setScreenSize(screenWidth: number, screenHeight: number): void;
        /**
         * 屏幕旋转用layaverse 需要
         * @param screenWidth
         * @param screenHeight
         * @param _screenMode
         * @returns
         */
        setScreenSizeForScene(screenWidth: number, screenHeight: number, _screenMode: string): {
            stageWidth: number;
            stageHeight: number;
            canvasWidth: number;
            canvasHeight: number;
            scaleX: number;
            scaleY: number;
        };
        /**@private */
        private _formatData;
        /**
         * <p>缩放模式。默认值为 "noscale"。</p>
         * <p><ul>取值范围：
         * <li>"noscale" ：不缩放；</li>
         * <li>"exactfit" ：全屏不等比缩放；</li>
         * <li>"showall" ：最小比例缩放；</li>
         * <li>"noborder" ：最大比例缩放；</li>
         * <li>"full" ：不缩放，stage的宽高等于屏幕宽高；</li>
         * <li>"fixedwidth" ：宽度不变，高度根据屏幕比缩放；</li>
         * <li>"fixedheight" ：高度不变，宽度根据屏幕比缩放；</li>
         * <li>"fixedauto" ：根据宽高比，自动选择使用fixedwidth或fixedheight；</li>
         * </ul></p>
         */
        get scaleMode(): string;
        set scaleMode(value: string);
        /**
         * <p>水平对齐方式。默认值为"left"。</p>
         * <p><ul>取值范围：
         * <li>"left" ：居左对齐；</li>
         * <li>"center" ：居中对齐；</li>
         * <li>"right" ：居右对齐；</li>
         * </ul></p>
         */
        get alignH(): string;
        set alignH(value: string);
        /**
         * <p>垂直对齐方式。默认值为"top"。</p>
         * <p><ul>取值范围：
         * <li>"top" ：居顶部对齐；</li>
         * <li>"middle" ：居中对齐；</li>
         * <li>"bottom" ：居底部对齐；</li>
         * </ul></p>
         */
        get alignV(): string;
        set alignV(value: string);
        /**舞台的背景颜色，默认为黑色，null为透明。*/
        get bgColor(): string;
        set bgColor(value: string);
        /**鼠标在 Stage 上的 X 轴坐标。@override*/
        get mouseX(): number;
        /**鼠标在 Stage 上的 Y 轴坐标。@override*/
        get mouseY(): number;
        /**@inheritDoc @override*/
        getMousePoint(): Point;
        /**当前视窗由缩放模式导致的 X 轴缩放系数。*/
        get clientScaleX(): number;
        /**当前视窗由缩放模式导致的 Y 轴缩放系数。*/
        get clientScaleY(): number;
        /**
         * <p>场景布局类型。</p>
         * <p><ul>取值范围：
         * <li>"none" ：不更改屏幕</li>
         * <li>"horizontal" ：自动横屏</li>
         * <li>"vertical" ：自动竖屏</li>
         * </ul></p>
         */
        get screenMode(): string;
        set screenMode(value: string);
        /**@inheritDoc @override*/
        repaint(type?: number): void;
        /**@inheritDoc @override*/
        parentRepaint(type?: number): void;
        /**@private */
        getFrameTm(): number;
        /**
         * <p>获得距当前帧开始后，过了多少时间，单位为毫秒。</p>
         * <p>可以用来判断函数内时间消耗，通过合理控制每帧函数处理消耗时长，避免一帧做事情太多，对复杂计算分帧处理，能有效降低帧率波动。</p>
         */
        getTimeFromFrameStart(): number;
        /**@inheritDoc @override*/
        set visible(value: boolean);
        /**
         * @inheritDoc
         * @override
         */
        get visible(): boolean;
        /** @private */
        static clear: Function;
        /**@inheritDoc @override*/
        render(context: Context, x: number, y: number): void;
        renderToNative(context: Context, x: number, y: number): void;
        private _runComponents;
        private _updateTimers;
        /**
         * <p>是否开启全屏，用户点击后进入全屏。</p>
         * <p>兼容性提示：部分浏览器不允许点击进入全屏，比如Iphone等。</p>
         */
        set fullScreenEnabled(value: boolean);
        /**退出全屏模式*/
        exitFullscreen(): void;
        get frameRate(): string;
        set frameRate(value: string);
        /**@private */
        isGlobalRepaint(): boolean;
        /**@private */
        setGlobalRepaint(): void;
    }
    /**
     * 文本内容发生改变后调度。
     * @eventType Event.CHANGE
     */
    /**
     * <p> <code>Text</code> 类用于创建显示对象以显示文本。</p>
     * <p>
     * 注意：如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。
     * </p>
     * @example
     * package
     * {
     * 	import laya.display.Text;
     * 	public class Text_Example
     * 	{
     * 		public function Text_Example()
     * 		{
     * 			Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     * 			Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     * 			onInit();
     * 		}
     * 		private function onInit():void
     * 		{
     * 			var text:Text = new Text();//创建一个 Text 类的实例对象 text 。
     * 			text.text = "这个是一个 Text 文本示例。";
     * 			text.color = "#008fff";//设置 text 的文本颜色。
     * 			text.font = "Arial";//设置 text 的文本字体。
     * 			text.bold = true;//设置 text 的文本显示为粗体。
     * 			text.fontSize = 30;//设置 text 的字体大小。
     * 			text.wordWrap = true;//设置 text 的文本自动换行。
     * 			text.x = 100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
     * 			text.y = 100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
     * 			text.width = 300;//设置 text 的宽度。
     * 			text.height = 200;//设置 text 的高度。
     * 			text.italic = true;//设置 text 的文本显示为斜体。
     * 			text.borderColor = "#fff000";//设置 text 的文本边框颜色。
     * 			Laya.stage.addChild(text);//将 text 添加到显示列表。
     * 		}
     * 	}
     * }
     * @example
     * Text_Example();
     * function Text_Example()
     * {
     *     Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     *     Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *     onInit();
     * }
     * function onInit()
     * {
     *     var text = new laya.display.Text();//创建一个 Text 类的实例对象 text 。
     *     text.text = "这个是一个 Text 文本示例。";
     *     text.color = "#008fff";//设置 text 的文本颜色。
     *     text.font = "Arial";//设置 text 的文本字体。
     *     text.bold = true;//设置 text 的文本显示为粗体。
     *     text.fontSize = 30;//设置 text 的字体大小。
     *     text.wordWrap = true;//设置 text 的文本自动换行。
     *     text.x = 100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
     *     text.y = 100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
     *     text.width = 300;//设置 text 的宽度。
     *     text.height = 200;//设置 text 的高度。
     *     text.italic = true;//设置 text 的文本显示为斜体。
     *     text.borderColor = "#fff000";//设置 text 的文本边框颜色。
     *     Laya.stage.addChild(text);//将 text 添加到显示列表。
     * }
     * @example
     * class Text_Example {
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         this.onInit();
     *     }
     *     private onInit(): void {
     *         var text: laya.display.Text = new laya.display.Text();//创建一个 Text 类的实例对象 text 。
     *         text.text = "这个是一个 Text 文本示例。";
     *         text.color = "#008fff";//设置 text 的文本颜色。
     *         text.font = "Arial";//设置 text 的文本字体。
     *         text.bold = true;//设置 text 的文本显示为粗体。
     *         text.fontSize = 30;//设置 text 的字体大小。
     *         text.wordWrap = true;//设置 text 的文本自动换行。
     *         text.x = 100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
     *         text.y = 100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
     *         text.width = 300;//设置 text 的宽度。
     *         text.height = 200;//设置 text 的高度。
     *         text.italic = true;//设置 text 的文本显示为斜体。
     *         text.borderColor = "#fff000";//设置 text 的文本边框颜色。
     *         Laya.stage.addChild(text);//将 text 添加到显示列表。
     *     }
     * }
     */
    class Text extends Sprite {
        /**visible不进行任何裁切。*/
        static VISIBLE: string;
        /**scroll 不显示文本域外的字符像素，并且支持 scroll 接口。*/
        static SCROLL: string;
        /**hidden 不显示超出文本域的字符。*/
        static HIDDEN: string;
        /**shrink 超出文本域时，文本整体缩小以适应文本框。*/
        static SHRINK: string;
        /**ellipsis 超出文本域时，文本被截断，并且文本最后显示省略号。*/
        static ELLIPSIS: string;
        /**语言包，是一个包含key:value的集合，用key索引，替换为目标value语言*/
        static langPacks: Record<string, string>;
        /**是否是从右向左的显示顺序*/
        static RightToLeft: boolean;
        static _passwordChar: string;
        /**@private 位图字体字典。*/
        private static _bitmapFonts;
        /** 标记此文本是否忽略语言包 */
        ignoreLang: boolean;
        /**表示文本内容字符串。*/
        protected _text: string;
        protected _overflow: string;
        protected _singleCharRender: boolean;
        protected _textStyle: TextStyle;
        protected _prompt: string;
        /**输入提示符颜色。*/
        protected _promptColor: string;
        /**
         * 文本背景颜色，以字符串表示。
         */
        protected _bgColor: string;
        /**
         * 文本边框背景颜色，以字符串表示。
         */
        protected _borderColor: string;
        /**
         * <p>默认边距信息</p>
         * <p>[上边距，右边距，下边距，左边距]（边距以像素为单位）</p>
         */
        protected _padding: number[];
        /**
         * <p>表示使用此文本格式的文本字段是否自动换行。</p>
         * 如果 wordWrap 的值为 true，则该文本字段自动换行；如果值为 false，则该文本字段不自动换行。
         * @default false。
         */
        protected _wordWrap: boolean;
        /**
         * <p>指定文本字段是否是密码文本字段。</p>
         * 如果此属性的值为 true，则文本字段被视为密码文本字段，并使用星号而不是实际字符来隐藏输入的字符。如果为 false，则不会将文本字段视为密码文本字段。
         */
        protected _asPassword: boolean;
        protected _htmlParseOptions: HtmlParseOptions;
        protected _templateVars: Record<string, string>;
        /**表示文本内容是否发生改变。*/
        protected _isChanged: boolean;
        /**表示文本的宽度，以像素为单位。*/
        protected _textWidth: number;
        /**表示文本的高度，以像素为单位。*/
        protected _textHeight: number;
        protected _realFont: string;
        protected _bitmapFont: BitmapFont;
        protected _scrollPos: Point | null;
        protected _bgDrawCmd: DrawRectCmd;
        protected _html: boolean;
        protected _ubb: boolean;
        protected _lines: Array<ITextLine>;
        protected _elements: Array<HtmlElement>;
        protected _objContainer: Sprite;
        protected _maxWidth: number;
        protected _hideText: boolean;
        private _updatingLayout;
        private _fontSizeScale;
        /**是否将字符串中的\n,\t转换为实际功能的字符 */
        _parseEscapeChars: boolean;
        _onPostLayout: () => void;
        /**
         * 创建一个新的 <code>Text</code> 实例。
         */
        constructor();
        /**
         * 注册位图字体。
         * @param	name		位图字体的名称。
         * @param	bitmapFont	位图字体文件。
         */
        static registerBitmapFont(name: string, bitmapFont: BitmapFont): void;
        /**
         * 移除注册的位图字体文件。
         * @param	name		位图字体的名称。
         * @param	destroy		是否销毁指定的字体文件。
         */
        static unregisterBitmapFont(name: string, destroy?: boolean): void;
        /**
         * @inheritDoc
         * @override
        */
        destroy(destroyChild?: boolean): void;
        /**
         * @inheritDoc
         * @override
         */
        getGraphicBounds(realSize?: boolean): Rectangle;
        /**
         * @inheritDoc
         * @override
         */
        get_width(): number;
        /**
         * @override
         */
        _setWidth(value: number): void;
        /**
         * @inheritDoc
         * @override
         */
        get_height(): number;
        /**
         * @override
         */
        _setHeight(value: number): void;
        /**
         * 表示文本的宽度，以像素为单位。
         */
        get textWidth(): number;
        /**
         * 表示文本的高度，以像素为单位。
         */
        get textHeight(): number;
        /** 当前文本的内容字符串。*/
        get text(): string;
        set text(value: string);
        /** @deprecated **/
        changeText(text: string): void;
        /**
         * <p>文本的字体名称，以字符串形式表示。</p>
         * <p>默认值为："Arial"，可以通过Config.defaultFont设置默认字体。</p>
         * <p>如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。</p>
         */
        get font(): string;
        set font(value: string);
        /**
         * <p>指定文本的字体大小（以像素为单位）。</p>
         * <p>默认为20像素，可以通过 <code>Config.defaultFontSize</code> 设置默认大小。</p>
         */
        get fontSize(): number;
        set fontSize(value: number);
        /**
         * <p>表示文本的颜色值。可以通过 <code>Text.defaultColor</code> 设置默认颜色。</p>
         * <p>默认值为黑色。</p>
         */
        get color(): string;
        set color(value: string);
        set_color(value: string): void;
        /**
         * <p>指定文本是否为粗体字。</p>
         * <p>默认值为 false，这意味着不使用粗体字。如果值为 true，则文本为粗体字。</p>
         */
        get bold(): boolean;
        set bold(value: boolean);
        /**
         * <p>表示使用此文本格式的文本是否为斜体。</p>
         * <p>默认值为 false，这意味着不使用斜体。如果值为 true，则文本为斜体。</p>
         */
        get italic(): boolean;
        set italic(value: boolean);
        /**
         * <p>表示文本的水平显示方式。</p>
         * <p><b>取值：</b>
         * <li>"left"： 居左对齐显示。</li>
         * <li>"center"： 居中对齐显示。</li>
         * <li>"right"： 居右对齐显示。</li>
         * </p>
         */
        get align(): string;
        set align(value: string);
        /**
         * <p>表示文本的垂直显示方式。</p>
         * <p><b>取值：</b>
         * <li>"top"： 居顶部对齐显示。</li>
         * <li>"middle"： 居中对齐显示。</li>
         * <li>"bottom"： 居底部对齐显示。</li>
         * </p>
         */
        get valign(): string;
        set valign(value: string);
        /**
         * 图文混排时图片和文字的对齐方式。可选值是top,middle,bottom
         */
        get alignItems(): string;
        set alignItems(value: string);
        /**
         * <p>表示文本是否自动换行，默认为false。</p>
         * <p>若值为true，则自动换行；否则不自动换行。</p>
         */
        get wordWrap(): boolean;
        set wordWrap(value: boolean);
        /**
         * 垂直行间距（以像素为单位）。
         */
        get leading(): number;
        set leading(value: number);
        /**
         * <p>边距信息。</p>
         * <p>数据格式：[上边距，右边距，下边距，左边距]（边距以像素为单位）。</p>
         */
        get padding(): number[];
        set padding(value: number[] | string);
        /**
         * 文本背景颜色，以字符串表示。
         */
        get bgColor(): string;
        set bgColor(value: string);
        /**
         * 文本边框背景颜色，以字符串表示。
         */
        get borderColor(): string;
        set borderColor(value: string);
        /**
         * <p>描边宽度（以像素为单位）。</p>
         * <p>默认值0，表示不描边。</p>
         */
        get stroke(): number;
        set stroke(value: number);
        /**
         * <p>描边颜色，以字符串表示。</p>
         * <p>默认值为 "#000000"（黑色）;</p>
         */
        get strokeColor(): string;
        set strokeColor(value: string);
        /**
         * 指定文本超出文本域后的行为
         * @tips: <p>值为:可见visible、隐藏hidden、滚动:scroll、自动收缩shrink、显示省略号ellipsis。</p>
         * @tips: <p>作用：可见，表示文本不受文本宽高约束全部可见；隐藏，超过文本宽高就会被裁切掉，性能最好；
         * 滚动，表示超出宽高的部分被隐藏，可以通过划动控制显示在宽高内区域；自动收缩，表示文本会跟随宽高的大小而自动调整文本的大小，始终全部显示在文本宽高内。
         * 显示省略号，表示当文本超出宽高后，未尾的几位字符会替换为省略号，表示当前文本还有未显示的内容</p>
         */
        get overflow(): string;
        set overflow(value: string);
        /**是否显示下划线。*/
        get underline(): boolean;
        set underline(value: boolean);
        /**下划线的颜色，为null则使用字体颜色。*/
        get underlineColor(): string;
        set underlineColor(value: string);
        get singleCharRender(): boolean;
        /** 设置是否单个字符渲染，如果Textd的内容一直改变，例如是一个增加的数字，就设置这个，防止无效占用缓存 */
        set singleCharRender(value: boolean);
        get html(): boolean;
        /** 设置是否富文本，支持html语法 */
        set html(value: boolean);
        get ubb(): boolean;
        /** 设置是否使用UBB语法解析文本 */
        set ubb(value: boolean);
        get maxWidth(): number;
        /** 设置当文本达到最大允许的宽度时，自定换行，设置为0则此限制不生效。*/
        set maxWidth(value: number);
        get htmlParseOptions(): HtmlParseOptions;
        set htmlParseOptions(value: HtmlParseOptions);
        protected parseTemplate(template: string): string;
        get templateVars(): Record<string, any>;
        set templateVars(value: Record<string, any> | boolean);
        setVar(name: string, value: any): Text;
        /**
        * <p>设置横向滚动量。</p>
        * <p>即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。</p>
        */
        set scrollX(value: number);
        /**
         * 获取横向滚动量。
         */
        get scrollX(): number;
        /**
         * 设置纵向滚动量（px)。即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。
         */
        set scrollY(value: number);
        /**
         * 获取纵向滚动量。
         */
        get scrollY(): number;
        /**
         * 获取横向可滚动最大值。
         */
        get maxScrollX(): number;
        /**
         * 获取纵向可滚动最大值。
         */
        get maxScrollY(): number;
        /**返回文字行信息*/
        get lines(): ReadonlyArray<ITextLine>;
        /**
         * @private
         */
        protected markChanged(): void;
        typeset(): void;
        refreshLayout(): void;
        get objContainer(): Sprite;
        /**
         * <p>排版文本。</p>
         * <p>进行宽高计算，渲染、重绘文本。</p>
         */
        protected _typeset(): void;
        /**
         * @private
         * 分析文本换行。
         */
        protected doLayout(): void;
        /**
        * @private
        * 渲染文字。
        * @param	begin 开始渲染的行索引。
        * @param	visibleLineCount 渲染的行数。
        */
        protected renderText(): void;
        protected drawBg(): void;
    }
    interface ITextCmd {
        x: number;
        y: number;
        width: number;
        height: number;
        style: TextStyle;
        wt: WordText;
        obj: IHtmlObject;
        linkEnd: boolean;
        next: ITextCmd;
    }
    interface ITextLine {
        x: number;
        y: number;
        height: number;
        width: number;
        cmd: ITextCmd;
    }
    /**
     * @Script {name:ButtonEffect}
     * @author ww
     */
    class ButtonEffect {
        private _tar;
        private _curState;
        private _curTween;
        /**
         * effectScale
         * @prop {name:effectScale,type:number, tips:"缩放值",default:"1.5"}
         */
        effectScale: number;
        /**
         * tweenTime
         * @prop {name:tweenTime,type:number, tips:"缓动时长",default:"300"}
         */
        tweenTime: number;
        /**
         * effectEase
         * @prop {name:effectEase,type:ease, tips:"效果缓动类型"}
         */
        effectEase: string;
        /**
         * backEase
         * @prop {name:backEase,type:ease, tips:"恢复缓动类型"}
         */
        backEase: string;
        /**
         * 设置控制对象
         * @param tar
         */
        set target(tar: Sprite);
        private toChangedState;
        private toInitState;
        private tweenComplete;
    }
    /**
     * 效果插件基类，基于对象池管理
     */
    class EffectBase extends Component {
        /**动画持续时间，单位为毫秒*/
        duration: number;
        /**动画延迟时间，单位为毫秒*/
        delay: number;
        /**重复次数，默认为播放一次*/
        repeat: number;
        /**缓动类型，如果为空，则默认为匀速播放*/
        ease: string;
        /**触发事件，如果为空，则创建时触发*/
        eventName: string;
        /**效用作用的目标对象，如果为空，则是脚本所在的节点本身*/
        target: Sprite;
        /**效果结束后，是否自动移除节点*/
        autoDestroyAtComplete: boolean;
        protected _comlete: Handler;
        protected _tween: Tween;
        protected _onAwake(): void;
        protected _exeTween(): void;
        protected _doTween(): Tween;
        onReset(): void;
    }
    /**
     * 淡入效果
     */
    class FadeIn extends EffectBase {
        /**
         * @override
         */
        protected _doTween(): Tween;
    }
    /**
     * 淡出效果
     */
    class FadeOut extends EffectBase {
        /**
         * @override
         */
        protected _doTween(): Tween;
    }
    interface ITouchInfo {
        touchId: number;
        readonly pos: Point;
    }
    /**
     * <code>Event</code> 是事件类型的集合。一般当发生事件时，<code>Event</code> 对象将作为参数传递给事件侦听器。
     */
    class Event {
        /** 一个空的 Event 对象。用于事件派发中转使用。*/
        static readonly EMPTY: Readonly<Event>;
        /** 定义 mousedown 事件对象的 type 属性值。*/
        static MOUSE_DOWN: string;
        /** 定义 mouseup 事件对象的 type 属性值。*/
        static MOUSE_UP: string;
        /** 定义 rightmousedown 事件对象的 type 属性值。*/
        static RIGHT_MOUSE_DOWN: string;
        /** 定义 rightmouseup 事件对象的 type 属性值。*/
        static RIGHT_MOUSE_UP: string;
        /** 定义 click 事件对象的 type 属性值。*/
        static CLICK: string;
        /** 定义 rightclick 事件对象的 type 属性值。*/
        static RIGHT_CLICK: string;
        /** 定义 mousemove 事件对象的 type 属性值。*/
        static MOUSE_MOVE: string;
        /** 定义 mouseover 事件对象的 type 属性值。*/
        static MOUSE_OVER: string;
        /** 定义 mouseout 事件对象的 type 属性值。*/
        static MOUSE_OUT: string;
        /** 定义 mousewheel 事件对象的 type 属性值。*/
        static MOUSE_WHEEL: string;
        /** 定义 mouseover 事件对象的 type 属性值。*/
        static ROLL_OVER: string;
        /** 定义 mouseout 事件对象的 type 属性值。*/
        static ROLL_OUT: string;
        /** 定义 doubleclick 事件对象的 type 属性值。*/
        static DOUBLE_CLICK: string;
        /** 定义 mousemove 事件对象的 type 属性值。*/
        static MOUSE_DRAG: string;
        /** 定义 mousemove 事件对象的 type 属性值。*/
        static MOUSE_DRAG_END: string;
        /** 定义 dragstart 事件对象的 type 属性值。*/
        static DRAG_START: string;
        /** 定义 dragmove 事件对象的 type 属性值。*/
        static DRAG_MOVE: string;
        /** 定义 dragend 事件对象的 type 属性值。*/
        static DRAG_END: string;
        /** 定义 keydown 事件对象的 type 属性值。*/
        static KEY_DOWN: string;
        /** 定义 keypress 事件对象的 type 属性值。*/
        static KEY_PRESS: string;
        /** 定义 keyup 事件对象的 type 属性值。*/
        static KEY_UP: string;
        /** 定义 change 事件对象的 type 属性值。*/
        static CHANGE: string;
        /** 定义 changed 事件对象的 type 属性值。*/
        static CHANGED: string;
        /** 定义 willResize 事件对象的 type 属性值。*/
        static WILL_RESIZE: string;
        /** 定义 resize 事件对象的 type 属性值。*/
        static RESIZE: string;
        /** 定义 added 事件对象的 type 属性值。*/
        static ADDED: string;
        /** 定义 removed 事件对象的 type 属性值。*/
        static REMOVED: string;
        /** 定义 display 事件对象的 type 属性值。*/
        static DISPLAY: string;
        /** 定义 undisplay 事件对象的 type 属性值。*/
        static UNDISPLAY: string;
        /** 定义 error 事件对象的 type 属性值。*/
        static ERROR: string;
        /** 定义 complete 事件对象的 type 属性值。*/
        static COMPLETE: string;
        /** 定义 loaded 事件对象的 type 属性值。*/
        static LOADED: string;
        /** 定义 loaded 事件对象的 type 属性值。*/
        static READY: string;
        /** 定义 progress 事件对象的 type 属性值。*/
        static PROGRESS: string;
        /** 定义 input 事件对象的 type 属性值。*/
        static INPUT: string;
        /** 定义 render 事件对象的 type 属性值。*/
        static RENDER: string;
        /** 定义 open 事件对象的 type 属性值。*/
        static OPEN: string;
        /** 定义 message 事件对象的 type 属性值。*/
        static MESSAGE: string;
        /** 定义 close 事件对象的 type 属性值。*/
        static CLOSE: string;
        /** 定义 frame 事件对象的 type 属性值。*/
        static FRAME: string;
        /** 定义 enter 事件对象的 type 属性值。*/
        static ENTER: string;
        /** 定义 select 事件对象的 type 属性值。*/
        static SELECT: string;
        /** 定义 blur 事件对象的 type 属性值。*/
        static BLUR: string;
        /** 定义 focus 事件对象的 type 属性值。*/
        static FOCUS: string;
        /** 定义 visibilitychange 事件对象的 type 属性值。*/
        static VISIBILITY_CHANGE: string;
        /** 定义 focuschange 事件对象的 type 属性值。*/
        static FOCUS_CHANGE: string;
        /** 定义 played 事件对象的 type 属性值。*/
        static PLAYED: string;
        /** 定义 paused 事件对象的 type 属性值。*/
        static PAUSED: string;
        /** 定义 stopped 事件对象的 type 属性值。*/
        static STOPPED: string;
        /** 定义 start 事件对象的 type 属性值。*/
        static START: string;
        /** 定义 end 事件对象的 type 属性值。*/
        static END: string;
        /** 定义 link 事件对象的 type 属性值。*/
        static LINK: string;
        /** 定义 label 事件对象的 type 属性值。*/
        static LABEL: string;
        /**浏览器全屏更改时触发*/
        static FULL_SCREEN_CHANGE: string;
        /**显卡设备丢失时触发*/
        static DEVICE_LOST: string;
        /**世界矩阵更新时触发。*/
        static TRANSFORM_CHANGED: string;
        /**3D layer改变时触发。*/
        static LAYERCHANGE: string;
        /**3D Static改变时触发 */
        static staticMask: string;
        /**物理碰撞开始*/
        static TRIGGER_ENTER: string;
        /**物理碰撞持续*/
        static TRIGGER_STAY: string;
        /**物理碰撞结束*/
        static TRIGGER_EXIT: string;
        /**物理碰撞开始*/
        static COLLISION_ENTER: string;
        /**物理碰撞持续*/
        static COLLISION_STAY: string;
        /**物理碰撞结束*/
        static COLLISION_EXIT: string;
        /**关节破坏 */
        static JOINT_BREAK: string;
        /**
         * 检测指定事件类型是否是鼠标事件。
         * @param	type 事件的类型。
         * @return	如果是鼠标事件，则值为 true;否则，值为 false。
         */
        static isMouseEvent(type: string): boolean;
        /** 事件类型。*/
        type: string;
        /** 事件目标触发对象。*/
        target: any;
        /** 事件当前冒泡对象。*/
        currentTarget: any;
        /** 分配给触摸点的唯一标识号（作为 int）。*/
        touchId: number;
        /** 点击坐标 */
        readonly touchPos: Point;
        /** 是否双击 */
        isDblClick: boolean;
        /**滚轮滑动增量*/
        delta: number;
        /**
         * 鼠标按键，
         * 0：主按键，通常指鼠标左键
         * 1：辅助按键，通常指鼠标滚轮中键
         * 2：次按键，通常指鼠标右键
         * 3：第四个按钮，通常指浏览器后退按钮
         * 4：第五个按钮，通常指浏览器的前进按钮
         */
        button: number;
        /** 原生浏览器事件。*/
        nativeEvent: MouseEvent | TouchEvent | WheelEvent | KeyboardEvent;
        constructor();
        /**
         * 设置事件数据。
         * @param	type 事件类型。
         * @param	currentTarget 事件目标触发对象。
         * @param	target 事件当前冒泡对象。
         * @return 返回当前 Event 对象。
         */
        setTo(type: string, currentTarget: any, target: any): Event;
        /**
         * 阻止对事件流中当前节点的后续节点中的所有事件侦听器进行处理。此方法不会影响当前节点 (currentTarget) 中的任何事件侦听器。
         */
        stopPropagation(): void;
        /**
         * 触摸点列表。
         */
        get touches(): ReadonlyArray<Readonly<ITouchInfo>>;
        /**
         * 表示 Alt 键是处于活动状态 (true) 还是非活动状态 (false)。
         */
        get altKey(): boolean;
        /**
         * 表示 Ctrl 键是处于活动状态 (true) 还是非活动状态 (false)。
         */
        get ctrlKey(): boolean;
        /**
         * 表示 Shift 键是处于活动状态 (true) 还是非活动状态 (false)。
         */
        get shiftKey(): boolean;
        /**
         * 表示 Shift 键是处于活动状态 (true) 还是非活动状态 (false)。
         */
        get metaKey(): boolean;
        get key(): string;
        get keyCode(): number;
        /**
         * 包含按下或释放的键的字符代码值。字符代码值为英文键盘值。
         */
        get charCode(): string;
        /**
         * 表示键在键盘上的位置。这对于区分在键盘上多次出现的键非常有用。<br>
         * 例如，您可以根据此属性的值来区分左 Shift 键和右 Shift 键：左 Shift 键的值为 KeyLocation.LEFT，右 Shift 键的值为 KeyLocation.RIGHT。另一个示例是区分标准键盘 (KeyLocation.STANDARD) 与数字键盘 (KeyLocation.NUM_PAD) 上按下的数字键。
         */
        get keyLocation(): number;
        /**鼠标在 Stage 上的 X 轴坐标*/
        get stageX(): number;
        /**鼠标在 Stage 上的 Y 轴坐标*/
        get stageY(): number;
    }
    /**
     * <code>EventDispatcher</code> 类是可调度事件的所有类的基类。
     */
    class EventDispatcher {
        /**@private */
        private _events;
        protected onStartListeningToType(type: string): void;
        /**
         * 检查 EventDispatcher 对象是否为特定事件类型注册了任何侦听器。
         * @param	type 事件的类型。
         * @return 如果指定类型的侦听器已注册，则值为 true；否则，值为 false。
         */
        hasListener(type: string): boolean;
        /**
         * 派发事件。
         * @param type	事件类型。
         * @param data	（可选）回调数据。<b>注意：</b>如果是需要传递多个参数 p1,p2,p3,...可以使用数组结构如：[p1,p2,p3,...] ；如果需要回调单个参数 p ，且 p 是一个数组，则需要使用结构如：[p]，其他的单个参数 p ，可以直接传入参数 p。
         * @return 此事件类型是否有侦听者，如果有侦听者则值为 true，否则值为 false。
         */
        event(type: string, data?: any): boolean;
        /**
         * 使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知。
         * @param type		事件的类型。
         * @param caller	事件侦听函数的执行域。
         * @param listener	事件侦听函数。
         * @param args		（可选）事件侦听函数的回调参数。
         * @return 此 EventDispatcher 对象。
         */
        on(type: string, listener: Function): EventDispatcher;
        on(type: string, caller: any, listener: Function, args?: any[]): EventDispatcher;
        /**
         * 使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知，此侦听事件响应一次后自动移除。
         * @param type		事件的类型。
         * @param caller	事件侦听函数的执行域。
         * @param listener	事件侦听函数。
         * @param args		（可选）事件侦听函数的回调参数。
         * @return 此 EventDispatcher 对象。
         */
        once(type: string, listener: Function): EventDispatcher;
        once(type: string, caller: any, listener: Function, args?: any[]): EventDispatcher;
        /**
         * 从 EventDispatcher 对象中删除侦听器。
         * @param type		事件的类型。
         * @param caller	事件侦听函数的执行域。
         * @param listener	事件侦听函数。
         * @return 此 EventDispatcher 对象。
         */
        off(type: string, listener: Function): EventDispatcher;
        off(type: string, caller: any, listener?: Function, args?: any[]): EventDispatcher;
        /**
         * 从 EventDispatcher 对象中删除指定事件类型的所有侦听器。
         * @param type	（可选）事件类型，如果值为 null，则移除本对象所有类型的侦听器。
         * @return 此 EventDispatcher 对象。
         */
        offAll(type?: string): EventDispatcher;
        /**
         * 移除caller为target的所有事件监听
         * @param	caller caller对象
         */
        offAllCaller(caller: any): EventDispatcher;
    }
    class InputManager {
        /**是否开启多点触控*/
        static multiTouchEnabled: boolean;
        /**是否开启鼠标/触摸事件，默认为true*/
        static mouseEventsEnabled: boolean;
        /**是否开启键盘事件，默认为true*/
        static keyEventsEnabled: boolean;
        /**如果鼠标按下的位置和弹起的位置距离超过这个阀值，则不视为一次点击*/
        static clickTestThreshold: number;
        /** canvas 上的鼠标X坐标。*/
        static mouseX: number;
        /** canvas 上的鼠标Y坐标。*/
        static mouseY: number;
        /** 当前是否正在输入文字 */
        static isTextInputting: boolean;
        static isiOSWKwebView: boolean;
        protected _stage: Stage;
        protected _mouseTouch: TouchInfo;
        protected _touches: TouchInfo[];
        protected _touchPool: TouchInfo[];
        protected _touchTarget: Node;
        protected _eventType: number;
        protected _nativeEvent: MouseEvent | WheelEvent | TouchEvent;
        protected _pressKeys: Set<string | number>;
        protected _keyEvent: Event;
        private _touchInput;
        constructor();
        static get inst(): InputManager;
        static getTouchPos(touchId?: number): Readonly<Point>;
        static get touchTarget(): Node;
        static get touches(): ReadonlyArray<Readonly<ITouchInfo>>;
        static get touchCount(): number;
        static cancelClick(touchId?: number): void;
        /**
         * 返回指定键是否被按下。
         * @param	key 键值。参考：https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values
         * @return 是否被按下。
         */
        static hasKeyDown(key: string | number): boolean;
        /**
         * @private
         * 初始化。
         */
        static __init__(stage: Stage, canvas: HTMLCanvasElement): void;
        handleMouse(ev: MouseEvent | WheelEvent, type: number): void;
        handleTouch(ev: TouchEvent, type: number): void;
        private getTouch;
        private handleFocus;
        handleKeys(ev: KeyboardEvent): void;
        getNodeUnderPoint(x: number, y: number): Node;
        /**
         * 获取指定坐标下的sprite。x/y值是sp的本地坐标
         * @param sp
         * @param x
         * @param y
         */
        getSpriteUnderPoint(sp: Sprite, x: number, y: number): Sprite;
        getSprite3DUnderPoint(x: number, y: number): Node;
        hitTest(sp: Sprite, x: number, y: number, editing?: boolean): boolean;
        private handleRollOver;
    }
    class TouchInfo implements ITouchInfo {
        readonly event: Event;
        readonly pos: Point;
        touchId: number;
        clickCount: number;
        began: boolean;
        target: Node;
        lastRollOver: Node;
        clickCancelled: boolean;
        moved: boolean;
        readonly downTargets: Node[];
        private downPos;
        constructor(touches: Array<TouchInfo>);
        begin(): void;
        move(): void;
        end(): void;
        clickTest(): Node;
        reset(): void;
    }
    /**
     * <code>Keyboard</code> 类的属性是一些常数，这些常数表示控制游戏时最常用的键。
     */
    class Keyboard {
        /** 与 0 的键控代码值 (48) 关联的常数。*/
        static NUMBER_0: number;
        /** 与 1 的键控代码值 (49) 关联的常数。*/
        static NUMBER_1: number;
        /** 与 2 的键控代码值 (50) 关联的常数。*/
        static NUMBER_2: number;
        /** 与 3 的键控代码值 (51) 关联的常数。*/
        static NUMBER_3: number;
        /** 与 4 的键控代码值 (52) 关联的常数。*/
        static NUMBER_4: number;
        /** 与 5 的键控代码值 (53) 关联的常数。*/
        static NUMBER_5: number;
        /** 与 6 的键控代码值 (54) 关联的常数。*/
        static NUMBER_6: number;
        /** 与 7 的键控代码值 (55) 关联的常数。*/
        static NUMBER_7: number;
        /** 与 8 的键控代码值 (56) 关联的常数。*/
        static NUMBER_8: number;
        /** 与 9 的键控代码值 (57) 关联的常数。*/
        static NUMBER_9: number;
        /** 与 A 键的键控代码值 (65) 关联的常数。*/
        static A: number;
        /** 与 B 键的键控代码值 (66) 关联的常数。*/
        static B: number;
        /** 与 C 键的键控代码值 (67) 关联的常数。*/
        static C: number;
        /** 与 D 键的键控代码值 (68) 关联的常数。*/
        static D: number;
        /** 与 E 键的键控代码值 (69) 关联的常数。*/
        static E: number;
        /** 与 F 键的键控代码值 (70) 关联的常数。*/
        static F: number;
        /** 与 G 键的键控代码值 (71) 关联的常数。*/
        static G: number;
        /** 与 H 键的键控代码值 (72) 关联的常数。*/
        static H: number;
        /** 与 I 键的键控代码值 (73) 关联的常数。*/
        static I: number;
        /** 与 J 键的键控代码值 (74) 关联的常数。*/
        static J: number;
        /** 与 K 键的键控代码值 (75) 关联的常数。*/
        static K: number;
        /** 与 L 键的键控代码值 (76) 关联的常数。*/
        static L: number;
        /** 与 M 键的键控代码值 (77) 关联的常数。*/
        static M: number;
        /** 与 N 键的键控代码值 (78) 关联的常数。*/
        static N: number;
        /** 与 O 键的键控代码值 (79) 关联的常数。*/
        static O: number;
        /** 与 P 键的键控代码值 (80) 关联的常数。*/
        static P: number;
        /** 与 Q 键的键控代码值 (81) 关联的常数。*/
        static Q: number;
        /** 与 R 键的键控代码值 (82) 关联的常数。*/
        static R: number;
        /** 与 S 键的键控代码值 (83) 关联的常数。*/
        static S: number;
        /** 与 T 键的键控代码值 (84) 关联的常数。*/
        static T: number;
        /** 与 U 键的键控代码值 (85) 关联的常数。*/
        static U: number;
        /** 与 V 键的键控代码值 (86) 关联的常数。*/
        static V: number;
        /** 与 W 键的键控代码值 (87) 关联的常数。*/
        static W: number;
        /** 与 X 键的键控代码值 (88) 关联的常数。*/
        static X: number;
        /** 与 Y 键的键控代码值 (89) 关联的常数。*/
        static Y: number;
        /** 与 Z 键的键控代码值 (90) 关联的常数。*/
        static Z: number;
        /** 与 F1 的键控代码值 (112) 关联的常数。*/
        static F1: number;
        /** 与 F2 的键控代码值 (113) 关联的常数。*/
        static F2: number;
        /** 与 F3 的键控代码值 (114) 关联的常数。*/
        static F3: number;
        /** 与 F4 的键控代码值 (115) 关联的常数。*/
        static F4: number;
        /** 与 F5 的键控代码值 (116) 关联的常数。*/
        static F5: number;
        /** 与 F6 的键控代码值 (117) 关联的常数。*/
        static F6: number;
        /** 与 F7 的键控代码值 (118) 关联的常数。*/
        static F7: number;
        /** 与 F8 的键控代码值 (119) 关联的常数。*/
        static F8: number;
        /** 与 F9 的键控代码值 (120) 关联的常数。*/
        static F9: number;
        /** 与 F10 的键控代码值 (121) 关联的常数。*/
        static F10: number;
        /** 与 F11 的键控代码值 (122) 关联的常数。*/
        static F11: number;
        /** 与 F12 的键控代码值 (123) 关联的常数。*/
        static F12: number;
        /** 与 F13 的键控代码值 (124) 关联的常数。*/
        static F13: number;
        /** 与 F14 的键控代码值 (125) 关联的常数。*/
        static F14: number;
        /** 与 F15 的键控代码值 (126) 关联的常数。*/
        static F15: number;
        /** 与数字键盘的伪键控代码 (21) 关联的常数。*/
        static NUMPAD: number;
        /** 与数字键盘上的数字 0 的键控代码值 (96) 关联的常数。*/
        static NUMPAD_0: number;
        /** 与数字键盘上的数字 1 的键控代码值 (97) 关联的常数。*/
        static NUMPAD_1: number;
        /** 与数字键盘上的数字 2 的键控代码值 (98) 关联的常数。*/
        static NUMPAD_2: number;
        /** 与数字键盘上的数字 3 的键控代码值 (99) 关联的常数。*/
        static NUMPAD_3: number;
        /** 与数字键盘上的数字 4 的键控代码值 (100) 关联的常数。*/
        static NUMPAD_4: number;
        /** 与数字键盘上的数字 5 的键控代码值 (101) 关联的常数。*/
        static NUMPAD_5: number;
        /** 与数字键盘上的数字 6 的键控代码值 (102) 关联的常数。*/
        static NUMPAD_6: number;
        /** 与数字键盘上的数字 7 的键控代码值 (103) 关联的常数。*/
        static NUMPAD_7: number;
        /** 与数字键盘上的数字 8 的键控代码值 (104) 关联的常数。*/
        static NUMPAD_8: number;
        /** 与数字键盘上的数字 9 的键控代码值 (105) 关联的常数。*/
        static NUMPAD_9: number;
        /** 与数字键盘上的加号 (+) 的键控代码值 (107) 关联的常数。*/
        static NUMPAD_ADD: number;
        /** 与数字键盘上的小数点 (.) 的键控代码值 (110) 关联的常数。*/
        static NUMPAD_DECIMAL: number;
        /** 与数字键盘上的除号 (/) 的键控代码值 (111) 关联的常数。*/
        static NUMPAD_DIVIDE: number;
        /** 与数字键盘上的 Enter 的键控代码值 (108) 关联的常数。*/
        static NUMPAD_ENTER: number;
        /** 与数字键盘上的乘号 (*) 的键控代码值 (106) 关联的常数。*/
        static NUMPAD_MULTIPLY: number;
        /** 与数字键盘上的减号 (-) 的键控代码值 (109) 关联的常数。*/
        static NUMPAD_SUBTRACT: number;
        /** 与 ; 键的键控代码值 (186) 关联的常数。*/
        static SEMICOLON: number;
        /** 与 = 键的键控代码值 (187) 关联的常数。*/
        static EQUAL: number;
        /** 与 F15 的键控代码值 (188) 关联的常数。*/
        static COMMA: number;
        /** 与 - 键的键控代码值 (189) 关联的常数。*/
        static MINUS: number;
        /** 与 . 键的键控代码值 (190) 关联的常数。*/
        static PERIOD: number;
        /** 与 / 键的键控代码值 (191) 关联的常数。*/
        static SLASH: number;
        /** 与 ` 键的键控代码值 (192) 关联的常数。*/
        static BACKQUOTE: number;
        /** 与 [ 键的键控代码值 (219) 关联的常数。*/
        static LEFTBRACKET: number;
        /** 与 \ 键的键控代码值 (220) 关联的常数。*/
        static BACKSLASH: number;
        /** 与 ] 键的键控代码值 (221) 关联的常数。*/
        static RIGHTBRACKET: number;
        /** 与 ' 键的键控代码值 (222) 关联的常数。*/
        static QUOTE: number;
        /** 与 Alternate (Option) 键的键控代码值 (18) 关联的常数。*/
        static ALTERNATE: number;
        /** 与 Backspace 的键控代码值 (8) 关联的常数。*/
        static BACKSPACE: number;
        /** 与 Caps Lock 的键控代码值 (20) 关联的常数。*/
        static CAPS_LOCK: number;
        /** 与 Mac 命令键 (15) 关联的常数。*/
        static COMMAND: number;
        /** 与 Ctrl 的键控代码值 (17) 关联的常数。*/
        static CONTROL: number;
        /** 与 Delete 的键控代码值 (46) 关联的常数。*/
        static DELETE: number;
        /** 与 Enter 的键控代码值 (13) 关联的常数。*/
        static ENTER: number;
        /** 与 Esc 的键控代码值 (27) 关联的常数。*/
        static ESCAPE: number;
        /** 与 Page Up 的键控代码值 (33) 关联的常数。*/
        static PAGE_UP: number;
        /** 与 Page Down 的键控代码值 (34) 关联的常数。*/
        static PAGE_DOWN: number;
        /** 与 End 的键控代码值 (35) 关联的常数。*/
        static END: number;
        /** 与 Home 的键控代码值 (36) 关联的常数。*/
        static HOME: number;
        /** 与向左箭头键的键控代码值 (37) 关联的常数。*/
        static LEFT: number;
        /** 与向上箭头键的键控代码值 (38) 关联的常数。*/
        static UP: number;
        /** 与向右箭头键的键控代码值 (39) 关联的常数。*/
        static RIGHT: number;
        /** 与向下箭头键的键控代码值 (40) 关联的常数。*/
        static DOWN: number;
        /** 与 Shift 的键控代码值 (16) 关联的常数。*/
        static SHIFT: number;
        /** 与空格键的键控代码值 (32) 关联的常数。*/
        static SPACE: number;
        /** 与 Tab 的键控代码值 (9) 关联的常数。*/
        static TAB: number;
        /** 与 Insert 的键控代码值 (45) 关联的常数。*/
        static INSERT: number;
    }
    /**
     * <p><code>KeyLocation</code> 类包含表示在键盘或类似键盘的输入设备上按键位置的常量。</p>
     * <p><code>KeyLocation</code> 常数用在键盘事件对象的 <code>keyLocation </code>属性中。</p>
     */
    class KeyLocation {
        /**
         * 表示激活的键不区分位于左侧还是右侧，也不区分是否位于数字键盘（或者是使用对应于数字键盘的虚拟键激活的）。
         */
        static STANDARD: number;
        /**
         * 表示激活的键在左侧键位置（此键有多个可能的位置）。
         */
        static LEFT: number;
        /**
         * 表示激活的键在右侧键位置（此键有多个可能的位置）。
         */
        static RIGHT: number;
        /**
         * <p>表示激活的键位于数字键盘或者是使用对应于数字键盘的虚拟键激活的。</p>
         * <p>注意：此属性只在flash模式下有效。</p>
         * */
        static NUM_PAD: number;
    }
    /**
     * 模糊滤镜
     */
    class BlurFilter extends Filter {
        /**模糊滤镜的强度(值越大，越不清晰 */
        strength: number;
        strength_sig2_2sig2_gauss1: number[];
        strength_sig2_native: Float32Array;
        renderFunc: any;
        /**
         * 模糊滤镜
         * @param	strength	模糊滤镜的强度值
         */
        constructor(strength?: number);
        /**
         * @private
         * 当前滤镜的类型
         * @override
         */
        get type(): number;
        getStrenth_sig2_2sig2_native(): Float32Array;
    }
    /**
     * @private
     */
    class BlurFilterGLRender {
        private static blurinfo;
        render(rt: RenderTexture2D, ctx: Context, width: number, height: number, filter: BlurFilter): void;
        setShaderInfo(shader: Value2D, filter: BlurFilter, w: number, h: number): void;
    }
    /**
     * <p><code>ColorFilter</code> 是颜色滤镜。使用 ColorFilter 类可以将 4 x 5 矩阵转换应用于输入图像上的每个像素的 RGBA 颜色和 Alpha 值，以生成具有一组新的 RGBA 颜色和 Alpha 值的结果。该类允许饱和度更改、色相旋转、亮度转 Alpha 以及各种其他效果。您可以将滤镜应用于任何显示对象（即，从 Sprite 类继承的对象）。</p>
     * <p>注意：对于 RGBA 值，最高有效字节代表红色通道值，其后的有效字节分别代表绿色、蓝色和 Alpha 通道值。</p>
     */
    class ColorFilter extends Filter implements IFilter {
        /**当前使用的矩阵*/
        _matrix: any[];
        /**
         * 创建一个 <code>ColorFilter</code> 实例。
         * @param mat	（可选）由 20 个项目（排列成 4 x 5 矩阵）组成的数组，用于颜色转换。
         */
        constructor(mat?: any[]);
        /**
         * 设置为灰色滤镜
         */
        gray(): ColorFilter;
        /**
         * 设置为变色滤镜
         * @param red 红色系数,范围:0~1
         * @param green 绿色系数,范围:0~1
         * @param blue 蓝色系数,范围:0~1
         * @param alpha alpha系数,范围:0~1
         */
        color(red?: number, green?: number, blue?: number, alpha?: number): ColorFilter;
        /**
         * 设置滤镜色
         * @param	color 颜色值
         */
        setColor(color: string): ColorFilter;
        /**
         * 设置矩阵数据
         * @param matrix 由 20 个项目（排列成 4 x 5 矩阵）组成的数组
         * @return this
         */
        setByMatrix(matrix: any[]): ColorFilter;
        /**
         * @private
         * @override
        */
        get type(): number;
        /**
         * 调整颜色，包括亮度，对比度，饱和度和色调
         * @param brightness 亮度,范围:-100~100
         * @param contrast 对比度,范围:-100~100
         * @param saturation 饱和度,范围:-100~100
         * @param hue 色调,范围:-180~180
         * @return this
         */
        adjustColor(brightness: number, contrast: number, saturation: number, hue: number): ColorFilter;
        /**
         * 调整亮度
         * @param brightness 亮度,范围:-100~100
         * @return this
         */
        adjustBrightness(brightness: number): ColorFilter;
        /**
         * 调整对比度
         * @param contrast 对比度,范围:-100~100
         * @return this
         */
        adjustContrast(contrast: number): ColorFilter;
        /**
         * 调整饱和度
         * @param saturation 饱和度,范围:-100~100
         * @return this
         */
        adjustSaturation(saturation: number): ColorFilter;
        /**
         * 调整色调
         * @param hue 色调,范围:-180~180
         * @return this
         */
        adjustHue(hue: number): ColorFilter;
        /**
         * 重置成单位矩阵，去除滤镜效果
         */
        reset(): ColorFilter;
        /**
         * 矩阵乘法
         * @param matrix
         * @return this
         */
        private _multiplyMatrix;
        /**
         * 规范值的范围
         * @param val 当前值
         * @param limit 值的范围-limit~limit
         */
        private _clampValue;
        /**
         * 规范矩阵,将矩阵调整到正确的大小
         * @param matrix 需要调整的矩阵
         */
        private _fixMatrix;
        /**
         * 复制矩阵
         */
        private _copyMatrix;
        onAfterDeserialize(): void;
    }
    /**
     * <code>Filter</code> 是滤镜基类。
     */
    class Filter implements IFilter {
        /**@private 模糊滤镜。*/
        static BLUR: number;
        /**@private 颜色滤镜。*/
        static COLOR: number;
        /**@private 发光滤镜。*/
        static GLOW: number;
        /**
         * 创建一个 <code>Filter</code> 实例。
         * */
        constructor();
        /**@private 滤镜类型。*/
        get type(): number;
        static _filter: (this: RenderSprite, sprite: Sprite, context: Context, x: number, y: number) => void;
    }
    /**
     *  发光滤镜(也可以当成阴影滤使用）
     */
    class GlowFilter extends Filter {
        /**数据的存储，顺序R,G,B,A,blurWidth,offX,offY;*/
        private _elements;
        /**滤镜的颜色*/
        private _color;
        /**
         * 创建发光滤镜
         * @param	color	滤镜的颜色
         * @param	blur	边缘模糊的大小
         * @param	offX	X轴方向的偏移
         * @param	offY	Y轴方向的偏移
         */
        constructor(color: string, blur?: number, offX?: number, offY?: number);
        /**
         * @private
         * 滤镜类型
         * @override
         */
        get type(): number;
        /**@private */
        get offY(): number;
        /**@private */
        set offY(value: number);
        /**@private */
        get offX(): number;
        /**@private */
        set offX(value: number);
        /**@private */
        get color(): string;
        /**@private */
        set color(value: string);
        /**@private */
        getColor(): any[];
        /**@private */
        get blur(): number;
        /**@private */
        set blur(value: number);
        getColorNative(): Float32Array;
        getBlurInfo1Native(): Float32Array;
        getBlurInfo2Native(): Float32Array;
    }
    /**
     * @private
     */
    class GlowFilterGLRender {
        private setShaderInfo;
        render(rt: RenderTexture2D, ctx: Context, width: number, height: number, filter: GlowFilter): void;
    }
    /**
     * 滤镜接口。
     */
    interface IFilter {
        type: number;
    }
    /**
     * <code>Filter</code> 是滤镜基类。
     */
    class NativeFilter implements IFilter {
        /**@private 模糊滤镜。*/
        static BLUR: number;
        /**@private 颜色滤镜。*/
        static COLOR: number;
        /**@private 发光滤镜。*/
        static GLOW: number;
        /**
         * 创建一个 <code>Filter</code> 实例。
         * */
        constructor();
        /**@private 滤镜类型。*/
        get type(): number;
        static _filter: (this: RenderSprite, sprite: Sprite, context: any, x: number, y: number) => void;
    }
    enum HtmlElementType {
        Text = 0,
        Link = 1,
        Image = 2,
        Input = 3,
        Select = 4,
        Object = 5,
        LinkEnd = 6
    }
    class HtmlElement {
        type: HtmlElementType;
        name: string;
        text: string;
        style: TextStyle;
        obj: IHtmlObject;
        space: number;
        _attrs: Record<string, any>;
        constructor();
        getAttr(attrName: string): any;
        setAttr(attrName: string, attrValue: any): void;
        getAttrString(attrName: string, defValue?: string): string;
        getAttrInt(attrName: string, defValue?: number): number;
        getAttrFloat(attrName: string, defValue?: number): number;
        getAttrBool(attrName: string, defValue?: boolean): boolean;
        fetchAttributes(): void;
        reset(): void;
        static pool: Array<HtmlElement>;
        static getFromPool(type: HtmlElementType): HtmlElement;
        static returnToPool(ele: HtmlElement | Array<HtmlElement>): void;
    }
    class HtmlImage implements IHtmlObject {
        readonly obj: Sprite;
        private _owner;
        private _element;
        constructor();
        get element(): HtmlElement;
        get width(): number;
        get height(): number;
        create(owner: Text, element: HtmlElement): void;
        protected loadTexture(src: string): void;
        pos(x: number, y: number): void;
        release(): void;
        destroy(): void;
    }
    class HtmlLink implements IHtmlObject, IHitArea {
        private _owner;
        private _element;
        private _shape;
        private _rects;
        private _rectCnt;
        constructor();
        get element(): HtmlElement;
        get width(): number;
        get height(): number;
        create(owner: Text, element: HtmlElement): void;
        resetArea(): void;
        addRect(x: number, y: number, width: number, height: number): void;
        contains(x: number, y: number): boolean;
        pos(x: number, y: number): void;
        release(): void;
        destroy(): void;
    }
    class HtmlParseOptions {
        linkUnderline: boolean;
        linkColor: string;
        ignoreWhiteSpace: boolean;
        static defaultLinkUnderline: boolean;
        static defaultLinkColor: string;
        constructor();
    }
    class HtmlParser {
        static defaultParser: HtmlParser;
        static classMap: Record<number, new () => IHtmlObject>;
        protected _styleStack: Array<TextStyle>;
        protected _styleStackTop: number;
        protected _style: TextStyle;
        protected _elements: Array<HtmlElement>;
        protected _options: HtmlParseOptions;
        constructor();
        parse(aSource: string, style: TextStyle, out: Array<HtmlElement>, options?: HtmlParseOptions): void;
        protected pushStyle(): void;
        protected popStyle(): void;
        protected isNewLine(): boolean;
        protected appendText(text: string): void;
    }
    interface IHtmlObject {
        width: number;
        height: number;
        element: HtmlElement;
        loading?: boolean;
        create(owner: Text, element: HtmlElement): void;
        pos(x: number, y: number): void;
        release(): void;
        destroy(): void;
    }
    interface IHtmlPageContext {
        createObject(owner: Text, element: HtmlElement): IHtmlObject;
        freeObject(obj: IHtmlObject): void;
    }
    interface ITagHandler {
        (tagName: string, end: boolean, attr: string): string;
    }
    class UBBParser {
        static defaultParser: UBBParser;
        private _text;
        private _readPos;
        protected _handlers: Record<string, ITagHandler>;
        defaultImgWidth: number;
        defaultImgHeight: number;
        lastColor: string;
        lastSize: string;
        constructor();
        protected onTag_URL(tagName: string, end: boolean, attr: string): string;
        protected onTag_IMG(tagName: string, end: boolean, attr: string): string;
        protected onTag_B(tagName: string, end: boolean, attr: string): string;
        protected onTag_I(tagName: string, end: boolean, attr: string): string;
        protected onTag_U(tagName: string, end: boolean, attr: string): string;
        protected onTag_Simple(tagName: string, end: boolean, attr: string): string;
        protected onTag_COLOR(tagName: string, end: boolean, attr: string): string;
        protected onTag_FONT(tagName: string, end: boolean, attr: string): string;
        protected onTag_SIZE(tagName: string, end: boolean, attr: string): string;
        protected getTagText(remove?: boolean): string;
        parse(text: string, remove?: boolean): string;
    }
    class XML {
        name: string;
        text: string;
        private _attrs;
        private _children;
        constructor(XmlString?: string);
        get attributes(): Record<string, string>;
        getAttrString(attrName: string, defValue?: string): string;
        getAttrInt(attrName: string, defValue?: number): number;
        getAttrFloat(attrName: string, defValue?: number): number;
        getAttrBool(attrName: string, defValue?: boolean): boolean;
        setAttribute(attrName: string, attrValue: string): void;
        getNode(selector: string): XML;
        elements(selector?: string): Array<XML>;
        parse(aSource: string): void;
        reset(): void;
    }
    enum XMLTagType {
        Start = 0,
        End = 1,
        Void = 2,
        CDATA = 3,
        Comment = 4,
        Instruction = 5
    }
    class XMLIterator {
        static tagName: string;
        static tagType: XMLTagType;
        static lastTagName: string;
        static source: string;
        static sourceLen: number;
        static parsePos: number;
        static tagPos: number;
        static tagLength: number;
        static lastTagEnd: number;
        static attrParsed: boolean;
        static lowerCaseName: boolean;
        private static _attrs;
        static begin(source: string, lowerCaseName?: boolean): void;
        static nextTag(): boolean;
        static getTagSource(): string;
        static getRawText(trim?: boolean): string;
        static getText(trim?: boolean): string;
        static get attributes(): any;
        static getAttribute(attrName: string): string;
        static parseAttributes(attrs: any): void;
    }
    class XMLUtils {
        static decodeString(aSource: string): string;
        static encodeString(str: string): string;
        static getString(attrs: any, attrName: string, defValue?: string): string;
        static getInt(attrs: any, attrName: string, defValue?: number): number;
        static getFloat(attrs: any, attrName: string, defValue?: number): number;
        static getBool(attrs: any, attrName: string, defValue?: boolean): boolean;
    }
    /**
     * @private
     * CommandEncoder Shader变量集合
     */
    class CommandEncoder {
        /**
         * 实例化一个ShaderVariable集合
         */
        constructor();
    }
    /**
     * 封装GL命令
     */
    class LayaGL {
        static textureContext: ITextureContext;
        static renderEngine: IRenderEngine;
        static render2DContext: IRender2DContext;
        static renderDrawContext: IRenderDrawContext;
        static renderOBJCreate: IRenderEngineFactory;
    }
    /**
     * ...
     * @author ww
     */
    class QuickTestTool {
        private static showedDic;
        private static _rendertypeToStrDic;
        private static _typeToNameDic;
        static getMCDName(type: number): string;
        static showRenderTypeInfo(type: any, force?: boolean): void;
        static __init__(): void;
        _renderType: number;
        _repaint: number;
        _x: number;
        _y: number;
        constructor();
        /**
         * 更新、呈现显示对象。由系统调用。
         * @param	context 渲染的上下文引用。
         * @param	x X轴坐标。
         * @param	y Y轴坐标。
         */
        render(context: Context, x: number, y: number): void;
        private static _PreStageRender;
        private static _countDic;
        private static _countStart;
        private static _i;
        private static _countEnd;
        static showCountInfo(): void;
        static enableQuickTest(): void;
    }
    class HierarchyLoader implements IResourceLoader {
        static v3: IHierarchyParserAPI;
        static v2: IHierarchyParserAPI;
        static legacySceneOrPrefab: IHierarchyParserAPI;
        load(task: ILoadTask): Promise<Prefab>;
    }
    class HierarchyParser {
        static parse(data: any, options?: Record<string, any>, errors?: Array<any>): Array<Node>;
        static collectResourceLinks(data: any, basePath: string): (string | ILoadURL)[];
    }
    /**
     * @private 场景辅助类
     */
    class LegacyUIParser {
        /**@private */
        private static _funMap;
        /**@private */
        private static _parseWatchData;
        /**@private */
        private static _parseKeyWord;
        static parse(data: any, options: any): Sprite;
        /**
         * @private 根据字符串，返回函数表达式
         */
        static getBindFun(value: string): Function;
        /**
         * @private
         * 通过视图数据创建视图。
         * @param uiView 视图数据信息。
         */
        static createByData(root: Sprite, uiView: any): Sprite;
        static createInitTool(): InitTool;
        /**
         * 根据UI数据实例化组件。
         * @param uiView UI数据。
         * @param comp 组件本体，如果为空，会新创建一个。
         * @param view 组件所在的视图实例，用来注册var全局变量，如果值为空则不注册。
         * @return 一个 Component 对象。
         */
        static createComp(uiView: any, comp?: Sprite, view?: Sprite, dataMap?: any[], initTool?: InitTool): any;
        /**
         * @private
         * 设置组件的属性值。
         * @param comp 组件实例。
         * @param prop 属性名称。
         * @param value 属性值。
         * @param view 组件所在的视图实例，用来注册var全局变量，如果值为空则不注册。
         */
        private static setCompValue;
        /**
         * @private
         * 通过组建UI数据，获取组件实例。
         * @param json UI数据。
         * @return Component 对象。
         */
        static getCompInstance(json: any): any;
        static collectResourceLinks(uiView: any): string[];
        /**
         * 根据指定的 json 数据创建节点对象。
         * 比如:
         * {
         * 	"type":"Sprite",
         * 	"props":{
         * 		"x":100,
         * 		"y":50,
         * 		"name":"item1",
         * 		"scale":[2,2]
         * 	},
         * 	"customProps":{
         * 		"x":100,
         * 		"y":50,
         * 		"name":"item1",
         * 		"scale":[2,2]
         * 	},
         * 	"child":[
         * 		{
         * 			"type":"Text",
         * 			"props":{
         * 				"text":"this is a test",
         * 				"var":"label",
         * 				"rumtime":""
         * 			}
         * 		}
         * 	]
         * }
         * @param	json json字符串或者Object对象。
         * @param	node node节点，如果为空，则新创建一个。
         * @param	root 根节点，用来设置var定义。
         * @return	生成的节点。
         */
        static createByJson(json: any, node?: any, root?: Node, customHandler?: Handler, instanceHandler?: Handler): any;
        /**
         * @private
         */
        private static _getGraphicsFromSprite;
        /**
         * @private
         */
        private static _getTransformData;
        /**
         * @private
         */
        private static _addGraphicToGraphics;
        /**
         * @private
         */
        private static _adptLineData;
        /**
         * @private
         */
        private static _adptTextureData;
        /**
         * @private
         */
        private static _adptLinesData;
        /**
         * @private
         */
        private static _getParams;
        /**@private */
        private static DrawTypeDic;
        /**@private */
        private static _temParam;
        /**@private */
        private static _tM;
        /**@private */
        private static _alpha;
        /**
         * @private
         */
        private static _getObjVar;
    }
    class InitTool {
        /**@private */
        private _nodeRefList;
        /**@private */
        private _initList;
        reset(): void;
        recover(): void;
        static create(): InitTool;
        /**@private */
        addNodeRef(node: any, prop: string, referStr: string): void;
        /**@private */
        setNodeRef(): void;
        /**@private */
        getReferData(referStr: string): any;
        /**@private */
        addInitItem(item: any): void;
        /**@private */
        doInits(): void;
        /**@private */
        finish(): void;
    }
    class MaterialLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<any>;
        private load2;
        private move;
    }
    class MaterialParser {
        static parse(data: any): Material;
        static collectLinks(data: any, basePath: string): ILoadURL[];
        /**
         * @deprecated
         * @inheritDoc
         */
        static parseLegacy(data: any): Material;
        /**
            * @deprecated
            * 兼容Blend数据
            */
        private static _getRenderStateParams;
    }
    class NullLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<any>;
    }
    const TypedArrayClasses: Record<string, any>;
    interface IDecodeObjOptions {
        outErrors?: Array<string>;
        getNodeByRef?: (id: string | string[]) => Node;
        getNodeData?: (node: Node) => any;
    }
    class SerializeUtil {
        static isDeserializing: boolean;
        static decodeObj(data: any, obj?: any, options?: IDecodeObjOptions): any;
        private static _decodeObj;
        static getLoadTypeByEngineType(type: string): string;
        static bakeOverrideData(overrideData: any): Record<string, any[]>;
        static applyOverrideData(nodeData: any, overrideDataMap: Record<string, Array<any>>): any;
    }
    class ShaderParser {
        static parse(data: string, basePath?: string): Shader3D;
        static compileToTree(sliceFlag: string[], data: string, sliceIndex: number): string[];
        static getMapKey(value: string): string;
        /**
         * get Shader Data
         */
        static getShaderBlock(source: string): IShaderObjStructor;
        /**
         * get CG data for map
         * @param source
         * @returns
         */
        static getCGBlock(source: string): {
            [key: string]: string;
        };
        static bindCG(shaderObj: IShaderObjStructor, cgmap: {
            [key: string]: string;
        }): void;
        /**
         * trans string to ShaderDataType
         * @param value
         * @returns
         */
        static getShaderDataType(value: string): ShaderDataType;
        /**
         * set ShaderData Value
         * @param type
         * @param data
         * @returns
         */
        static getDefaultData(type: ShaderDataType, data: any): any;
    }
    class Texture2DLoader implements IResourceLoader {
        constructor();
        load(task: ILoadTask): Promise<BaseTexture>;
        protected load2(task: ILoadTask, meta: any): Promise<BaseTexture>;
        protected move(obsoluteInst: BaseTexture, tex: BaseTexture): BaseTexture;
    }
    class RenderTextureLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<RenderTexture>;
    }
    class VideoTextureLoader implements IResourceLoader {
        load(task: ILoadTask): Promise<VideoTexture>;
    }
    class TextureLoader implements IResourceLoader {
        wrapTex2D(task: ILoadTask, tex2D: Texture2D): Texture;
        load(task: ILoadTask): Promise<Texture>;
    }
    /**
     * 地图的每层都会分块渲染处理
     * 本类就是地图的块数据
     * @author ...
     */
    class GridSprite extends Sprite {
        /**相对于地图X轴的坐标*/
        relativeX: number;
        /**相对于地图Y轴的坐标*/
        relativeY: number;
        /**是否用于对象层的独立物件*/
        isAloneObject: boolean;
        /**当前GRID中是否有动画*/
        isHaveAnimation: boolean;
        /**当前GRID包含的动画*/
        aniSpriteArray: any[];
        /**当前GRID包含多少个TILE(包含动画)*/
        drawImageNum: number;
        private _map;
        /**
         * 传入必要的参数，用于裁剪，跟确认此对象类型
         * @param	map	把地图的引用传进来，参与一些裁剪计算
         * @param	objectKey true:表示当前GridSprite是个活动对象，可以控制，false:地图层的组成块
         */
        initData(map: TiledMap, objectKey?: boolean): void;
        /**
         * 把一个动画对象绑定到当前GridSprite
         * @param	sprite 动画的显示对象
         */
        addAniSprite(sprite: TileAniSprite): void;
        /**
         * 显示当前GridSprite，并把上面的动画全部显示
         */
        show(): void;
        /**
         * 隐藏当前GridSprite，并把上面绑定的动画全部移除
         */
        hide(): void;
        /**
         * 刷新坐标，当我们自己控制一个GridSprite移动时，需要调用此函数，手动刷新
         */
        updatePos(): void;
        /**
         * 重置当前对象的所有属性
         */
        clearAll(): void;
    }
    /**
     * 地图支持多层渲染（例如，地表层，植被层，建筑层等）
     * 本类就是层级类
     * @author ...
     */
    class MapLayer extends Sprite {
        private _map;
        private _tileWidthHalf;
        private _tileHeightHalf;
        private _mapWidthHalf;
        private _mapHeightHalf;
        private _objDic;
        private _dataDic;
        private _tempMapPos;
        private _properties;
        /**被合到的层*/
        tarLayer: MapLayer;
        /**当前Layer的名称*/
        layerName: string;
        /**
         * 解析LAYER数据，以及初始化一些数据
         * @param	layerData 地图数据中，layer数据的引用
         * @param	map 地图的引用
         */
        init(layerData: any, map: TiledMap): void;
        /******************************************对外接口*********************************************/
        /**
         * 通过名字获取控制对象，如果找不到返回为null
         * @param	objName 所要获取对象的名字
         * @return
         */
        getObjectByName(objName: string): GridSprite;
        /**
         * 通过名字获取数据，如果找不到返回为null
         * @param	objName 所要获取对象的名字
         * @return
         */
        getObjectDataByName(objName: string): any;
        /**
         * 得到地图层的自定义属性
         * @param	name
         * @return
         */
        getLayerProperties(name: string): any;
        /**
         * 得到指定格子的数据
         * @param	tileX 格子坐标X
         * @param	tileY 格子坐标Y
         * @return
         */
        getTileData(tileX: number, tileY: number): number;
        /**
         * 通过地图坐标得到屏幕坐标
         * @param	tileX 格子坐标X
         * @param	tileY 格子坐标Y
         * @param	screenPos 把计算好的屏幕坐标数据，放到此对象中
         */
        getScreenPositionByTilePos(tileX: number, tileY: number, screenPos?: Point): void;
        /**
         * 通过屏幕坐标来获取选中格子的数据
         * @param	screenX 屏幕坐标x
         * @param	screenY 屏幕坐标y
         * @return
         */
        getTileDataByScreenPos(screenX: number, screenY: number): number;
        /**
         * 通过屏幕坐标来获取选中格子的索引
         * @param	screenX 屏幕坐标x
         * @param	screenY 屏幕坐标y
         * @param	result 把计算好的格子坐标，放到此对象中
         * @return
         */
        getTilePositionByScreenPos(screenX: number, screenY: number, result?: Point): boolean;
        /***********************************************************************************************/
        /**
         * 得到一个GridSprite
         * @param	gridX 当前Grid的X轴索引
         * @param	gridY 当前Grid的Y轴索引
         * @return  一个GridSprite对象
         */
        getDrawSprite(gridX: number, gridY: number): GridSprite;
        /**
         * 更新此层中块的坐标
         * 手动刷新的目的是，保持层级的宽和高保持最小，加快渲染
         */
        updateGridPos(): void;
        /**
         * @private
         * 把tile画到指定的显示对象上
         * @param	gridSprite 被指定显示的目标
         * @param	tileX 格子的X轴坐标
         * @param	tileY 格子的Y轴坐标
         * @return
         */
        drawTileTexture(gridSprite: GridSprite, tileX: number, tileY: number): boolean;
        /**
         * @private
         * 清理当前对象
         */
        clearAll(): void;
    }
    /**
     * TildMap的动画显示对象（一个动画（TileTexSet），可以绑定多个动画显示对象（TileAniSprite））
     * @author ...
     */
    class TileAniSprite extends Sprite {
        private _tileTextureSet;
        private _aniName;
        /**
         * 确定当前显示对象的名称以及属于哪个动画
         * @param	aniName	当前动画显示对象的名字，名字唯一
         * @param	tileTextureSet 当前显示对象属于哪个动画（一个动画，可以绑定多个同类显示对象）
         */
        setTileTextureSet(aniName: string, tileTextureSet: TileTexSet): void;
        /**
         * 把当前动画加入到对应的动画刷新列表中
         */
        show(): void;
        /**
         * 把当前动画从对应的动画刷新列表中移除
         */
        hide(): void;
        /**
         * 清理
         */
        clearAll(): void;
    }
    /**
     * tiledMap是整个地图的核心
     * 地图以层级来划分地图（例如：地表层，植被层，建筑层）
     * 每层又以分块（GridSprite)来处理显示对象，只显示在视口区域的区
     * 每块又包括N*N个格子（tile)
     * 格子类型又分为动画格子跟图片格子两种
     * @author ...
     */
    class TiledMap {
        /**四边形地图*/
        static ORIENTATION_ORTHOGONAL: string;
        /**菱形地图*/
        static ORIENTATION_ISOMETRIC: string;
        /**45度交错地图*/
        static ORIENTATION_STAGGERED: string;
        /**六边形地图*/
        static ORIENTATION_HEXAGONAL: string;
        /**地图格子从左上角开始渲染*/
        static RENDERORDER_RIGHTDOWN: string;
        /**地图格子从左下角开始渲染*/
        static RENDERORDER_RIGHTUP: string;
        /**地图格子从右上角开始渲染*/
        static RENDERORDER_LEFTDOWN: string;
        /**地图格子右下角开始渲染*/
        static RENDERORDER_LEFTUP: string;
        private _jsonData;
        private _tileTexSetArr;
        private _texArray;
        private _x;
        private _y;
        private _width;
        private _height;
        private _mapW;
        private _mapH;
        private _mapTileW;
        private _mapTileH;
        private _rect;
        private _paddingRect;
        private _mapSprite;
        private _layerArray;
        private _renderLayerArray;
        private _gridArray;
        private _showGridKey;
        private _totalGridNum;
        private _gridW;
        private _gridH;
        private _gridWidth;
        private _gridHeight;
        private _tileSetArray;
        private _currTileSet;
        private _completeHandler;
        private _mapRect;
        private _mapLastRect;
        private _index;
        private _animationDic;
        private _properties;
        private _tileProperties;
        private _tileProperties2;
        private _orientation;
        private _renderOrder;
        private _colorArray;
        private _scale;
        private _pivotScaleX;
        private _pivotScaleY;
        private _centerX;
        private _centerY;
        private _viewPortWidth;
        private _viewPortHeight;
        private _enableLinear;
        private _resPath;
        private _pathArray;
        private _limitRange;
        /**
         * 是否自动缓存没有动画的地块
         */
        autoCache: boolean;
        /**
         * 自动缓存类型,地图较大时建议使用normal
         */
        autoCacheType: string;
        /**
         * 是否合并图层,开启合并图层时，图层属性内可添加layer属性，运行时将会将相邻的layer属性相同的图层进行合并以提高性能
         */
        enableMergeLayer: boolean;
        /**
         * 是否移除被覆盖的格子,地块可添加type属性，type不为0时表示不透明，被不透明地块遮挡的地块将会被剔除以提高性能
         */
        removeCoveredTile: boolean;
        /**
         * 是否显示大格子里显示的贴图数量
         */
        showGridTextureCount: boolean;
        /**
         * 是否调整地块边缘消除缩放导致的缝隙
         */
        antiCrack: boolean;
        /**
         * 是否在加载完成之后cache所有大格子
         */
        cacheAllAfterInit: boolean;
        constructor();
        /**
         * 创建地图
         * @param	mapName 		JSON文件名字
         * @param	viewRect 		视口区域
         * @param	completeHandler 地图创建完成的回调函数
         * @param	viewRectPadding 视口扩充区域，把视口区域上、下、左、右扩充一下，防止视口移动时的穿帮
         * @param	gridSize 		grid大小
         * @param	enableLinear 	是否开启线性取样（为false时，可以解决地图黑线的问题，但画质会锐化）
         * @param	limitRange		把地图限制在显示区域
         */
        createMap(mapName: string, viewRect: Rectangle, completeHandler: Handler, viewRectPadding?: Rectangle, gridSize?: Point, enableLinear?: boolean, limitRange?: boolean): void;
        /**
         * json文件读取成功后，解析里面的纹理数据，进行加载
         * @param	e JSON数据
         */
        private onJsonComplete;
        /**
         * 合并路径
         * @param	resPath
         * @param	relativePath
         * @return
         */
        private mergePath;
        private _texutreStartDic;
        /**
         * 纹理加载完成，如果所有的纹理加载，开始初始化地图
         * @param	tex 纹理数据
         */
        private onTextureComplete;
        private adptTexture;
        /**
         * 初始化地图
         */
        private initMap;
        private addTileProperties;
        getTileUserData(id: number, sign: string, defaultV?: any): any;
        private adptTiledMapData;
        private removeCoverd;
        private collectCovers;
        /**
         * 得到一块指定的地图纹理
         * @param	index 纹理的索引值，默认从1开始
         * @return
         */
        getTexture(index: number): TileTexSet;
        /**
         * 得到地图的自定义属性
         * @param	name		属性名称
         * @return
         */
        getMapProperties(name: string): any;
        /**
         * 得到tile自定义属性
         * @param	index		地图块索引
         * @param	id			具体的TileSetID
         * @param	name		属性名称
         * @return
         */
        getTileProperties(index: number, id: number, name: string): any;
        /**
         * 通过纹理索引，生成一个可控制物件
         * @param	index 纹理的索引值，默认从1开始
         * @return
         */
        getSprite(index: number, width: number, height: number): GridSprite;
        /**
         * 设置视口的缩放中心点（例如：scaleX= scaleY= 0.5,就是以视口中心缩放）
         * @param	scaleX
         * @param	scaleY
         */
        setViewPortPivotByScale(scaleX: number, scaleY: number): void;
        /**
         * 设置地图缩放
         * @param	scale
         */
        set scale(scale: number);
        /**
         * 得到当前地图的缩放
         */
        get scale(): number;
        /**
         * 移动视口
         * @param	moveX 视口的坐标x
         * @param	moveY 视口的坐标y
         */
        moveViewPort(moveX: number, moveY: number): void;
        /**
         * 改变视口大小
         * @param	moveX	视口的坐标x
         * @param	moveY	视口的坐标y
         * @param	width	视口的宽
         * @param	height	视口的高
         */
        changeViewPort(moveX: number, moveY: number, width: number, height: number): void;
        /**
         * 在锚点的基础上计算，通过宽和高，重新计算视口
         * @param	width		新视口宽
         * @param	height		新视口高
         * @param	rect		返回的结果
         * @return
         */
        changeViewPortBySize(width: number, height: number, rect?: Rectangle): Rectangle;
        /**
         * 刷新视口
         */
        private updateViewPort;
        /**
         * GRID裁剪
         */
        private clipViewPort;
        /**
         * 显示指定的GRID
         * @param	gridX
         * @param	gridY
         */
        private showGrid;
        private cacheAllGrid;
        private static _tempCanvas;
        private cacheGridsArray;
        private getGridArray;
        /**
         * 隐藏指定的GRID
         * @param	gridX
         * @param	gridY
         */
        private hideGrid;
        /**
         * 得到对象层上的某一个物品
         * @param	layerName   层的名称
         * @param	objectName	所找物品的名称
         * @return
         */
        getLayerObject(layerName: string, objectName: string): GridSprite;
        /**
         * 销毁地图
         */
        destroy(): void;
        /****************************地图的基本数据***************************/ /**
         * 格子的宽度
         */
        get tileWidth(): number;
        /**
         * 格子的高度
         */
        get tileHeight(): number;
        /**
         * 地图的宽度
         */
        get width(): number;
        /**
         * 地图的高度
         */
        get height(): number;
        /**
         * 地图横向的格子数
         */
        get numColumnsTile(): number;
        /**
         * 地图竖向的格子数
         */
        get numRowsTile(): number;
        /**
         * @private
         * 视口x坐标
         */
        get viewPortX(): number;
        /**
         * @private
         * 视口的y坐标
         */
        get viewPortY(): number;
        /**
         * @private
         * 视口的宽度
         */
        get viewPortWidth(): number;
        /**
         * @private
         * 视口的高度
         */
        get viewPortHeight(): number;
        /**
         * 地图的x坐标
         */
        get x(): number;
        /**
         * 地图的y坐标
         */
        get y(): number;
        /**
         * 块的宽度
         */
        get gridWidth(): number;
        /**
         * 块的高度
         */
        get gridHeight(): number;
        /**
         * 地图的横向块数
         */
        get numColumnsGrid(): number;
        /**
         * 地图的坚向块数
         */
        get numRowsGrid(): number;
        /**
         * 当前地图类型
         */
        get orientation(): string;
        /**
         * tile渲染顺序
         */
        get renderOrder(): string;
        /*****************************************对外接口**********************************************/
        /**
         * 整个地图的显示容器
         * @return 地图的显示容器
         */
        mapSprite(): Sprite;
        /**
         * 得到指定的MapLayer
         * @param layerName 要找的层名称
         * @return
         */
        getLayerByName(layerName: string): MapLayer;
        /**
         * 通过索引得MapLayer
         * @param	index 要找的层索引
         * @return
         */
        getLayerByIndex(index: number): MapLayer;
    }
    /**
     * 此类是子纹理类，也包括同类动画的管理
     * TiledMap会把纹理分割成无数子纹理，也可以把其中的某块子纹理替换成一个动画序列
     * 本类的实现就是如果发现子纹理被替换成一个动画序列，animationKey会被设为true
     * 即animationKey为true,就使用TileAniSprite来做显示，把动画序列根据时间画到TileAniSprite上
     * @author ...
     */
    class TileTexSet {
        /**唯一标识*/
        gid: number;
        /**子纹理的引用*/
        texture: Texture;
        /**纹理显示时的坐标偏移X*/
        offX: number;
        /**纹理显示时的坐标偏移Y*/
        offY: number;
        /**当前要播放动画的纹理序列*/
        textureArray: any[];
        /** 当前动画每帧的时间间隔*/
        durationTimeArray: any[];
        /** 动画播放的总时间 */
        animationTotalTime: number;
        /**true表示当前纹理，是一组动画，false表示当前只有一个纹理*/
        isAnimation: boolean;
        private _spriteNum;
        private _aniDic;
        private _frameIndex;
        private _time;
        private _interval;
        private _preFrameTime;
        /**
         * 加入一个动画显示对象到此动画中
         * @param	aniName	//显示对象的名字
         * @param	sprite	//显示对象
         */
        addAniSprite(aniName: string, sprite: TileAniSprite): void;
        /**
         * 把动画画到所有注册的SPRITE上
         */
        private animate;
        private drawTexture;
        /**
         * 移除不需要更新的SPRITE
         * @param	_name
         */
        removeAniSprite(_name: string): void;
        /**
         * 显示当前动画的使用情况
         */
        showDebugInfo(): string;
        /**
         * 清理
         */
        clearAll(): void;
    }
    /**
     * @private
     * 计算贝塞尔曲线的工具类。
     */
    class Bezier {
        /**
         * 工具类单例
         */
        static I: Bezier;
        /** @private */
        private _controlPoints;
        /** @private */
        private _calFun;
        /** @private */
        private _switchPoint;
        /**
         * 计算二次贝塞尔点。
         */
        getPoint2(t: number, rst: any[]): void;
        /**
         * 计算三次贝塞尔点
         */
        getPoint3(t: number, rst: any[]): void;
        /**
         * 计算贝塞尔点序列
         */
        insertPoints(count: number, rst: any[]): void;
        /**
         * 获取贝塞尔曲线上的点。
         * @param pList 控制点[x0,y0,x1,y1...]
         * @param inSertCount 每次曲线的插值数量
         */
        getBezierPoints(pList: any[], inSertCount?: number, count?: number): any[];
    }
    /**
     * <code>Color</code> 类用于创建颜色实例。
     */
    class Color implements IClone {
        /**
         * 红色
         */
        static RED: Color;
        /**
         * 绿色
         */
        static GREEN: Color;
        /**
         * 蓝色
         */
        static BLUE: Color;
        /**
         * 蓝绿色
         */
        static CYAN: Color;
        /**
         * 黄色
         */
        static YELLOW: Color;
        /**
         * 品红色
         */
        static MAGENTA: Color;
        /**
         * 灰色
         */
        static GRAY: Color;
        /**
         * 白色
         */
        static WHITE: Color;
        /**
         * 黑色
         */
        static BLACK: Color;
        /**
         * 全透明
         */
        static CLEAR: Color;
        /**
         * Gamma空间值转换到线性空间。
         * @param value gamma空间值。
         */
        static gammaToLinearSpace(value: number): number;
        /**
         * 线性空间值转换到Gamma空间。
         * @param value 线性空间值。
         */
        static linearToGammaSpace(value: number): number;
        /**red分量*/
        r: number;
        /**green分量*/
        g: number;
        /**blue分量*/
        b: number;
        /**alpha分量*/
        a: number;
        /**
         * 创建一个 <code>Color</code> 实例。
         * @param	r  颜色的red分量。
         * @param	g  颜色的green分量。
         * @param	b  颜色的blue分量。
         * @param	a  颜色的alpha分量。
         */
        constructor(r?: number, g?: number, b?: number, a?: number);
        equal(c: Color): boolean;
        /**
         * Gamma空间转换到线性空间。
         * @param	linear 线性空间颜色。
         */
        toLinear(out: Color): void;
        /**
         * 线性空间转换到Gamma空间。
         * @param	gamma Gamma空间颜色。
         */
        toGamma(out: Color): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        scale(value: number): Color;
        setValue(r: number, g: number, b: number, a: number): void;
        /**
         * 从Array数组拷贝值。
         * @param  array 数组。
         * @param  offset 数组偏移。
         */
        fromArray(array: any[], offset?: number): void;
        /**
         * 转换为Array数组
         * @return
         */
        toArray(): Array<number>;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
    }
    /**
     * @private
     * 凸包算法。
     */
    class GrahamScan {
        private static _mPointList;
        private static _tempPointList;
        private static _temPList;
        private static _temArr;
        static multiply(p1: Point, p2: Point, p0: Point): number;
        /**
         * 计算两个点的距离。
         * @param	p1
         * @param	p2
         * @return
         */
        static dis(p1: Point, p2: Point): number;
        private static _getPoints;
        /**
         * 将数组 src 从索引0位置 依次取 cout 个项添加至 tst 数组的尾部。
         * @param	rst 原始数组，用于添加新的子元素。
         * @param	src 用于取子元素的数组。
         * @param	count 需要取得子元素个数。
         * @return 添加完子元素的 rst 对象。
         */
        static getFrom(rst: any[], src: any[], count: number): any[];
        /**
         * 将数组 src 从末尾索引位置往头部索引位置方向 依次取 cout 个项添加至 tst 数组的尾部。
         * @param	rst 原始数组，用于添加新的子元素。
         * @param	src 用于取子元素的数组。
         * @param	count 需要取得子元素个数。
         * @return 添加完子元素的 rst 对象。
         */
        static getFromR(rst: any[], src: any[], count: number): any[];
        /**
         *  [x,y...]列表 转 Point列表
         * @param pList Point列表
         * @return [x,y...]列表
         */
        static pListToPointList(pList: any[], tempUse?: boolean): any[];
        /**
         * Point列表转[x,y...]列表
         * @param pointList Point列表
         * @return [x,y...]列表
         */
        static pointListToPlist(pointList: any[]): any[];
        /**
         *  寻找包括所有点的最小多边形顶点集合
         * @param pList 形如[x0,y0,x1,y1...]的点列表
         * @return  最小多边形顶点集合
         */
        static scanPList(pList: any[]): any[];
        /**
         * 寻找包括所有点的最小多边形顶点集合
         * @param PointSet Point列表
         * @return 最小多边形顶点集合
         */
        static scan(PointSet: any[]): any[];
    }
    /**
         * @private
         * <code>MathUtil</code> 是一个数据处理工具类。
         */
    class MathUtil {
        static subtractVector3(l: Float32Array, r: Float32Array, o: Float32Array): void;
        static lerp(left: number, right: number, amount: number): number;
        static scaleVector3(f: Float32Array, b: number, e: Float32Array): void;
        static lerpVector3(l: Float32Array, r: Float32Array, t: number, o: Float32Array): void;
        static lerpVector4(l: Float32Array, r: Float32Array, t: number, o: Float32Array): void;
        static slerpQuaternionArray(a: Float32Array, Offset1: number, b: Float32Array, Offset2: number, t: number, out: Float32Array, Offset3: number): Float32Array;
        /**
         * 获取指定的两个点组成的线段的角度值。
         * @param	x0 点一的 X 轴坐标值。
         * @param	y0 点一的 Y 轴坐标值。
         * @param	x1 点二的 X 轴坐标值。
         * @param	y1 点二的 Y 轴坐标值。
         * @return 角度值。
         */
        static getRotation(x0: number, y0: number, x1: number, y1: number): number;
        /**
         * 一个用来确定数组元素排序顺序的比较函数。
         * @param	a 待比较数字。
         * @param	b 待比较数字。
         * @return 如果a等于b 则值为0；如果b>a则值为1；如果b<则值为-1。
         */
        static sortBigFirst(a: number, b: number): number;
        /**
         * 一个用来确定数组元素排序顺序的比较函数。
         * @param	a 待比较数字。
         * @param	b 待比较数字。
         * @return 如果a等于b 则值为0；如果b>a则值为-1；如果b<则值为1。
         */
        static sortSmallFirst(a: number, b: number): number;
        /**
         * 将指定的元素转为数字进行比较。
         * @param	a 待比较元素。
         * @param	b 待比较元素。
         * @return b、a转化成数字的差值 (b-a)。
         */
        static sortNumBigFirst(a: any, b: any): number;
        /**
         * 将指定的元素转为数字进行比较。
         * @param	a 待比较元素。
         * @param	b 待比较元素。
         * @return a、b转化成数字的差值 (a-b)。
         */
        static sortNumSmallFirst(a: any, b: any): number;
        /**
         * 返回根据对象指定的属性进行排序的比较函数。
         * @param	key 排序要依据的元素属性名。
         * @param	bigFirst 如果值为true，则按照由大到小的顺序进行排序，否则按照由小到大的顺序进行排序。
         * @param	forceNum 如果值为true，则将排序的元素转为数字进行比较。
         * @return 排序函数。
         */
        static sortByKey(key: string, bigFirst?: boolean, forceNum?: boolean): (a: any, b: any) => number;
    }
    /**
     * <code>MathUtils3D</code> 类用于创建数学工具。
     */
    class MathUtils3D {
        /**单精度浮点(float)零的容差*/
        static zeroTolerance: number;
        /**浮点数默认最大值*/
        static MaxValue: number;
        /**浮点数默认最小值*/
        static MinValue: number;
        /**角度转弧度系数*/
        static Deg2Rad: number;
        /**
         * 创建一个 <code>MathUtils</code> 实例。
         */
        constructor();
        /**
         * 是否在容差的范围内近似于0
         * @param  判断值
         * @return  是否近似于0
         */
        static isZero(v: number): boolean;
        /**
         * 两个值是否在容差的范围内近似相等Sqr Magnitude
         * @param  判断值
         * @return  是否近似于0
         */
        static nearEqual(n1: number, n2: number): boolean;
        static fastInvSqrt(value: number): number;
    }
    /**
     * <p> <code>Matrix</code> 类表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。</p>
     * <p>您可以对一个显示对象执行不同的图形转换，方法是设置 Matrix 对象的属性，将该 Matrix 对象应用于 Transform 对象的 matrix 属性，然后应用该 Transform 对象作为显示对象的 transform 属性。这些转换函数包括平移（x 和 y 重新定位）、旋转、缩放和倾斜。</p>
     */
    class Matrix {
        /**@private 一个初始化的 <code>Matrix</code> 对象，不允许修改此对象内容。*/
        static EMPTY: Matrix;
        /**用于中转使用的 <code>Matrix</code> 对象。*/
        static TEMP: Matrix;
        /**缩放或旋转图像时影响像素沿 x 轴定位的值。*/
        a: number;
        /**旋转或倾斜图像时影响像素沿 y 轴定位的值。*/
        b: number;
        /**旋转或倾斜图像时影响像素沿 x 轴定位的值。*/
        c: number;
        /**缩放或旋转图像时影响像素沿 y 轴定位的值。*/
        d: number;
        /**沿 x 轴平移每个点的距离。*/
        tx: number;
        /**沿 y 轴平移每个点的距离。*/
        ty: number;
        /**
         * 使用指定参数创建新的 <code>Matrix</code> 对象。
         * @param a		（可选）缩放或旋转图像时影响像素沿 x 轴定位的值。
         * @param b		（可选）旋转或倾斜图像时影响像素沿 y 轴定位的值。
         * @param c		（可选）旋转或倾斜图像时影响像素沿 x 轴定位的值。
         * @param d		（可选）缩放或旋转图像时影响像素沿 y 轴定位的值。
         * @param tx	（可选）沿 x 轴平移每个点的距离。
         * @param ty	（可选）沿 y 轴平移每个点的距离。
         */
        constructor(a?: number, b?: number, c?: number, d?: number, tx?: number, ty?: number, nums?: number);
        /**
         * 将本矩阵设置为单位矩阵。
         * @return 返回当前矩形。
         */
        identity(): Matrix;
        /**
         * 设置沿 x 、y 轴平移每个点的距离。
         * @param	x 沿 x 轴平移每个点的距离。
         * @param	y 沿 y 轴平移每个点的距离。
         * @return	返回对象本身
         */
        setTranslate(x: number, y: number): Matrix;
        /**
         * 沿 x 和 y 轴平移矩阵，平移的变化量由 x 和 y 参数指定。
         * @param	x 沿 x 轴向右移动的量（以像素为单位）。
         * @param	y 沿 y 轴向下移动的量（以像素为单位）。
         * @return 返回此矩形对象。
         */
        translate(x: number, y: number): Matrix;
        /**
         * 对矩阵应用缩放转换。
         * @param	x 用于沿 x 轴缩放对象的乘数。
         * @param	y 用于沿 y 轴缩放对象的乘数。
         * @return	返回矩阵对象本身
         */
        scale(x: number, y: number): Matrix;
        /**
         * 对 Matrix 对象应用旋转转换。
         * @param	angle 以弧度为单位的旋转角度。
         * @return	返回矩阵对象本身
         */
        rotate(angle: number): Matrix;
        /**
         * 对 Matrix 对象应用倾斜转换。
         * @param	x 沿着 X 轴的 2D 倾斜弧度。
         * @param	y 沿着 Y 轴的 2D 倾斜弧度。
         * @return 当前 Matrix 对象。
         */
        skew(x: number, y: number): Matrix;
        /**
         * 对指定的点应用当前矩阵的逆转化并返回此点。
         * @param	out 待转化的点 Point 对象。
         * @return	返回out
         */
        invertTransformPoint(out: Point): Point;
        /**
         * 将 Matrix 对象表示的几何转换应用于指定点。
         * @param	out 用来设定输出结果的点。
         * @return	返回out
         */
        transformPoint(out: Point): Point;
        /**
         * 将 Matrix 对象表示的几何转换应用于指定点，忽略tx、ty。
         * @param	out 用来设定输出结果的点。
         * @return	返回out
         */
        transformPointN(out: Point): Point;
        /**
         * 获取 X 轴缩放值。
         * @return  X 轴缩放值。
         */
        getScaleX(): number;
        /**
         * 获取 Y 轴缩放值。
         * @return Y 轴缩放值。
         */
        getScaleY(): number;
        /**
         * 执行原始矩阵的逆转换。
         * @return 当前矩阵对象。
         */
        invert(): Matrix;
        /**
         *  将 Matrix 的成员设置为指定值。
         * @param	a 缩放或旋转图像时影响像素沿 x 轴定位的值。
         * @param	b 旋转或倾斜图像时影响像素沿 y 轴定位的值。
         * @param	c 旋转或倾斜图像时影响像素沿 x 轴定位的值。
         * @param	d 缩放或旋转图像时影响像素沿 y 轴定位的值。
         * @param	tx 沿 x 轴平移每个点的距离。
         * @param	ty 沿 y 轴平移每个点的距离。
         * @return 当前矩阵对象。
         */
        setTo(a: number, b: number, c: number, d: number, tx: number, ty: number): Matrix;
        /**
         * 将指定矩阵与当前矩阵连接，从而将这两个矩阵的几何效果有效地结合在一起。
         * @param	matrix 要连接到源矩阵的矩阵。
         * @return	当前矩阵。
         */
        concat(matrix: Matrix): Matrix;
        /**
         * 将指定的两个矩阵相乘后的结果赋值给指定的输出对象。
         * @param	m1 矩阵一。
         * @param	m2 矩阵二。
         * @param	out 输出对象。
         * @return	结果输出对象 out。
         */
        static mul(m1: Matrix, m2: Matrix, out: Matrix): Matrix;
        /**
         * 将指定的两个矩阵相乘，结果赋值给指定的输出数组，长度为16。
         * @param m1	矩阵一。
         * @param m2	矩阵二。
         * @param out	输出对象Array。
         * @return 结果输出对象 out。
         */
        static mul16(m1: Matrix, m2: Matrix, out: any[]): any[];
        /**
         * @private
         * 对矩阵应用缩放转换。反向相乘
         * @param	x 用于沿 x 轴缩放对象的乘数。
         * @param	y 用于沿 y 轴缩放对象的乘数。
         */
        scaleEx(x: number, y: number): void;
        /**
         * @private
         * 对 Matrix 对象应用旋转转换。反向相乘
         * @param	angle 以弧度为单位的旋转角度。
         */
        rotateEx(angle: number): void;
        /**
         * 返回此 Matrix 对象的副本。
         * @return 与原始实例具有完全相同的属性的新 Matrix 实例。
         */
        clone(): Matrix;
        /**
         * 将当前 Matrix 对象中的所有矩阵数据复制到指定的 Matrix 对象中。
         * @param	dec 要复制当前矩阵数据的 Matrix 对象。
         * @return	已复制当前矩阵数据的 Matrix 对象。
         */
        copyTo(dec: Matrix): Matrix;
        /**
         * 返回列出该 Matrix 对象属性的文本值。
         * @return 一个字符串，它包含 Matrix 对象的属性值：a、b、c、d、tx 和 ty。
         */
        toString(): string;
        /**
         * 销毁此对象。
         */
        destroy(): void;
        /**
         * 回收到对象池，方便复用
         */
        recover(): void;
        /**
         * 从对象池中创建一个 <code>Matrix</code> 对象。
         * @return <code>Matrix</code> 对象。
         */
        static create(): Matrix;
    }
    /**
     * <code>Matrix3x3</code> 类用于创建3x3矩阵。
     */
    class Matrix3x3 implements IClone {
        static readonly DEFAULT: Readonly<Matrix3x3>;
        static Temp: Matrix3x3;
        /**
         * 通过四元数创建旋转矩阵。
         * @param rotation 旋转四元数。
         * @param out 旋转矩阵。
         */
        static createRotationQuaternion(rotation: Quaternion, out: Matrix3x3): void;
        /**
         * 根据指定平移生成3x3矩阵
         * @param	tra 平移
         * @param	out 输出矩阵
         */
        static createFromTranslation(trans: Vector2, out: Matrix3x3): void;
        /**
         * 根据指定旋转生成3x3矩阵
         * @param	rad  旋转值
         * @param	out 输出矩阵
         */
        static createFromRotation(rad: number, out: Matrix3x3): void;
        /**
         * 根据制定缩放生成3x3矩阵
         * @param	scale 缩放值
         * @param	out 输出矩阵
         */
        static createFromScaling(scale: Vector3, out: Matrix3x3): void;
        /**
         * 从4x4矩阵转换为一个3x3的矩阵（原则为upper-left,忽略第四行四列）
         * @param	sou 4x4源矩阵
         * @param	out 3x3输出矩阵
         */
        static createFromMatrix4x4(sou: Matrix4x4, out: Matrix3x3): void;
        /**
         *  两个3x3矩阵的相乘
         * @param	left 左矩阵
         * @param	right  右矩阵
         * @param	out  输出矩阵
         */
        static multiply(left: Matrix3x3, right: Matrix3x3, out: Matrix3x3): void;
        /**矩阵元素数组*/
        elements: Float32Array;
        /**
         * 创建一个 <code>Matrix3x3</code> 实例。
         */
        constructor(createElement?: boolean);
        /**
         * 克隆
         * @param destObject
         */
        cloneByArray(destObject: Float32Array): void;
        /**
         * 计算3x3矩阵的行列式
         * @return    矩阵的行列式
         */
        determinant(): number;
        /**
         * 通过一个二维向量转换3x3矩阵
         * @param	tra 转换向量
         * @param	out 输出矩阵
         */
        translate(trans: Vector2, out: Matrix3x3): void;
        /**
         * 根据指定角度旋转3x3矩阵
         * @param	rad 旋转角度
         * @param	out 输出矩阵
         */
        rotate(rad: number, out: Matrix3x3): void;
        /**
         *根据制定缩放3x3矩阵
         * @param	scale 缩放值
         * @param	out 输出矩阵
         */
        scale(scale: Vector2, out: Matrix3x3): void;
        /**
         * 计算3x3矩阵的逆矩阵
         * @param	out 输出的逆矩阵
         */
        invert(out: Matrix3x3): void;
        /**
         * 计算3x3矩阵的转置矩阵
         * @param 	out 输出矩阵
         */
        transpose(out: Matrix3x3): void;
        /** 设置已有的矩阵为单位矩阵*/
        identity(): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
        /**
         * 计算观察3x3矩阵
         * @param	eye    观察者位置
         * @param	target 目标位置
         * @param	up     上向量
         * @param	out    输出3x3矩阵
         */
        static lookAt(eye: Vector3, target: Vector3, up: Vector3, out: Matrix3x3): void;
        /**
         * forward看向target
         * forward在这里规定为z轴
         * @param eye
         * @param target 目标
         * @param up
         * @param out
         */
        static forwardLookAt(eye: Vector3, target: Vector3, up: Vector3, out: Matrix3x3): void;
    }
    /**
     * <code>Matrix4x4</code> 类用于创建4x4矩阵。
     */
    class Matrix4x4 implements IClone {
        /**默认矩阵,禁止修改*/
        static readonly DEFAULT: Readonly<Matrix4x4>;
        static readonly DEFAULTINVERT: Readonly<Matrix4x4>;
        /**默认矩阵,禁止修改*/
        static readonly ZERO: Readonly<Matrix4x4>;
        /**
         * 绕X轴旋转
         * @param	rad  旋转角度
         * @param	out 输出矩阵
         */
        static createRotationX(rad: number, out: Matrix4x4): void;
        /**
         *
         * 绕Y轴旋转
         * @param	rad  旋转角度
         * @param	out 输出矩阵
         */
        static createRotationY(rad: number, out: Matrix4x4): void;
        /**
         * 绕Z轴旋转
         * @param	rad  旋转角度
         * @param	out 输出矩阵
         */
        static createRotationZ(rad: number, out: Matrix4x4): void;
        /**
         * 通过yaw pitch roll旋转创建旋转矩阵。
         * @param	yaw
         * @param	pitch
         * @param	roll
         * @param	result
         */
        static createRotationYawPitchRoll(yaw: number, pitch: number, roll: number, result: Matrix4x4): void;
        /**
         * 通过旋转轴axis和旋转角度angle计算旋转矩阵。
         * @param	axis 旋转轴,假定已经归一化。
         * @param	angle 旋转角度。
         * @param	result 结果矩阵。
         */
        static createRotationAxis(axis: Vector3, angle: number, result: Matrix4x4): void;
        /**
         * 通过四元数创建旋转矩阵。
         * @param	rotation 旋转四元数。
         * @param	result 输出旋转矩阵
         */
        static createRotationQuaternion(rotation: Quaternion, result: Matrix4x4): void;
        /**
         * 根据平移计算输出矩阵
         * @param	trans  平移向量
         * @param	out 输出矩阵
         */
        static createTranslate(trans: Vector3, out: Matrix4x4): void;
        /**
         * 根据缩放计算输出矩阵
         * @param	scale  缩放值
         * @param	out 输出矩阵
         */
        static createScaling(scale: Vector3, out: Matrix4x4): void;
        /**
         * 计算两个矩阵的乘法
         * @param	left left矩阵
         * @param	right  right矩阵
         * @param	out  输出矩阵
         */
        static multiply(left: Matrix4x4, right: Matrix4x4, out: Matrix4x4): void;
        /**
         * 从四元数计算旋转矩阵
         * @param	rotation 四元数
         * @param	out 输出矩阵
         */
        static createFromQuaternion(rotation: Quaternion, out: Matrix4x4): void;
        /**
         * 计算仿射矩阵
         * @param	trans 平移
         * @param	rot 旋转
         * @param	scale 缩放
         * @param	out 输出矩阵
         */
        static createAffineTransformation(trans: Vector3, rot: Quaternion, scale: Vector3, out: Matrix4x4): void;
        /**
         * 计算观察矩阵
         * @param	eye 视点位置
         * @param	target 视点目标
         * @param	up 向上向量
         * @param	out 输出矩阵
         */
        static createLookAt(eye: Vector3, target: Vector3, up: Vector3, out: Matrix4x4): void;
        /**
         * 通过FOV创建透视投影矩阵。
         * @param	fov  视角。
         * @param	aspect 横纵比。
         * @param	near 近裁面。
         * @param	far 远裁面。
         * @param	out 输出矩阵。
         */
        static createPerspective(fov: number, aspect: number, znear: number, zfar: number, out: Matrix4x4): void;
        /**
         * 创建透视投影矩阵。
         * @param	left 视椎左边界。
         * @param	right 视椎右边界。
         * @param	bottom 视椎底边界。
         * @param	top 视椎顶边界。
         * @param	znear 视椎近边界。
         * @param	zfar 视椎远边界。
         * @param	out 输出矩阵。
         */
        static createPerspectiveOffCenter(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, out: Matrix4x4): void;
        /**
         * 计算正交投影矩阵。
         * @param	left 视椎左边界。
         * @param	right 视椎右边界。
         * @param	bottom 视椎底边界。
         * @param	top 视椎顶边界。
         * @param	near 视椎近边界。
         * @param	far 视椎远边界。
         * @param	out 输出矩阵。
         */
        static createOrthoOffCenter(left: number, right: number, bottom: number, top: number, znear: number, zfar: number, out: Matrix4x4): void;
        /**矩阵元素数组*/
        elements: Float32Array;
        /**
         * 创建一个 <code>Matrix4x4</code> 实例。
         * @param	4x4矩阵的各元素
         */
        constructor(m11?: number, m12?: number, m13?: number, m14?: number, m21?: number, m22?: number, m23?: number, m24?: number, m31?: number, m32?: number, m33?: number, m34?: number, m41?: number, m42?: number, m43?: number, m44?: number, elements?: Float32Array);
        /**
      * 四元数生成矩阵
      * @param rotation
      */
        setRotation(rotation: Quaternion): void;
        /**
         * 位置
         * @param position
         */
        setPosition(position: Vector3): void;
        /**
         * 判断两个4x4矩阵的值是否相等。
         * @param	other 4x4矩阵
         */
        equalsOtherMatrix(other: Matrix4x4): boolean;
        /**
         * 分解矩阵为平移向量、旋转四元数、缩放向量。
         * @param	translation 平移向量。
         * @param	rotation 旋转四元数。
         * @param	scale 缩放向量。
         * @return 是否分解成功。
         */
        decomposeTransRotScale(translation: Vector3, rotation: Quaternion, scale: Vector3): boolean;
        /**
         * 分解矩阵为平移向量、旋转矩阵、缩放向量。
         * @param	translation 平移向量。
         * @param	rotationMatrix 旋转矩阵。
         * @param	scale 缩放向量。
         * @return 是否分解成功。
         */
        decomposeTransRotMatScale(translation: Vector3, rotationMatrix: Matrix4x4, scale: Vector3): boolean;
        /**
         * 分解旋转矩阵的旋转为YawPitchRoll欧拉角。
         * @param	out float yaw
         * @param	out float pitch
         * @param	out float roll
         * @return
         */
        decomposeYawPitchRoll(yawPitchRoll: Vector3): void;
        /**
         * 归一化矩阵
         */
        normalize(): void;
        /**
         * 计算矩阵的转置矩阵
         */
        transpose(): Matrix4x4;
        /**
         * 计算一个矩阵的逆矩阵
         * @param	out 输出矩阵
         */
        invert(out: Matrix4x4): void;
        /**
         * 计算BlillBoard矩阵
         * @param	objectPosition 物体位置
         * @param	cameraPosition 相机位置
         * @param	cameraUp       相机上向量
         * @param	cameraForward  相机前向量
         * @param	mat            变换矩阵
         */
        static billboard(objectPosition: Vector3, cameraPosition: Vector3, cameraUp: Vector3, cameraForward: Vector3, mat: Matrix4x4): void;
        /**
         * 归一化
         */
        identity(): void;
        /**判断是否是单位矩阵 */
        isIdentity(): boolean;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆
         * @param destObject
         */
        cloneByArray(destObject: Float32Array): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
        static translation(v3: Vector3, out: Matrix4x4): void;
        /**
         * 获取平移向量。
         * @param	out 平移向量。
         */
        getTranslationVector(out: Vector3): void;
        /**
         * 设置平移向量。
         * @param	translate 平移向量。
         */
        setTranslationVector(translate: Vector3): void;
        /**
         * 获取前向量。
         * @param	out 前向量。
         */
        getForward(out: Vector3): void;
        /**
         * 设置前向量。
         * @param	forward 前向量。
         */
        setForward(forward: Vector3): void;
        /**
         * 判断此矩阵是否是反向矩阵
         */
        getInvertFront(): boolean;
    }
    /**
     * <code>Point</code> 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
     */
    class Point {
        /**临时使用的公用对象。*/
        static TEMP: Point;
        /**@private 全局空的point对象(x=0，y=0)，不允许修改此对象内容*/
        static EMPTY: Point;
        /**该点的水平坐标。*/
        x: number;
        /**该点的垂直坐标。*/
        y: number;
        /**
         * 根据指定坐标，创建一个新的 <code>Point</code> 对象。
         * @param x	（可选）水平坐标。
         * @param y	（可选）垂直坐标。
         */
        constructor(x?: number, y?: number);
        /**
         * 从对象池创建
         */
        static create(): Point;
        /**
         * 将 <code>Point</code> 的成员设置为指定值。
         * @param	x 水平坐标。
         * @param	y 垂直坐标。
         * @return 当前 Point 对象。
         */
        setTo(x: number, y: number): Point;
        /**
         * 重置
         */
        reset(): Point;
        /**
         * 回收到对象池，方便复用
         */
        recover(): void;
        /**
         * 计算当前点和目标点(x，y)的距离。
         * @param	x 水平坐标。
         * @param	y 垂直坐标。
         * @return	返回当前点和目标点之间的距离。
         */
        distance(x: number, y: number): number;
        /**返回包含 x 和 y 坐标的值的字符串。*/
        toString(): string;
        /**
         * 标准化向量。
         */
        normalize(): void;
        /**
         * copy point坐标
         * @param	point 需要被copy的point
         */
        copy(point: Point): Point;
    }
    /**
     * <code>Quaternion</code> 类用于创建四元数。
     */
    class Quaternion implements IClone {
        /**默认矩阵,禁止修改*/
        static readonly DEFAULT: Readonly<Quaternion>;
        /**无效矩阵,禁止修改*/
        static readonly NAN: Readonly<Quaternion>;
        /**
         *  从欧拉角生成四元数（顺序为Yaw、Pitch、Roll）
         * @param	yaw yaw值
         * @param	pitch pitch值
         * @param	roll roll值
         * @param	out 输出四元数
         */
        static createFromYawPitchRoll(yaw: number, pitch: number, roll: number, out: Quaternion): void;
        /**
         * 计算两个四元数相乘
         * @param	left left四元数
         * @param	right  right四元数
         * @param	out 输出四元数
         */
        static multiply(left: Quaternion, right: Quaternion, out: Quaternion): void;
        /**
       * Calculate a quaternion rotates around an arbitrary axis.
       * @param axis - The axis
       * @param rad - The rotation angle in radians
       * @param out - The quaternion after rotate
       */
        static rotationAxisAngle(axis: Vector3, rad: number, out: Quaternion): void;
        private static arcTanAngle;
        private static angleTo;
        /**
         * 从指定的轴和角度计算四元数
         * @param	axis  轴
         * @param	rad  角度
         * @param	out  输出四元数
         */
        static createFromAxisAngle(axis: Vector3, rad: number, out: Quaternion): void;
        /**
         *  从旋转矩阵计算四元数
         * @param	mat 旋转矩阵
         * @param	out  输出四元数
         */
        static createFromMatrix4x4(mat: Matrix4x4, out: Quaternion): void;
        /**
         * 球面插值
         * @param	left left四元数
         * @param	right  right四元数
         * @param	t 插值比例
         * @param	out 输出四元数
         * @returns 输出Float32Array
         */
        static slerp(left: Quaternion, right: Quaternion, t: number, out: Quaternion): Quaternion;
        /**
         * 计算两个四元数的线性插值
         * @param	left left四元数
         * @param	right right四元数b
         * @param	t 插值比例
         * @param	out 输出四元数
         */
        static lerp(left: Quaternion, right: Quaternion, amount: number, out: Quaternion): void;
        /**
         * 计算两个四元数的和
         * @param	left  left四元数
         * @param	right right 四元数
         * @param	out 输出四元数
         */
        static add(left: Quaternion, right: Quaternion, out: Quaternion): void;
        /**
         * 计算两个四元数的点积
         * @param	left left四元数
         * @param	right right四元数
         * @return  点积
         */
        static dot(left: Quaternion, right: Quaternion): number;
        /**X轴坐标*/
        x: number;
        /**Y轴坐标*/
        y: number;
        /**Z轴坐标*/
        z: number;
        /**W轴坐标*/
        w: number;
        /**
         * 创建一个 <code>Quaternion</code> 实例。
         * @param	x 四元数的x值
         * @param	y 四元数的y值
         * @param	z 四元数的z值
         * @param	w 四元数的w值
         */
        constructor(x?: number, y?: number, z?: number, w?: number);
        /**
         * 设置四元数的值。
         * @param	x X值。
         * @param	y Y值。
         * @param	z Z值。
         */
        setValue(x: number, y: number, z: number, w: number): void;
        /**
         * 设置四元数的值。
         * @param	x X值。
         * @param	y Y值。
         * @param	z Z值。
         * @return 返回四元数
         */
        set(x: number, y: number, z: number, w: number): this;
        /**
         * 根据缩放值缩放四元数
         * @param	scale 缩放值
         * @param	out 输出四元数
         */
        scaling(scaling: number, out: Quaternion): void;
        /**
         * 归一化四元数
         * @param	out 输出四元数
         */
        normalize(out: Quaternion): void;
        /**
         * 计算四元数的长度
         * @return  长度
         */
        length(): number;
        /**
         * 根据绕X轴的角度旋转四元数
         * @param	rad 角度
         * @param	out 输出四元数
         */
        rotateX(rad: number, out: Quaternion): void;
        /**
         * 根据绕Y轴的制定角度旋转四元数
         * @param	rad 角度
         * @param	out 输出四元数
         */
        rotateY(rad: number, out: Quaternion): void;
        /**
         * 根据绕Z轴的制定角度旋转四元数
         * @param	rad 角度
         * @param	out 输出四元数
         */
        rotateZ(rad: number, out: Quaternion): void;
        /**
         * 分解四元数到欧拉角（顺序为Yaw、Pitch、Roll），参考自http://xboxforums.create.msdn.com/forums/p/4574/23988.aspx#23988,问题绕X轴翻转超过±90度时有，会产生瞬间反转
         * @param	quaternion 源四元数
         * @param	out 欧拉角值
         */
        getYawPitchRoll(out: Vector3): void;
        /**
         * 求四元数的逆
         * @param	out  输出四元数
         */
        invert(out: Quaternion): void;
        /**
         *设置四元数为单位算数
         * @param out  输出四元数
         */
        identity(): void;
        /**
         * 从Array数组拷贝值。
         * @param  array 数组。
         * @param  offset 数组偏移。
         */
        fromArray(array: any[], offset?: number): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
        equals(b: Quaternion): boolean;
        /**
         * 计算旋转观察四元数
         * @param	forward 方向
         * @param	up     上向量
         * @param	out    输出四元数
         */
        static rotationLookAt(forward: Vector3, up: Vector3, out: Quaternion): void;
        /**
         * 计算观察四元数（适用Camera 灯光）
         * @param	eye    观察者位置
         * @param	target 目标位置
         * @param	up     上向量
         * @param	out    输出四元数
         */
        static lookAt(eye: Vector3, target: Vector3, up: Vector3, out: Quaternion): void;
        /**
         * 计算观察四元数（适用gameObject）
         * @param eye 观察者位置
         * @param target 目标位置
         * @param up 上向量
         * @param out 输出四元数
         */
        static forwardLookAt(eye: Vector3, target: Vector3, up: Vector3, out: Quaternion): void;
        /**
         * 计算长度的平方。
         * @return 长度的平方。
         */
        lengthSquared(): number;
        /**
         * 计算四元数的逆四元数。
         * @param	value 四元数。
         * @param	out 逆四元数。
         */
        static invert(value: Quaternion, out: Quaternion): void;
        /**
         * 通过一个3x3矩阵创建一个四元数
         * @param	matrix3x3  3x3矩阵
         * @param	out        四元数
         */
        static rotationMatrix(matrix3x3: Matrix3x3, out: Quaternion): void;
        forNativeElement(nativeElements?: Float32Array): void;
    }
    /**
     * <p><code>Rectangle</code> 对象是按其位置（由它左上角的点 (x, y) 确定）以及宽度和高度定义的区域。</p>
     * <p>Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。</p>
     */
    class Rectangle {
        /**@private 全局空的矩形区域x=0,y=0,width=0,height=0，不允许修改此对象内容*/
        static EMPTY: Rectangle;
        /**全局临时的矩形区域，此对象用于全局复用，以减少对象创建*/
        static TEMP: Rectangle;
        /** @private */
        private static _temB;
        /** @private */
        private static _temA;
        /** 矩形左上角的 X 轴坐标。*/
        x: number;
        /** 矩形左上角的 Y 轴坐标。*/
        y: number;
        /** 矩形的宽度。*/
        width: number;
        /** 矩形的高度。*/
        height: number;
        /**
         * 创建一个 <code>Rectangle</code> 对象。
         * @param	x 矩形左上角的 X 轴坐标。
         * @param	y 矩形左上角的 Y 轴坐标。
         * @param	width 矩形的宽度。
         * @param	height 矩形的高度。
         */
        constructor(x?: number, y?: number, width?: number, height?: number);
        /** 此矩形右侧的 X 轴坐标。 x 和 width 属性的和。*/
        get right(): number;
        /** 此矩形底端的 Y 轴坐标。y 和 height 属性的和。*/
        get bottom(): number;
        /**
         * 将 Rectangle 的属性设置为指定值。
         * @param	x	x 矩形左上角的 X 轴坐标。
         * @param	y	x 矩形左上角的 Y 轴坐标。
         * @param	width	矩形的宽度。
         * @param	height	矩形的高。
         * @return	返回属性值修改后的矩形对象本身。
         */
        setTo(x: number, y: number, width: number, height: number): Rectangle;
        /**
         * 重置
         */
        reset(): Rectangle;
        /**
         * 回收
         */
        recover(): void;
        /**
         * 创建
         */
        static create(): Rectangle;
        /**
         * 复制 source 对象的属性值到此矩形对象中。
         * @param	sourceRect	源 Rectangle 对象。
         * @return	返回属性值修改后的矩形对象本身。
         */
        copyFrom(source: Rectangle): Rectangle;
        /**
         * 确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。
         * @param x	点的 X 轴坐标值（水平位置）。
         * @param y	点的 Y 轴坐标值（垂直位置）。
         * @return	如果 Rectangle 对象包含指定的点，则值为 true；否则为 false。
         */
        contains(x: number, y: number): boolean;
        /**
         * 确定在 rect 参数中指定的对象是否与此 Rectangle 对象相交。此方法检查指定的 Rectangle 对象的 x、y、width 和 height 属性，以查看它是否与此 Rectangle 对象相交。
         * @param	rect Rectangle 对象。
         * @return	如果传入的矩形对象与此对象相交，则返回 true 值，否则返回 false。
         */
        intersects(rect: Rectangle): boolean;
        /**
         * 如果在 rect 参数中指定的 Rectangle 对象与此 Rectangle 对象相交，则返回交集区域作为 Rectangle 对象。如果矩形不相交，则此方法返回null。
         * @param rect	待比较的矩形区域。
         * @param out	（可选）待输出的矩形区域。如果为空则创建一个新的。建议：尽量复用对象，减少对象创建消耗。
         * @return	返回相交的矩形区域对象。
         */
        intersection(rect: Rectangle, out?: Rectangle | null): Rectangle | null;
        /**
         * <p>矩形联合，通过填充两个矩形之间的水平和垂直空间，将这两个矩形组合在一起以创建一个新的 Rectangle 对象。</p>
         * <p>注意：union() 方法忽略高度或宽度值为 0 的矩形，如：var rect2:Rectangle = new Rectangle(300,300,50,0);</p>
         * @param	要添加到此 Rectangle 对象的 Rectangle 对象。
         * @param	out	用于存储输出结果的矩形对象。如果为空，则创建一个新的。建议：尽量复用对象，减少对象创建消耗。Rectangle.TEMP对象用于对象复用。
         * @return	充当两个矩形的联合的新 Rectangle 对象。
         */
        union(source: Rectangle, out?: Rectangle | null): Rectangle;
        /**
         * 返回一个 Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
         * @param out	（可选）用于存储结果的矩形对象。如果为空，则创建一个新的。建议：尽量复用对象，减少对象创建消耗。。Rectangle.TEMP对象用于对象复用。
         * @return Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
         */
        clone(out?: Rectangle | null): Rectangle;
        /**
         * 当前 Rectangle 对象的水平位置 x 和垂直位置 y 以及高度 width 和宽度 height 以逗号连接成的字符串。
         */
        toString(): string;
        /**
         * 检测传入的 Rectangle 对象的属性是否与当前 Rectangle 对象的属性 x、y、width、height 属性值都相等。
         * @param	rect 待比较的 Rectangle 对象。
         * @return	如果判断的属性都相等，则返回 true ,否则返回 false。
         */
        equals(rect: Rectangle): boolean;
        /**
         * <p>为当前矩形对象加一个点，以使当前矩形扩展为包含当前矩形和此点的最小矩形。</p>
         * <p>此方法会修改本对象。</p>
         * @param x	点的 X 坐标。
         * @param y	点的 Y 坐标。
         * @return 返回此 Rectangle 对象。
         */
        addPoint(x: number, y: number): Rectangle;
        /**
         * 确定此 Rectangle 对象是否为空。
         * @return 如果 Rectangle 对象的宽度或高度小于等于 0，则返回 true 值，否则返回 false。
         */
        isEmpty(): boolean;
    }
    interface IV2 {
        x: number;
        y: number;
    }
    /**
     * <code>Vector2</code> 类用于创建二维向量。
     */
    class Vector2 implements IClone {
        /**零向量,禁止修改*/
        static readonly ZERO: Readonly<Vector2>;
        /**一向量,禁止修改*/
        static readonly ONE: Readonly<Vector2>;
        static TempVector2: Vector2;
        /**X轴坐标*/
        x: number;
        /**Y轴坐标*/
        y: number;
        /**
         * 创建一个 <code>Vector2</code> 实例。
         * @param	x  X轴坐标。
         * @param	y  Y轴坐标。
         */
        constructor(x?: number, y?: number);
        /**
         * 设置xy值。
         * @param	x X值。
         * @param	y Y值。
         */
        setValue(x: number, y: number): void;
        /**
         * 缩放二维向量。
         * @param	a 源二维向量。
         * @param	b 缩放值。
         * @param	out 输出二维向量。
         */
        static scale(a: Vector2, b: number, out: Vector2): void;
        /**
         * 判断两个二维向量是否相等。
         * @param	a 三维向量。
         * @param	b 三维向量。
         * @return  是否相等。
         */
        static equals(a: Vector2, b: Vector2): boolean;
        /**
         * 从Array数组拷贝值。
         * @param  array 数组。
         * @param  offset 数组偏移。
         */
        fromArray(array: ArrayLike<number>, offset?: number): void;
        /**
         * 转换为Array数组
         * @return
         */
        toArray(): Array<number>;
        /**
         * 写入Float32Array数组
         * @param array 数组。
         * @param offset 数组偏移。
         */
        writeTo(array: Float32Array, offset?: number): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 求两个二维向量的点积。
         * @param	a left向量。
         * @param	b right向量。
         * @return   点积。
         */
        static dot(a: Vector2, b: Vector2): number;
        /**
         * 归一化二维向量。
         * @param	s 源三维向量。
         * @param	out 输出三维向量。
         */
        static normalize(s: Vector2, out: Vector2): void;
        /**
         * 计算标量长度。
         * @param	a 源三维向量。
         * @return 标量长度。
         */
        static scalarLength(a: Vector2): number;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
        forNativeElement(nativeElements?: Float32Array | null): void;
        static rewriteNumProperty(proto: any, name: string, index: number): void;
    }
    /**
     * <code>Vector3</code> 类用于创建三维向量。
     */
    class Vector3 implements IClone {
        static _tempVector3: Vector3;
        static readonly ZERO: Readonly<Vector3>;
        static readonly ONE: Readonly<Vector3>;
        static readonly NegativeUnitX: Readonly<Vector3>;
        static readonly UnitX: Readonly<Vector3>;
        static readonly UnitY: Readonly<Vector3>;
        static readonly UnitZ: Readonly<Vector3>;
        static readonly ForwardRH: Readonly<Vector3>;
        static readonly ForwardLH: Readonly<Vector3>;
        static readonly Up: Readonly<Vector3>;
        /**
         * 两个三维向量距离的平方。
         * @param	value1 向量1。
         * @param	value2 向量2。
         * @return	距离的平方。
         */
        static distanceSquared(value1: Vector3, value2: Vector3): number;
        /**
         * 两个三维向量距离。
         * @param	value1 向量1。
         * @param	value2 向量2。
         * @return	距离。
         */
        static distance(value1: Vector3, value2: Vector3): number;
        /**
         * 分别取两个三维向量x、y、z的最小值计算新的三维向量。
         * @param	a。
         * @param	b。
         * @param	out。
         */
        static min(a: Vector3, b: Vector3, out: Vector3): void;
        /**
         * 分别取两个三维向量x、y、z的最大值计算新的三维向量。
         * @param	a a三维向量。
         * @param	b b三维向量。
         * @param	out 结果三维向量。
         */
        static max(a: Vector3, b: Vector3, out: Vector3): void;
        /**
         * 根据四元数旋转三维向量。
         * @param	source 源三维向量。
         * @param	rotation 旋转四元数。
         * @param	out 输出三维向量。
         */
        static transformQuat(source: Vector3, rotation: Quaternion, out: Vector3): void;
        /**
         * 计算标量长度。
         * @param	a 源三维向量。
         * @return 标量长度。
         */
        static scalarLength(a: Vector3): number;
        /**
         * 计算标量长度的平方。
         * @param	a 源三维向量。
         * @return 标量长度的平方。
         */
        static scalarLengthSquared(a: Vector3): number;
        /**
         * 归一化三维向量。
         * @param	s 源三维向量。
         * @param	out 输出三维向量。
         */
        static normalize(s: Vector3, out: Vector3): void;
        /**
         * 计算两个三维向量的乘积。
         * @param	a left三维向量。
         * @param	b right三维向量。
         * @param	out 输出三维向量。
         */
        static multiply(a: Vector3, b: Vector3, out: Vector3): void;
        /**
         * 缩放三维向量。
         * @param	a 源三维向量。
         * @param	b 缩放值。
         * @param	out 输出三维向量。
         */
        static scale(a: Vector3, b: number, out: Vector3): void;
        /**
         * 插值三维向量。
         * @param	a left向量。
         * @param	b right向量。
         * @param	t 插值比例。
         * @param	out 输出向量。
         */
        static lerp(a: Vector3, b: Vector3, t: number, out: Vector3): void;
        /**
         * 通过矩阵转换一个三维向量到另外一个三维向量。
         * @param	vector 源三维向量。
         * @param	transform  变换矩阵。
         * @param	result 输出三维向量。
         */
        static transformV3ToV3(vector: Vector3, transform: Matrix4x4, result: Vector3): void;
        /**
         * 通过矩阵转换一个三维向量到另外一个四维向量。
         * @param	vector 源三维向量。
         * @param	transform  变换矩阵。
         * @param	result 输出四维向量。
         */
        static transformV3ToV4(vector: Vector3, transform: Matrix4x4, result: Vector4): void;
        /**
         * 通过法线矩阵转换一个法线三维向量到另外一个三维向量。
         * @param	normal 源法线三维向量。
         * @param	transform  法线变换矩阵。
         * @param	result 输出法线三维向量。
         */
        static TransformNormal(normal: Vector3, transform: Matrix4x4, result: Vector3): void;
        /**
         * 通过矩阵转换一个三维向量到另外一个归一化的三维向量。
         * @param	vector 源三维向量。
         * @param	transform  变换矩阵。
         * @param	result 输出三维向量。
         */
        static transformCoordinate(coordinate: Vector3, transform: Matrix4x4, result: Vector3): void;
        /**
         * 求一个指定范围的向量
         * @param	value clamp向量
         * @param	min  最小
         * @param	max  最大
         * @param   out 输出向量
         */
        static Clamp(value: Vector3, min: Vector3, max: Vector3, out: Vector3): void;
        /**
         * 求两个三维向量的和。
         * @param	a left三维向量。
         * @param	b right三维向量。
         * @param	out 输出向量。
         */
        static add(a: Vector3, b: Vector3, out: Vector3): void;
        /**
         * 求两个三维向量的差。
         * @param	a  left三维向量。
         * @param	b  right三维向量。
         * @param	o out 输出向量。
         */
        static subtract(a: Vector3, b: Vector3, o: Vector3): void;
        /**
         * 求两个三维向量的叉乘。
         * @param	a left向量。
         * @param	b right向量。
         * @param	o 输出向量。
         */
        static cross(a: Vector3, b: Vector3, o: Vector3): void;
        /**
         * 求两个三维向量的点积。
         * @param	a left向量。
         * @param	b right向量。
         * @return   点积。
         */
        static dot(a: Vector3, b: Vector3): number;
        /**
         * 判断两个三维向量是否相等。
         * @param	a 三维向量。
         * @param	b 三维向量。
         * @return  是否相等。
         */
        static equals(a: Vector3, b: Vector3): boolean;
        /**X轴坐标*/
        x: number;
        /**Y轴坐标*/
        y: number;
        /**Z轴坐标*/
        z: number;
        /**
         * 创建一个 <code>Vector3</code> 实例。
         * @param	x  X轴坐标。
         * @param	y  Y轴坐标。
         * @param	z  Z轴坐标。
         */
        constructor(x?: number, y?: number, z?: number);
        /**
         * 求四维向量是否相等
         * @param value
         * @returns
         */
        equal(value: Vector3): boolean;
        /**
         * 设置xyz值。
         * @param	x X值。
         * @param	y Y值。
         * @param	z Z值。
         */
        setValue(x: number, y: number, z: number): Vector3;
        /**
         * 设置xyz值。
         * @param	x X值。
         * @param	y Y值。
         * @param	z Z值。
         * @return 返回Vector3
         */
        set(x: number, y: number, z: number): this;
        /**
         * 从Array数组拷贝值。
         * @param  arr 数组。
         * @param  offset 数组偏移。
         */
        fromArray(arr: ArrayLike<number>, offset?: number): void;
        /**
         * 转换为Array数组
         * @return
         */
        toArray(): Array<number>;
        /**
         * 写入Array数组
         * @param arr 数组。
         * @param offset 数组偏移。
         */
        writeTo(arr: Float32Array, offset?: number): void;
        /**
         * 计算长度。
         * @return 长度。
         */
        length(): number;
        /**
         * 计算平方。
         * @return 返回向量长度的平方。
         */
        lengthSquared(): number;
        /**
         * 向量相减
         * @param b 被减向量
         * @param out
         * @returns
         */
        vsub(b: Vector3, out: Vector3): Vector3;
        /**
         * 向量相加
         * @param b 加向量
         * @param out
         * @returns
         */
        vadd(b: Vector3, out: Vector3): Vector3;
        /**
         * 缩放向量
         * @param s 缩放值
         * @param out
         * @returns 返回缩放向量
         */
        scale(s: number, out: Vector3): Vector3;
        /**
         * 归一化向量
         * @returns
         */
        normalize(): this;
        /**
         * 向量点乘
         * @param b
         * @returns
         */
        dot(b: Vector3): number;
        /**
         * 向量叉乘
         * @param b
         * @param o
         * @returns
         */
        cross(b: Vector3, o: Vector3): Vector3;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
        /**
         * 设置默认值
         */
        toDefault(): void;
    }
    /**
     * <code>Vector4</code> 类用于创建四维向量。
     */
    class Vector4 implements IClone {
        /**零向量*/
        static readonly ZERO: Readonly<Vector4>;
        static readonly ONE: Readonly<Vector4>;
        static readonly UnitX: Readonly<Vector4>;
        static readonly UnitY: Readonly<Vector4>;
        static readonly UnitZ: Readonly<Vector4>;
        static readonly UnitW: Readonly<Vector4>;
        /**X轴坐标*/
        x: number;
        /**Y轴坐标*/
        y: number;
        /**Z轴坐标*/
        z: number;
        /**W轴坐标*/
        w: number;
        /**
         * 创建一个 <code>Vector4</code> 实例。
         * @param	x  X轴坐标。
         * @param	y  Y轴坐标。
         * @param	z  Z轴坐标。
         * @param	w  W轴坐标。
         */
        constructor(x?: number, y?: number, z?: number, w?: number);
        /**
         * 设置xyzw值。
         * @param	x X值。
         * @param	y Y值。
         * @param	z Z值。
         * @param	w W值。
         */
        setValue(x: number, y: number, z: number, w: number): void;
        /**
         * 从Array数组拷贝值。
         * @param  arr 数组。
         * @param  offset 数组偏移。
         */
        fromArray(arr: ArrayLike<number>, offset?: number): void;
        /**
         * 转换为Array数组
         * @return
         */
        toArray(): Array<number>;
        /**
         * 写入Float32Array数组
         * @param arr 数组。
         * @param offset 数组偏移。
         */
        writeTo(arr: Float32Array, offset?: number): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
        /**
         * 插值四维向量。
         * @param	a left向量。
         * @param	b right向量。
         * @param	t 插值比例。
         * @param	out 输出向量。
         */
        static lerp(a: Vector4, b: Vector4, t: number, out: Vector4): void;
        /**
         * 通过4x4矩阵把一个四维向量转换为另一个四维向量
         * @param	vector4 带转换四维向量。
         * @param	M4x4    4x4矩阵。
         * @param	out     转换后四维向量。
         */
        static transformByM4x4(vector4: Vector4, m4x4: Matrix4x4, out: Vector4): void;
        /**
         * 判断两个四维向量是否相等。
         * @param	a 四维向量。
         * @param	b 四维向量。
         * @return  是否相等。
         */
        static equals(a: Vector4, b: Vector4): boolean;
        /**
         * 求四维向量是否相等
         * @param value
         * @returns
         */
        equal(value: Vector4): boolean;
        /**
         * 求四维向量的长度。
         * @return  长度。
         */
        length(): number;
        /**
         * 求四维向量长度的平方。
         * @return  长度的平方。
         */
        lengthSquared(): number;
        /**
         * 归一化四维向量。
         * @param	s   源四维向量。
         * @param	out 输出四维向量。
         */
        static normalize(s: Vector4, out: Vector4): void;
        /**
         * 求两个四维向量的和。
         * @param	a   四维向量。
         * @param	b   四维向量。
         * @param	out 输出向量。
         */
        static add(a: Vector4, b: Vector4, out: Vector4): void;
        /**
         * 求两个四维向量的差。
         * @param	a   四维向量。
         * @param	b   四维向量。
         * @param	out 输出向量。
         */
        static subtract(a: Vector4, b: Vector4, out: Vector4): void;
        /**
         * 计算两个四维向量的乘积。
         * @param	a   四维向量。
         * @param	b   四维向量。
         * @param	out 输出向量。
         */
        static multiply(a: Vector4, b: Vector4, out: Vector4): void;
        /**
         * 缩放四维向量。
         * @param	a   源四维向量。
         * @param	b   缩放值。
         * @param	out 输出四维向量。
         */
        static scale(a: Vector4, b: number, out: Vector4): void;
        /**
         * 求一个指定范围的四维向量
         * @param	value clamp向量
         * @param	min   最小
         * @param	max   最大
         * @param   out   输出向量
         */
        static Clamp(value: Vector4, min: Vector4, max: Vector4, out: Vector4): void;
        /**
         * 两个四维向量距离的平方。
         * @param	value1 向量1。
         * @param	value2 向量2。
         * @return	距离的平方。
         */
        static distanceSquared(value1: Vector4, value2: Vector4): number;
        /**
         * 两个四维向量距离。
         * @param	value1 向量1。
         * @param	value2 向量2。
         * @return	距离。
         */
        static distance(value1: Vector4, value2: Vector4): number;
        /**
         * 求两个四维向量的点积。
         * @param	a 向量。
         * @param	b 向量。
         * @return  点积。
         */
        static dot(a: Vector4, b: Vector4): number;
        /**
         * 分别取两个四维向量x、y、z的最小值计算新的四维向量。
         * @param	a   四维向量。
         * @param	b   四维向量。
         * @param	out 结果三维向量。
         */
        static min(a: Vector4, b: Vector4, out: Vector4): void;
        /**
         * 分别取两个四维向量x、y、z的最大值计算新的四维向量。
         * @param	a   四维向量。
         * @param	b   四维向量。
         * @param	out 结果三维向量。
         */
        static max(a: Vector4, b: Vector4, out: Vector4): void;
        forNativeElement(nativeElements?: Float32Array): void;
    }
    /**
     * @private
     * 使用Audio标签播放声音
     */
    class AudioSound extends EventDispatcher {
        /**@private */
        private static _audioCache;
        /**
         * 声音URL
         */
        url: string;
        /**
         * 播放用的audio标签
         */
        audio: HTMLAudioElement;
        /**
         * 是否已加载完成
         */
        loaded: boolean;
        /**
         * 释放声音
         *
         */
        dispose(): void;
        /**@private */
        private static _makeMusicOK;
        /**
         * 加载声音
         * @param url
         *
         */
        load(url: string): void;
        /**
         * 播放声音
         * @param startTime 起始时间
         * @param loops 循环次数
         * @return
         *
         */
        play(startTime?: number, loops?: number): SoundChannel;
        /**
         * 获取总时间。
         */
        get duration(): number;
    }
    /**
     * @private
     * audio标签播放声音的音轨控制
     */
    class AudioSoundChannel extends SoundChannel {
        /**
         * 播放用的audio标签
         */
        private _audio;
        private _onEnd;
        private _resumePlay;
        private _src;
        constructor(audio: HTMLAudioElement);
        private __onEnd;
        private __resumePlay;
        /**
         * 播放
         * @override
         */
        play(): void;
        /**
         * 当前播放到的位置
         * @return
         * @override
         *
         */
        get position(): number;
        /**
         * 获取总时间。
         * @override
         */
        get duration(): number;
        /**
         * 停止播放
         * @override
         */
        stop(): void;
        /**
         * @override
         */
        pause(): void;
        /**
         * @override
         */
        resume(): void;
        /**
         * 设置音量
         * @param v
         * @override
         *
         */
        set volume(v: number);
        /**
         * 获取音量
         * @return
         * @override
         *
         */
        get volume(): number;
    }
    /**
     * <code>Sound</code> 类是用来播放控制声音的类。
     * 引擎默认有两套声音方案，优先使用WebAudio播放声音，如果WebAudio不可用，则用H5Audio播放，H5Audio在部分机器上有兼容问题（比如不能混音，播放有延迟等）。
     */
    class Sound extends EventDispatcher {
        /**
         * 加载声音。
         * @param url 地址。
         */
        load(url: string): void;
        /**
         * 播放声音。
         * @param startTime 开始时间,单位秒
         * @param loops 循环次数,0表示一直循环
         * @return 声道 SoundChannel 对象。
         */
        play(startTime?: number, loops?: number): SoundChannel;
        /**
         * 获取总时间。
         */
        get duration(): number;
        /**
         * 释放声音资源。
         */
        dispose(): void;
    }
    /**
     * <p> <code>SoundChannel</code> 用来控制程序中的声音。每个声音均分配给一个声道，而且应用程序可以具有混合在一起的多个声道。</p>
     * <p> <code>SoundChannel</code> 类包含控制声音的播放、暂停、停止、音量的方法，以及获取声音的播放状态、总时间、当前播放时间、总循环次数、播放地址等信息的方法。</p>
     */
    class SoundChannel extends EventDispatcher {
        /**
         * 声音地址。
         */
        url: string;
        /**
         * 循环次数。
         */
        loops: number;
        /**
         * 播放声音开始时间。
         */
        startTime: number;
        /**
         * 表示声音是否已暂停。
         */
        isStopped: boolean;
        /**
         * 播放完成处理器。
         */
        completeHandler: Handler;
        /**
         * 音量范围从 0（静音）至 1（最大音量）。
         */
        set volume(v: number);
        get volume(): number;
        /**
         * 获取当前播放时间，单位是秒。
         */
        get position(): number;
        /**
         * 获取总时间，单位是秒。
         */
        get duration(): number;
        /**
         * 播放声音。
         */
        play(): void;
        /**
         * 停止播放。
         */
        stop(): void;
        /**
         * 暂停播放。
         */
        pause(): void;
        /**
         * 继续播放。
         */
        resume(): void;
        /**
         * private
         */
        protected __runComplete(handler: Handler): void;
    }
    /**
     * <code>SoundManager</code> 是一个声音管理类。提供了对背景音乐、音效的播放控制方法。
     * 引擎默认有两套声音方案：WebAudio和H5Audio
     * 播放音效，优先使用WebAudio播放声音，如果WebAudio不可用，则用H5Audio播放，H5Audio在部分机器上有兼容问题（比如不能混音，播放有延迟等）。
     * 播放背景音乐，则使用H5Audio播放（使用WebAudio会增加特别大的内存，并且要等加载完毕后才能播放，有延迟）
     * 建议背景音乐用mp3类型，音效用wav或者mp3类型（如果打包为app，音效只能用wav格式）。
     * 详细教程及声音格式请参考：http://ldc2.layabox.com/doc/?nav=ch-as-1-7-0
     */
    class SoundManager {
        /**
         * 背景音乐音量。
         * @default 1
         */
        static musicVolume: number;
        /**
         * 音效音量。
         * @default 1
         */
        static soundVolume: number;
        /**
         * 声音播放速率。
         * @default 1
         */
        static playbackRate: number;
        /**
         * 背景音乐使用Audio标签播放。
         * @default true
         */
        private static _useAudioMusic;
        /**@private 是否静音，默认为false。*/
        private static _muted;
        /**@private 是否音效静音，默认为false。*/
        private static _soundMuted;
        /**@private 是否背景音乐静音，默认为false。*/
        private static _musicMuted;
        /**@private 当前背景音乐声道。*/
        static _musicChannel: SoundChannel;
        /**@private 当前播放的Channel列表。*/
        private static _channels;
        /**@private */
        private static _autoStopMusic;
        /**@private */
        private static _blurPaused;
        /**@private */
        private static _isActive;
        /**@private */
        private static _lastSoundUsedTimeDic;
        /**@private */
        private static _isCheckingDispose;
        /**@private */
        private static _soundCache;
        /**
         * 音效播放后自动删除。
         * @default true
         */
        static autoReleaseSound: boolean;
        /**
         * 添加播放的声音实例。
         * @param channel <code>SoundChannel</code> 对象。
         */
        static addChannel(channel: SoundChannel): void;
        /**
         * 移除播放的声音实例。
         * @param channel <code>SoundChannel</code> 对象。
         */
        static removeChannel(channel: SoundChannel): void;
        /**@private */
        static disposeSoundLater(url: string): void;
        /**@private */
        private static _checkDisposeSound;
        /**@private */
        static disposeSoundIfNotUsed(url: string): void;
        /**
         * 失去焦点后是否自动停止背景音乐。
         * @param v Boolean 失去焦点后是否自动停止背景音乐。
         *
         */
        static set autoStopMusic(v: boolean);
        /**
         * 失去焦点后是否自动停止背景音乐。
         */
        static get autoStopMusic(): boolean;
        private static _visibilityChange;
        private static _stageOnBlur;
        private static _recoverWebAudio;
        private static _stageOnFocus;
        /**
         * 背景音乐和所有音效是否静音。
         */
        static set muted(value: boolean);
        static get muted(): boolean;
        /**
         * 所有音效（不包括背景音乐）是否静音。
         */
        static set soundMuted(value: boolean);
        static get soundMuted(): boolean;
        /**
         * 背景音乐（不包括音效）是否静音。
         */
        static set musicMuted(value: boolean);
        static get musicMuted(): boolean;
        static get useAudioMusic(): boolean;
        static set useAudioMusic(value: boolean);
        /**
         * 播放音效。音效可以同时播放多个。
         * @param url			声音文件地址。
         * @param loops			循环次数,0表示无限循环。
         * @param complete		声音播放完成回调  Handler对象。
         * @param soundClass	使用哪个声音类进行播放，null表示自动选择。
         * @param startTime		声音播放起始时间。
         * @return SoundChannel对象，通过此对象可以对声音进行控制，以及获取声音信息。
         */
        static playSound(url: string, loops?: number, complete?: Handler, soundClass?: new () => any, startTime?: number): SoundChannel;
        /**
         * 释放声音资源。
         * @param url	声音播放地址。
         */
        static destroySound(url: string): void;
        /**
         * 播放背景音乐。背景音乐同时只能播放一个，如果在播放背景音乐时再次调用本方法，会先停止之前的背景音乐，再播放当前的背景音乐。
         * @param url		声音文件地址。
         * @param loops		循环次数,0表示无限循环。
         * @param complete	声音播放完成回调,complete 结果参数 true: 播放完成, false/undefined ：stop触发的complete。
         * @param startTime	声音播放起始时间。
         * @return SoundChannel对象，通过此对象可以对声音进行控制，以及获取声音信息。
         */
        static playMusic(url: string, loops?: number, complete?: Handler, startTime?: number): SoundChannel;
        /**
         * 停止声音播放。此方法能够停止任意声音的播放（包括背景音乐和音效），只需传入对应的声音播放地址。
         * @param url  声音文件地址。
         */
        static stopSound(url: string): void;
        /**
         * 停止播放所有声音（包括背景音乐和音效）。
         */
        static stopAll(): void;
        /**
         * 停止播放所有音效（不包括背景音乐）。
         */
        static stopAllSound(): void;
        /**
         * 停止播放背景音乐（不包括音效）。
         * @param url  声音文件地址。
         */
        static stopMusic(): void;
        /**
         * 设置声音音量。根据参数不同，可以分别设置指定声音（背景音乐或音效）音量或者所有音效（不包括背景音乐）音量。
         * @param volume	音量。初始值为1。音量范围从 0（静音）至 1（最大音量）。
         * @param url		(default = null)声音播放地址。默认为null。为空表示设置所有音效（不包括背景音乐）的音量，不为空表示设置指定声音（背景音乐或音效）的音量。
         */
        static setSoundVolume(volume: number, url?: string): void;
        /**
         * 设置背景音乐音量。音量范围从 0（静音）至 1（最大音量）。
         * @param volume	音量。初始值为1。音量范围从 0（静音）至 1（最大音量）。
         */
        static setMusicVolume(volume: number): void;
        /**
         * 设置指定声音的音量。
         * @param url		声音文件url
         * @param volume	音量。初始值为1。
         */
        private static _setVolume;
    }
    /**
     * 用于播放背景音乐或者音效的节点
     */
    class SoundNode extends Sprite {
        private _channel;
        private _tar;
        private _playEvents;
        private _stopEvents;
        private _source;
        private _isMusic;
        private _autoPlay;
        private _loop;
        constructor();
        get source(): string;
        set source(value: string);
        /**
         * 如果是，音乐类型为背景音乐，否则为音效
         */
        get isMusic(): boolean;
        set isMusic(value: boolean);
        /**
         * 循环次数
         */
        get loop(): number;
        set loop(value: number);
        /**
         * 是否自动播放
         */
        get autoPlay(): boolean;
        set autoPlay(value: boolean);
        /**@private */
        private _onParentChange;
        /**
         * 播放
         * @param loops 循环次数
         * @param complete 完成回调
         *
         */
        play(loops?: number, complete?: Handler): void;
        /**
         * 停止播放
         *
         */
        stop(): void;
        /**@private */
        private _setPlayAction;
        /**@private */
        private _setPlayActions;
        /**
         * 设置触发播放的事件
         * @param events
         *
         */
        set playEvent(events: string);
        /**
         * 设置控制播放的对象
         * @param tar
         *
         */
        set target(tar: Sprite);
        /**
         * 设置触发停止的事件
         * @param events
         *
         */
        set stopEvent(events: string);
    }
    /**
     * <code>VideoNode</code>将视频显示到Canvas上。<code>Video</code>可能不会在所有浏览器有效。
     * <p>关于Video支持的所有事件参见：<i>http://www.w3school.com.cn/tags/html_ref_audio_video_dom.asp</i>。</p>
     * <p>
     * <b>注意：</b><br/>
     * 在PC端可以在任何时机调用<code>play()</code>因此，可以在程序开始运行时就使Video开始播放。但是在移动端，只有在用户第一次触碰屏幕后才可以调用play()，所以移动端不可能在程序开始运行时就自动开始播放Video。
     * </p>
     *
     * <p>MDN Video链接： <i>https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video</i></p>
     */
    class VideoNode extends Sprite {
        private _videoTexture;
        private _internalTex;
        constructor();
        get videoTexture(): VideoTexture;
        set videoTexture(value: VideoTexture);
        get source(): string;
        set source(value: string);
        /**
         * 设置播放源。
         * @param url	播放源路径。
         */
        load(url: string): void;
        /**
         * 开始播放视频。
         */
        play(): void;
        /**
         * 暂停视频播放。
         */
        pause(): void;
        /**
         * 重新加载视频。
         */
        reload(): void;
        /**
         * 检测是否支持播放指定格式视频。
         * @param type	"mp4","ogg","webm","m3u8"等。
         * @return 表示支持的级别。可能的值：
         * <ul>
         * <li>"probably" - 浏览器最可能支持该音频/视频类型</li>
         * <li>"maybe" - 浏览器也许支持该音频/视频类型</li>
         * <li>"" - （空字符串）浏览器不支持该音频/视频类型</li>
         * </ul>
         */
        canPlayType(type: string): CanPlayTypeResult;
        private onVideoMetaLoaded;
        /**
         * buffered 属性返回 TimeRanges(JS)对象。TimeRanges 对象表示用户的音视频缓冲范围。缓冲范围指的是已缓冲音视频的时间范围。如果用户在音视频中跳跃播放，会得到多个缓冲范围。
         * <p>buffered.length返回缓冲范围个数。如获取第一个缓冲范围则是buffered.start(0)和buffered.end(0)。以秒计。</p>
         * @return TimeRanges(JS)对象
         */
        get buffered(): any;
        /**
         * 获取当前播放源路径。
         */
        get currentSrc(): string;
        /**
         * 设置和获取当前播放头位置。
         */
        get currentTime(): number;
        set currentTime(value: number);
        /**
         * 设置和获取当前音量。
         */
        set volume(value: number);
        get volume(): number;
        /**
         * 表示视频元素的就绪状态：
         * <ul>
         * <li>0 = HAVE_NOTHING - 没有关于音频/视频是否就绪的信息</li>
         * <li>1 = HAVE_METADATA - 关于音频/视频就绪的元数据</li>
         * <li>2 = HAVE_CURRENT_DATA - 关于当前播放位置的数据是可用的，但没有足够的数据来播放下一帧/毫秒</li>
         * <li>3 = HAVE_FUTURE_DATA - 当前及至少下一帧的数据是可用的</li>
         * <li>4 = HAVE_ENOUGH_DATA - 可用数据足以开始播放</li>
         * </ul>
         */
        get readyState(): any;
        /**
         * 获取视频源尺寸。ready事件触发后可用。
         */
        get videoWidth(): number;
        get videoHeight(): number;
        /**
         * 获取视频长度（秒）。ready事件触发后可用。
         */
        get duration(): number;
        /**
         * 返回音频/视频的播放是否已结束
         */
        get ended(): boolean;
        /**
         * 返回表示音频/视频错误状态的 MediaError（JS）对象。
         */
        get error(): MediaError;
        /**
         * 设置或返回音频/视频是否应在结束时重新播放。
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * playbackRate 属性设置或返回音频/视频的当前播放速度。如：
         * <ul>
         * <li>1.0 正常速度</li>
         * <li>0.5 半速（更慢）</li>
         * <li>2.0 倍速（更快）</li>
         * <li>-1.0 向后，正常速度</li>
         * <li>-0.5 向后，半速</li>
         * </ul>
         * <p>只有 Google Chrome 和 Safari 支持 playbackRate 属性。</p>
         */
        get playbackRate(): number;
        set playbackRate(value: number);
        /**
         * 获取和设置静音状态。
         */
        get muted(): boolean;
        set muted(value: boolean);
        /**
         * 返回视频是否暂停
         */
        get paused(): boolean;
        /**
         * preload 属性设置或返回是否在页面加载后立即加载视频。可赋值如下：
         * <ul>
         * <li>auto	指示一旦页面加载，则开始加载视频。</li>
         * <li>metadata	指示当页面加载后仅加载音频/视频的元数据。</li>
         * <li>none	指示页面加载后不应加载音频/视频。</li>
         * </ul>
         */
        get preload(): string;
        set preload(value: string);
        /**
         * 参见 <i>http://www.w3school.com.cn/tags/av_prop_seekable.asp</i>。
         */
        get seekable(): any;
        /**
         * seeking 属性返回用户目前是否在音频/视频中寻址。
         * 寻址中（Seeking）指的是用户在音频/视频中移动/跳跃到新的位置。
         */
        get seeking(): boolean;
        /**
        * @override
        */
        _setX(value: number): void;
        /**
         * @override
         */
        _setY(value: number): void;
        /**
         * @override
         */
        set_width(value: number): void;
        /**
         * @override
         */
        set_height(value: number): void;
        /**
         * 销毁内部事件绑定。
         * @override
         */
        destroy(detroyChildren?: boolean): void;
    }
    /**
     * <code>VideoTexture</code> 多媒体纹理
     */
    class VideoTexture extends BaseTexture {
        readonly element: HTMLVideoElement;
        private _source;
        private _listeningEvents;
        private immediatelyPlay;
        /**
         * 是否开发者自己调用Render
         */
        private _frameRender;
        /** @inernal 避免重复的加载 */
        _isLoaded: boolean;
        _needUpdate: boolean;
        /** @inernal 是否使用了requestVideoFrameCallback 接口 */
        _requestVideoFrame: boolean;
        /**
         * 创建VideoTexture对象，
         */
        constructor();
        private isNeedUpdate;
        loadedmetadata(): void;
        get source(): string;
        get gammaCorrection(): number;
        /**
        * 设置播放源路径
        * @param url 播放源路径
        */
        set source(url: string);
        private appendSource;
        /**
         * 是否每一帧都渲染
         */
        set frameRender(value: boolean);
        get frameRender(): boolean;
        /**
         * 开始播放视频
         */
        play(): void;
        _getSource(): any;
        get defaultTexture(): Texture2D;
        /**
         * 暂停播放视频
         */
        pause(): void;
        /**
         * 重新加载视频。
         */
        load(): void;
        /**
         * 检测是否支持播放指定格式视频。
         * @param type	"mp4","ogg","webm","m3u8"等。
         * @return 表示支持的级别。可能的值：
         * <ul>
         * <li>"probably" - 浏览器最可能支持该音频/视频类型</li>
         * <li>"maybe" - 浏览器也许支持该音频/视频类型</li>
         * <li>"" - （空字符串）浏览器不支持该音频/视频类型</li>
         * </ul>
         */
        canPlayType(type: string): CanPlayTypeResult;
        /**
         * buffered 属性返回 TimeRanges(JS)对象。TimeRanges 对象表示用户的音视频缓冲范围。缓冲范围指的是已缓冲音视频的时间范围。如果用户在音视频中跳跃播放，会得到多个缓冲范围。
         * <p>buffered.length返回缓冲范围个数。如获取第一个缓冲范围则是buffered.start(0)和buffered.end(0)。以秒计。</p>
         * @return TimeRanges(JS)对象
         */
        get buffered(): any;
        /**
         * 获取当前播放源路径。
         */
        get currentSrc(): string;
        /**
         * 设置和获取当前播放头位置。
         */
        get currentTime(): number;
        set currentTime(value: number);
        /**
         * 设置和获取当前音量。
         */
        set volume(value: number);
        get volume(): number;
        /**
         * 表示视频元素的就绪状态：
         * <ul>
         * <li>0 = HAVE_NOTHING - 没有关于音频/视频是否就绪的信息</li>
         * <li>1 = HAVE_METADATA - 关于音频/视频就绪的元数据</li>
         * <li>2 = HAVE_CURRENT_DATA - 关于当前播放位置的数据是可用的，但没有足够的数据来播放下一帧/毫秒</li>
         * <li>3 = HAVE_FUTURE_DATA - 当前及至少下一帧的数据是可用的</li>
         * <li>4 = HAVE_ENOUGH_DATA - 可用数据足以开始播放</li>
         * </ul>
         */
        get readyState(): any;
        /**
         * 获取视频源尺寸。ready事件触发后可用。
         */
        get videoWidth(): number;
        get videoHeight(): number;
        /**
         * 获取视频长度（秒）。ready事件触发后可用。
         */
        get duration(): number;
        /**
         * 返回音频/视频的播放是否已结束
         */
        get ended(): boolean;
        /**
         * 返回表示音频/视频错误状态的 MediaError（JS）对象。
         */
        get error(): MediaError;
        /**
         * 设置或返回音频/视频是否应在结束时重新播放。
         */
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * playbackRate 属性设置或返回音频/视频的当前播放速度。如：
         * <ul>
         * <li>1.0 正常速度</li>
         * <li>0.5 半速（更慢）</li>
         * <li>2.0 倍速（更快）</li>
         * <li>-1.0 向后，正常速度</li>
         * <li>-0.5 向后，半速</li>
         * </ul>
         * <p>只有 Google Chrome 和 Safari 支持 playbackRate 属性。</p>
         */
        get playbackRate(): number;
        set playbackRate(value: number);
        /**
         * 获取和设置静音状态。
         */
        get muted(): boolean;
        set muted(value: boolean);
        /**
         * 返回视频是否暂停
         */
        get paused(): boolean;
        /**
         * preload 属性设置或返回是否在页面加载后立即加载视频。可赋值如下：
         * <ul>
         * <li>auto	指示一旦页面加载，则开始加载视频。</li>
         * <li>metadata	指示当页面加载后仅加载音频/视频的元数据。</li>
         * <li>none	指示页面加载后不应加载音频/视频。</li>
         * </ul>
         */
        get preload(): string;
        set preload(value: string);
        /**
         * 参见 <i>http://www.w3school.com.cn/tags/av_prop_seekable.asp</i>。
         */
        get seekable(): any;
        /**
         * seeking 属性返回用户目前是否在音频/视频中寻址。
         * 寻址中（Seeking）指的是用户在音频/视频中移动/跳跃到新的位置。
         */
        get seeking(): boolean;
        protected onStartListeningToType(type: string): void;
        destroy(): void;
    }
    /**
     * @private
     * web audio api方式播放声音
     */
    class WebAudioSound extends EventDispatcher {
        /**
         * 播放设备
         */
        static ctx: AudioContext;
        /**
         * 用于播放解锁声音以及解决Ios9版本的内存释放
         */
        static _miniBuffer: any;
        /**
         * 是否已解锁声音播放
         */
        private static _unlocked;
        /**
         * 声音URL
         */
        url: string;
        /**
         * 是否已加载完成
         */
        loaded: boolean;
        /**
         * 声音原始文件数据
         */
        audioBuffer: AudioBuffer;
        /**
         * 待播放的声音列表
         */
        private __toPlays;
        /**
         * @private
         */
        private _disposed;
        /**
         * 播放声音以解锁IOS的声音
         *
         */
        private static _playEmptySound;
        /**
         * 尝试解锁声音
         *
         */
        private static _unlock;
        static initWebAudio(): void;
        /**
         * 加载声音
         * @param url
         *
         */
        load(url: string): void;
        private _loaded;
        private __playAfterLoaded;
        /**
         * 播放声音
         * @param startTime 起始时间
         * @param loops 循环次数
         * @return
         *
         */
        play(startTime?: number, loops?: number, channel?: WebAudioSoundChannel): SoundChannel;
        get duration(): number;
        dispose(): void;
    }
    /**
     * @private
     * web audio api方式播放声音的音轨控制
     */
    class WebAudioSoundChannel extends SoundChannel {
        /**
         * 声音原始文件数据
         */
        audioBuffer: any;
        /**
         * gain节点
         */
        private gain;
        /**
         * 播放用的数据
         */
        private bufferSource;
        /**
         * 当前时间
         */
        private _currentTime;
        /**
         * 当前音量
         */
        private _volume;
        /**
         * 播放开始时的时间戳
         */
        private _startTime;
        private _pauseTime;
        /**
         * 播放设备
         */
        private context;
        private _onPlayEnd;
        private static _tryCleanFailed;
        static SetTargetDelay: number;
        constructor();
        /**
         * 播放声音
         * @override
         */
        play(): void;
        private __onPlayEnd;
        /**
         * 获取当前播放位置
         * @override
         */
        get position(): number;
        /**
         * @override
         */
        get duration(): number;
        private _clearBufferSource;
        private _tryClearBuffer;
        /**
         * 停止播放
         * @override
         */
        stop(): void;
        /**
         * @override
         */
        pause(): void;
        /**
         * @override
         */
        resume(): void;
        /**
         * 设置音量
         * @override
         */
        set volume(v: number);
        /**
         * 获取音量
         * @override
         */
        get volume(): number;
    }
    /**
     * 自动图集管理类
     * @private
     */
    class AtlasInfoManager {
        static _fileLoadDic: Record<string, {
            url: string;
            baseUrl?: string;
        }>;
        static enable(infoFile: string, callback?: Handler | null): void;
        static addAtlases(data: Record<string, [
            string,
            string[]
        ]>): void;
        static addAtlas(atlasUrl: string, prefix: string, frames: Array<string>): void;
        static getFileLoadPath(file: string): {
            url: string;
            baseUrl?: string;
        };
    }
    type ProgressCallback = (progress: number) => void;
    interface IBatchProgress {
        readonly itemCount: number;
        createCallback(weight?: number): ProgressCallback;
        update(index: number, progress: number): void;
    }
    class BatchProgress implements IBatchProgress {
        private _callback;
        private _items;
        private _weights;
        private _progress;
        constructor(callback: ProgressCallback);
        get itemCount(): number;
        reset(): void;
        createCallback(weight?: number): ProgressCallback;
        update(index: number, value: number): void;
    }
    class Downloader {
        common(owner: any, url: string, originalUrl: string, contentType: string, onProgress: (progress: number) => void, onComplete: (data: any, error?: string) => void): void;
        image(owner: any, url: string, originalUrl: string, onProgress: (progress: number) => void, onComplete: (data: any, error?: string) => void): void;
        imageWithBlob(owner: any, blob: ArrayBuffer, originalUrl: string, onProgress: (progress: number) => void, onComplete: (data: any, error?: string) => void): void;
        imageWithWorker(owner: any, url: string, originalUrl: string, onProgress: (progress: number) => void, onComplete: (data: any, error?: string) => void): void;
        audio(owner: any, url: string, originalUrl: string, onProgress: (progress: number) => void, onComplete: (data: any, error?: string) => void): void;
        httpRequestPool: Array<HttpRequest>;
        protected getRequestInst(): HttpRequest;
        protected returnRequestInst(inst: HttpRequest): void;
    }
    /**
     * 请求进度改变时调度。
     * @eventType Event.PROGRESS
     * */
    /**
     * 请求结束后调度。
     * @eventType Event.COMPLETE
     * */
    /**
     * 请求出错时调度。
     * @eventType Event.ERROR
     * */
    /**
     * <p> <code>HttpRequest</code> 通过封装 HTML <code>XMLHttpRequest</code> 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。 <code>HttpRequest</code> 只提供以异步的形式返回 Web 服务器的响应，并且能够以文本或者二进制的形式返回内容。</p>
     * <p><b>注意：</b>建议每次请求都使用新的 <code>HttpRequest</code> 对象，因为每次调用该对象的send方法时，都会清空之前设置的数据，并重置 HTTP 请求的状态，这会导致之前还未返回响应的请求被重置，从而得不到之前请求的响应结果。</p>
     */
    class HttpRequest extends EventDispatcher {
        /**@private */
        protected _http: XMLHttpRequest;
        /**@private */
        private static _urlEncode;
        /**@private */
        protected _responseType: string;
        /**@private */
        protected _data: any;
        /**@private */
        protected _url: string;
        /**
         * 发送 HTTP 请求。
         * @param	url				请求的地址。大多数浏览器实施了一个同源安全策略，并且要求这个 URL 与包含脚本的文本具有相同的主机名和端口。
         * @param	data			(default = null)发送的数据。
         * @param	method			(default = "get")用于请求的 HTTP 方法。值包括 "get"、"post"、"head"。
         * @param	responseType	(default = "text")Web 服务器的响应类型，可设置为 "text"、"json"、"xml"、"arraybuffer"。
         * @param	headers			(default = null) HTTP 请求的头部信息。参数形如key-value数组：key是头部的名称，不应该包括空白、冒号或换行；value是头部的值，不应该包括换行。比如["Content-Type", "application/json"]。
         */
        send(url: string, data?: any, method?: "get" | "post" | "head", responseType?: "text" | "json" | "xml" | "arraybuffer", headers?: string[]): void;
        /**
         * @private
         * 请求进度的侦听处理函数。
         * @param	e 事件对象。
         */
        protected _onProgress(e: any): void;
        /**
         * @private
         * 请求中断的侦听处理函数。
         * @param	e 事件对象。
         */
        protected _onAbort(e: any): void;
        /**
         * @private
         * 请求出错侦的听处理函数。
         * @param	e 事件对象。
         */
        protected _onError(e: any): void;
        /**
         * @private
         * 请求消息返回的侦听处理函数。
         * @param	e 事件对象。
         */
        protected _onLoad(e: any): void;
        /**
         * @private
         * 请求错误的处理函数。
         * @param	message 错误信息。
         */
        protected error(message: string): void;
        /**
         * @private
         * 请求成功完成的处理函数。
         */
        protected complete(): void;
        /**
         * @private
         * 清除当前请求。
         */
        protected clear(): void;
        /** 请求的地址。*/
        get url(): string;
        /** 返回的数据。*/
        get data(): any;
        /**
         * 本对象所封装的原生 XMLHttpRequest 引用。
         */
        get http(): any;
        reset(): void;
    }
    interface ILoadTask {
        readonly type: string;
        readonly url: string;
        readonly uuid: string;
        readonly ext: string;
        readonly loader: Loader;
        readonly obsoluteInst: Resource;
        readonly options: Readonly<ILoadOptions>;
        readonly progress: IBatchProgress;
    }
    interface IResourceLoader {
        load(task: ILoadTask): Promise<any>;
    }
    interface ILoadOptions {
        type?: string;
        priority?: number;
        group?: string;
        cache?: boolean;
        ignoreCache?: boolean;
        noRetry?: boolean;
        silent?: boolean;
        useWorkerLoader?: boolean;
        constructParams?: TextureConstructParams;
        propertyParams?: TexturePropertyParams;
        blob?: ArrayBuffer;
        initiator?: ILoadTask;
        [key: string]: any;
    }
    interface ILoadURL extends ILoadOptions {
        url: string;
    }
    interface ContentTypeMap {
        "text": string;
        "json": any;
        "xml": XML;
        "arraybuffer": ArrayBuffer;
        "image": HTMLImageElement | ImageBitmap;
        "sound": HTMLAudioElement;
    }
    type TypeMapEntry = {
        typeId: number;
        loaderType: new () => IResourceLoader;
    };
    interface URLInfo {
        ext: string;
        typeId: number;
        main: boolean;
        loaderType: new () => IResourceLoader;
    }
    /**
     * <code>Loader</code> 类可用来加载文本、JSON、XML、二进制、图像等资源。
     */
    class Loader extends EventDispatcher {
        /**文本类型，加载完成后返回包含string的TextResource对象。*/
        static TEXT: string;
        /**JSON 类型，加载完成后返回包含json数据的TextResource对象。*/
        static JSON: string;
        /**XML 类型，加载完成后返回包含domXML的TextResource对象。*/
        static XML: string;
        /**二进制类型，加载完成后返回包含arraybuffer的TextResource对象。*/
        static BUFFER: string;
        /**纹理类型，加载完成后返回Texture。*/
        static IMAGE: string;
        /**声音类型，加载完成后返回Sound。*/
        static SOUND: string;
        /**视频类型，加载完成后返回VideoTexture。*/
        static VIDEO: string;
        /**图集类型，加载完成后返回图集json信息(并创建图集内小图Texture)。*/
        static ATLAS: string;
        /**位图字体类型，加载完成后返回BitmapFont，加载后，会根据文件名自动注册为位图字体。*/
        static FONT: string;
        /** TTF字体类型，加载完成后返回一个对象。*/
        static TTF: string;
        /**Hierarchy资源。*/
        static HIERARCHY: string;
        /**Mesh资源。*/
        static MESH: string;
        /**Material资源。*/
        static MATERIAL: string;
        /**Texture2D资源。*/
        static TEXTURE2D: string;
        /**TextureCube资源。*/
        static TEXTURECUBE: string;
        static TEXTURE2DARRAY: string;
        /**AnimationClip资源。*/
        static ANIMATIONCLIP: string;
        /**Terrain资源。*/
        static TERRAINHEIGHTDATA: string;
        /**Terrain资源。*/
        static TERRAINRES: string;
        /** Spine 资源 */
        static SPINE: string;
        /** 加载出错后的重试次数，默认重试一次*/
        retryNum: number;
        /** 延迟时间多久再进行错误重试，默认立即重试*/
        retryDelay: number;
        /** 最大下载线程，默认为5个*/
        maxLoader: number;
        static readonly extMap: {
            [ext: string]: Array<TypeMapEntry>;
        };
        static readonly typeMap: {
            [type: string]: TypeMapEntry;
        };
        static downloader: Downloader;
        /**
         * 注册一种资源装载器。
         * @param exts 扩展名
         * @param cls
         * @param type 类型标识。如果这种资源需要支持识别没有扩展名的情况，或者一个扩展名对应了多种资源类型的情况，那么指定type参数是个最优实践。
         */
        static registerLoader(exts: string[], cls: new () => IResourceLoader, type?: string): void;
        /**资源分组对应表。*/
        static groupMap: {
            [name: string]: Set<string>;
        };
        /**已加载的资源池。*/
        static loadedMap: {
            [url: string]: Array<any>;
        };
        /** 预加载的数据文件。如果一个url在这里有记录，则请求时直接使用这里的数据，放弃网络加载。*/
        static preLoadedMap: {
            [url: string]: any;
        };
        /**@private */
        private _loadings;
        /**@private */
        private _queue;
        /**@private */
        private _downloadings;
        /**
         * <p>创建一个新的 <code>Loader</code> 实例。</p>
         * <p><b>注意：</b>请使用Laya.loader加载资源，这是一个单例，不要手动实例化此类，否则会导致不可预料的问题。</p>
         */
        constructor();
        /**
         * 是否有任何的加载任务在进行
         */
        get loading(): boolean;
        /**
         * <p>加载资源。</p>
         * @param url 要加载的资源地址或资源地址数组。
         * @param type 资源类型。比如：Loader.IMAGE。
         * @param onProgress 进度回调函数。
         * @return 根据url类型不同分为2种情况：1. url为String或ILoadURL类型，也就是单个资源地址，如果加载成功，则回调参数值为加载完成的资源，否则为null；2. url为数组类型，则返回一个数组，数组每个元素为加载完成的资源或null。
         */
        load(url: string | ILoadURL | (string | Readonly<ILoadURL>)[], type?: string, onProgress?: ProgressCallback): Promise<any>;
        /**
         * <p>加载资源。</p>
         * @param url 要加载的资源地址或资源地址数组。
         * @param options 加载选项。
         * @param onProgress 进度回调函数。
         * @return 根据url类型不同分为2种情况：1. url为String或ILoadURL类型，也就是单个资源地址，如果加载成功，则回调参数值为加载完成的资源，否则为null；2. url为数组类型，则返回一个数组，数组每个元素为加载完成的资源或null。
         */
        load(url: string | ILoadURL | (string | Readonly<ILoadURL>)[], options?: Readonly<ILoadOptions>, onProgress?: ProgressCallback): Promise<any>;
        /**
         * <p>这是兼容2.0引擎的加载接口</p>
         * <p>加载资源。</p>
         * @param url		要加载的单个资源地址或资源信息数组。比如：简单数组：["a.png","b.png"]；复杂数组[{url:"a.png",type:Loader.IMAGE,size:100,priority:1},{url:"b.json",type:Loader.JSON,size:50,priority:1}]。
         * @param complete	加载结束回调。根据url类型不同分为2种情况：1. url为String类型，也就是单个资源地址，如果加载成功，则回调参数值为加载完成的资源，否则为null；2. url为数组类型，则返回一个数组，数组每个元素为加载完成的资源或null。
         * @param progress	加载进度回调。回调参数值为当前资源的加载进度信息(0-1)。
         * @param type		资源类型。比如：Loader.IMAGE。
         * @param priority	(default = 0)加载的优先级，数字越大优先级越高，优先级高的优先加载。
         * @param cache		是否缓存。
         * @param group		分组，方便对资源进行管理。
         * @param ignoreCache	是否忽略缓存。
         * @param useWorkerLoader(default = false)是否使用worker加载（只针对IMAGE类型和ATLAS类型，并且浏览器支持的情况下生效）
         * @return Promise对象
         */
        load(url: string | ILoadURL | (string | Readonly<ILoadURL>)[], complete?: Handler, progress?: Handler, type?: string, priority?: number, cache?: boolean, group?: string, ignoreCache?: boolean, useWorkerLoader?: boolean): Promise<any>;
        /**
         * 从指定URL下载。这是较为底层的下载资源的方法，它和load方法不同，不对返回的数据进行解析，也不会缓存下载的内容。
         * 成功则返回下载的数据，失败返回null。
         */
        fetch<K extends keyof ContentTypeMap>(url: string, contentType: K, onProgress?: ProgressCallback, options?: Readonly<ILoadOptions>): Promise<ContentTypeMap[K]>;
        private queueToDownload;
        private download;
        private completeItem;
        static getURLInfo(url: string, type?: string): URLInfo;
        static warnFailed(url: string, err?: any, initiatorUrl?: string): void;
        static warn(msg: string, err?: any): void;
        /**
         * 获取指定资源地址的资源。
         * @param url 资源地址。
         * @return 返回资源。
         */
        static getRes(url: string, type?: string): any;
        /**
         *
         */
        static getTexture2D(url: string): Texture2D;
        /**
         *
         */
        static getBaseTexture<T extends BaseTexture>(url: string): T;
        /**
         * 获取指定资源地址的图集地址列表。
         * @param url 图集地址。
         * @return 返回地址集合。
         */
        static getAtlas(url: string): AtlasResource;
        getRes(url: string, type?: string): any;
        static createNodes<T extends Node>(url: string): T;
        /**
         * 缓存资源。
         * @param url 资源地址。
         * @param data 要缓存的内容。
         */
        static cacheRes(url: string, data: any, type?: string): void;
        cacheRes(url: string, data: any, type?: string): void;
        /**
         * 清理指定资源地址缓存。
         * @param url 资源地址。
         * @param checkObj 如果缓存中的对象是这个，才清除，否则不清除
         */
        static clearRes(url: string, checkObj?: any): void;
        /**
         * 清理指定资源地址缓存。
         * @param url 资源地址。
         * @param checkObj 如果缓存中的对象是这个，才清除，否则不清除
         */
        clearRes(url: string, checkObj?: any): void;
        /**
         * 销毁Texture使用的图片资源，保留texture壳，如果下次渲染的时候，发现texture使用的图片资源不存在，则会自动恢复
         * 相比clearRes，clearTextureRes只是清理texture里面使用的图片资源，并不销毁texture，再次使用到的时候会自动恢复图片资源
         * 而clearRes会彻底销毁texture，导致不能再使用；clearTextureRes能确保立即销毁图片资源，并且不用担心销毁错误
         * @param url 图集地址或者texture地址，比如 "res/atlas/comp.atlas"或"hall/bg.jpg"
         */
        clearTextureRes(url: string): void;
        /**
         * 设置资源分组。
         * @param url 资源地址。
         * @param group 分组名。
         */
        static setGroup(url: string, group: string): void;
        /**
         * 根据分组清理资源。
         * @param group 分组名
         */
        static clearResByGroup(group: string): void;
        /** 清理当前未完成的加载，所有未加载的内容全部停止加载。*/
        clearUnLoaded(): void;
        /**
         * 根据地址集合清理掉未加载的内容
         * @param urls 资源地址集合
         */
        cancelLoadByUrls(urls: any[]): void;
        /**
         * 根据地址清理掉未加载的内容
         * @param url 资源地址
         */
        cancelLoadByUrl(url: string): void;
        /**
         * 载入一个分包
         * @path 小游戏的分包路径
         * @onProgress 加载进度回调
         */
        loadPackage(path: string, onProgress?: ProgressCallback): Promise<void>;
        /**
         * 载入一个分包。
         * @path 分包路径
         * @remoteUrl 如果分包是一个远程包，那需要提供远程资源服务器的地址，例如"http://cdn.com/"
         * @onProgress 加载进度回调
         */
        loadPackage(path: string, remoteUrl?: string, onProgress?: ProgressCallback): Promise<void>;
        private _loadMiniPackage;
        private _loadSubFileConfig;
    }
    /**
     * <p> <code>LocalStorage</code> 类用于没有时间限制的数据存储。</p>
     */
    class LocalStorage {
        /**@ 基础类*/
        static _baseClass: any;
        /**
         *  数据列表。
         */
        static items: any;
        /**
         * 表示是否支持  <code>LocalStorage</code>。
         */
        static support: boolean;
        /**
         * 存储指定键名和键值，字符串类型。
         * @param key 键名。
         * @param value 键值。
         */
        static setItem(key: string, value: string): void;
        /**
         * 获取指定键名的值。
         * @param key 键名。
         * @return 字符串型值。
         */
        static getItem(key: string): string;
        /**
         * 存储指定键名及其对应的 <code>Object</code> 类型值。
         * @param key 键名。
         * @param value 键值。是 <code>Object</code> 类型，此致会被转化为 JSON 字符串存储。
         */
        static setJSON(key: string, value: any): void;
        /**
         * 获取指定键名对应的 <code>Object</code> 类型值。
         * @param key 键名。
         * @return <code>Object</code> 类型值
         */
        static getJSON(key: string): any;
        /**
         * 删除指定键名的信息。
         * @param key 键名。
         */
        static removeItem(key: string): void;
        /**
         * 清除本地存储信息。
         */
        static clear(): void;
    }
    /**
     * 连接建立成功后调度。
     * @eventType Event.OPEN
     * */
    /**
     * 接收到数据后调度。
     * @eventType Event.MESSAGE
     * */
    /**
     * 连接被关闭后调度。
     * @eventType Event.CLOSE
     * */
    /**
     * 出现异常后调度。
     * @eventType Event.ERROR
     * */
    /**
     * <p> <code>Socket</code> 封装了 HTML5 WebSocket ，允许服务器端与客户端进行全双工（full-duplex）的实时通信，并且允许跨域通信。在建立连接后，服务器和 Browser/Client Agent 都能主动的向对方发送或接收文本和二进制数据。</p>
     * <p>要使用 <code>Socket</code> 类的方法，请先使用构造函数 <code>new Socket</code> 创建一个 <code>Socket</code> 对象。 <code>Socket</code> 以异步方式传输和接收数据。</p>
     */
    class Socket extends EventDispatcher {
        /**
         * <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。</p>
         * <p> LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
         * <p> BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。</p>
         */
        static LITTLE_ENDIAN: string;
        /**
         * <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。</p>
         * <p> BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。</p>
         * <p> LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
         */
        static BIG_ENDIAN: string;
        /**@private */
        protected _socket: any;
        /**@private */
        private _connected;
        /**@private */
        private _addInputPosition;
        /**@private */
        private _input;
        /**@private */
        private _output;
        /**
         * 不再缓存服务端发来的数据，如果传输的数据为字符串格式，建议设置为true，减少二进制转换消耗。
         */
        disableInput: boolean;
        /**
         * 用来发送和接收数据的 <code>Byte</code> 类。
         */
        private _byteClass;
        /**
         * <p>子协议名称。子协议名称字符串，或由多个子协议名称字符串构成的数组。必须在调用 connect 或者 connectByUrl 之前进行赋值，否则无效。</p>
         * <p>指定后，只有当服务器选择了其中的某个子协议，连接才能建立成功，否则建立失败，派发 Event.ERROR 事件。</p>
         * @see https://html.spec.whatwg.org/multipage/comms.html#dom-websocket
         */
        protocols: any;
        /**
         * 缓存的服务端发来的数据。
         */
        get input(): any;
        /**
         * 表示需要发送至服务端的缓冲区中的数据。
         */
        get output(): any;
        /**
         * 表示此 Socket 对象目前是否已连接。
         */
        get connected(): boolean;
        /**
         * <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。</p>
         * <p> LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
         * <p> BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。</p>
         */
        get endian(): string;
        set endian(value: string);
        /**
         * <p>创建新的 Socket 对象。默认字节序为 Socket.BIG_ENDIAN 。若未指定参数，将创建一个最初处于断开状态的套接字。若指定了有效参数，则尝试连接到指定的主机和端口。</p>
         * @param host		服务器地址。
         * @param port		服务器端口。
         * @param byteClass	用于接收和发送数据的 Byte 类。如果为 null ，则使用 Byte 类，也可传入 Byte 类的子类。
         * @param protocols	子协议名称。子协议名称字符串，或由多个子协议名称字符串构成的数组
         * @param isSecure  是否使用WebSocket安全协议wss，默认（false）使用普通协议ws
         * @see laya.utils.Byte
         */
        constructor(host?: string | null, port?: number, byteClass?: new () => any, protocols?: any[] | null, isSecure?: boolean);
        /**
         * <p>连接到指定的主机和端口。</p>
         * <p>连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。</p>
         * @param host	服务器地址。
         * @param port	服务器端口。
         * @param isSecure  是否使用WebSocket安全协议wss，默认（false）使用普通协议ws
         */
        connect(host: string, port: number, isSecure?: boolean): void;
        /**
         * <p>连接到指定的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。</p>
         * <p>连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。</p>
         * @param url	要连接的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。
         */
        connectByUrl(url: string): void;
        /**
         * 清理Socket：关闭Socket链接，关闭事件监听，重置Socket
         */
        cleanSocket(): void;
        /**
         * 关闭连接。
         */
        close(): void;
        /**
         * @private
         * 连接建立成功 。
         */
        protected _onOpen(e: any): void;
        /**
         * @private
         * 接收到数据处理方法。
         * @param msg 数据。
         */
        protected _onMessage(msg: any): void;
        /**
         * @private
         * 连接被关闭处理方法。
         */
        protected _onClose(e: any): void;
        /**
         * @private
         * 出现异常处理方法。
         */
        protected _onError(e: any): void;
        /**
         * 发送数据到服务器。
         * @param	data 需要发送的数据，可以是String或者ArrayBuffer。
         */
        send(data: any): void;
        /**
         * 发送缓冲区中的数据到服务器。
         */
        flush(): void;
    }
    /**
     * <p><code>URL</code> 提供URL格式化，URL版本管理的类。</p>
     * <p>引擎加载资源的时候，会自动调用formatURL函数格式化URL路径</p>
     * <p>通过basePath属性可以设置网络基础路径</p>
     * <p>通过设置customFormat函数，可以自定义URL格式化的方式</p>
     */
    class URL {
        /**URL地址版本映射表，比如{"aaa/bb.png":"edcba","aaa/bb.png":"1342a"}，默认情况下，通过formatURL格式化后，会自动生成为"aaa/bb-1342a.png"的一个地址*/
        static version: Record<string, string>;
        /**基础路径。如果不设置，默认为当前网页的路径。最终地址将被格式化为 basePath+相对URL地址，*/
        static basePath: string;
        /**扩展的基础路径映射表，比如{"aa/":"http://abc.com/"},则把路径以aa/开头的资源映射到http://abc.com/下*/
        static basePaths: Record<string, string>;
        /**root路径。只针对'~'类型的url路径有效*/
        static rootPath: string;
        /**@private */
        private _url;
        /**@private */
        private _path;
        private static overrideFileExts;
        private static hasExtOverrides;
        static __init__(): void;
        static initMiniGameExtensionOverrides(): void;
        /**创建一个新的 <code>URL</code> 实例。*/
        constructor(url: string);
        /**格式化后的地址。*/
        get url(): string;
        /**地址的文件夹路径（不包括文件名）。*/
        get path(): string;
        /** 自定义URL格式化的方式。例如： customFormat = function(url:String):String{} */
        static customFormat: Function;
        /**
         * 包含normalizedURL功能，并且合并base，如果base没有提供，则使用URL.basePath或者URL.rootPath。
         * @param url 地址。
         * @param base 基础路径，如果没有，则使用URL.basePath或者URL.rootPath。
         * @return 格式化处理后的地址。
         */
        static formatURL(url: string, base?: string): string;
        /**
         * 处理扩展名的自动转换
         * @param url 地址。
         * @return 格式化处理后的地址。
         */
        static postFormatURL(url: string): string;
        /**
         * 格式化相对路径。主要是处理.和..这些情况。
         */
        static normalize(url: string): string;
        static getResURLByUUID(url: string): string;
        /**
        * 组合相对路径并格式化
        * @param base
        * @param path
        */
        static join(base: string, path: string): string;
        /**
         * 获取指定 URL 的文件夹路径（不包括文件名）。
         * <p><b>注意：</b>末尾有斜杠（/）。</p>
         * @param url url地址。
         * @return 返回文件夹路径。
         */
        static getPath(url: string): string;
        /**
         * 获取指定 URL 的文件名。
         * @param url 地址。
         * @return 返回文件名。
         */
        static getFileName(url: string): string;
        /**
         * 获取URL版本字符。
         * @param url
         * @return
         */
        static getURLVerion(url: string): string;
        /**
         * 下载时，转换URL的扩展名。
         * @originalExts 原始扩展名。例如["scene"]。
         * @targetExt 要转换为的扩展名。例如"json"。
         */
        static overrideExtension(originalExts: Array<string>, targetExt: string): void;
    }
    /**
     * Worker Image加载器
     */
    class WorkerLoader {
        /**worker.js的路径 */
        static workerPath: string;
        private static _worker;
        private static _dispatcher;
        private static _enable;
        /**
         * 是否支持worker
         * @return 是否支持worker
         */
        static workerSupported(): boolean;
        /**
         * 是否启用。
         */
        static set enable(value: boolean);
        static get enable(): boolean;
        static load(url: string, options: any): Promise<any>;
        private static workerMessage;
    }
    /**
     * 2D矩形碰撞体
     */
    class BoxCollider extends ColliderBase {
        /**矩形宽度*/
        private _width;
        /**矩形高度*/
        private _height;
        /**
        * 创建一个新的 <code>BoxCollider</code> 实例。
        */
        constructor();
        /**@override */
        protected _setShapeData(shape: any): void;
        /**矩形宽度*/
        get width(): number;
        set width(value: number);
        /**矩形高度*/
        get height(): number;
        set height(value: number);
    }
    /**
     * 2D线形碰撞体
     */
    class ChainCollider extends ColliderBase {
        /**
         * @deprecated
         * 用逗号隔开的点的集合，格式：x,y,x,y ...
         */
        private _points;
        /**顶点数据*/
        private _datas;
        /**是否是闭环，注意不要有自相交的链接形状，它可能不能正常工作*/
        private _loop;
        constructor();
        /**
        * @override
        */
        protected _setShapeData(shape: any): void;
        /**
         * @deprecated
         * 用逗号隔开的点的集合，格式：x,y,x,y ...
         */
        get points(): string;
        onAdded(): void;
        set points(value: string);
        /**顶点数据 x,y,x,y ...*/
        get datas(): number[];
        set datas(value: number[]);
        /**是否是闭环，注意不要有自相交的链接形状，它可能不能正常工作*/
        get loop(): boolean;
        set loop(value: boolean);
    }
    /**
     * 2D圆形碰撞体
     */
    class CircleCollider extends ColliderBase {
        /**圆形半径，必须为正数*/
        private _radius;
        constructor();
        /**
        * @override
        */
        protected _setShapeData(shape: any): void;
        /**圆形半径，必须为正数*/
        get radius(): number;
        set radius(value: number);
    }
    /**
     * 碰撞体基类
     */
    class ColliderBase extends Component {
        /**FixtureBox2DDef 数据 */
        private static TempDef;
        /**是否是传感器，传感器能够触发碰撞事件，但不会产生碰撞反应*/
        private _isSensor;
        /**密度值，值可以为零或者是正数，建议使用相似的密度，这样做可以改善堆叠稳定性，默认值为10*/
        private _density;
        /**摩擦力，取值范围0-1，值越大，摩擦越大，默认值为0.2*/
        private _friction;
        /**弹性系数，取值范围0-1，值越大，弹性越大，默认值为0*/
        private _restitution;
        /**标签*/
        label: string;
        /**@private box2D fixture Def */
        protected _fixtureDef: any;
        /**@readonly[只读]b2Fixture对象 */
        fixture: any;
        /**刚体引用*/
        rigidBody: RigidBody;
        /**相对节点的x轴偏移*/
        private _x;
        /**相对节点的y轴偏移*/
        private _y;
        /**相对节点的x轴偏移*/
        get x(): number;
        set x(value: number);
        /**相对节点的y轴偏移*/
        get y(): number;
        set y(value: number);
        /**
         * 创建一个新的 <code>ColliderBase</code> 实例。
         */
        constructor();
        /**@private 创建Shape*/
        protected createfixture(): any;
        /**@private 设置shape属性*/
        protected resetFixtureData(): void;
        protected _onEnable(): void;
        protected _onAwake(): void;
        /**通知rigidBody 更新shape 属性值 */
        protected _needupdataShapeAttribute(): void;
        /**是否是传感器，传感器能够触发碰撞事件，但不会产生碰撞反应*/
        get isSensor(): boolean;
        set isSensor(value: boolean);
        /**密度值，值可以为零或者是正数，建议使用相似的密度，这样做可以改善堆叠稳定性，默认值为10*/
        get density(): number;
        set density(value: number);
        /**摩擦力，取值范围0-1，值越大，摩擦越大，默认值为0.2*/
        get friction(): number;
        set friction(value: number);
        /**弹性系数，取值范围0-1，值越大，弹性越大，默认值为0*/
        get restitution(): number;
        set restitution(value: number);
        /**
         * @private
         * 碰撞体参数发生变化后，刷新物理世界碰撞信息
         */
        refresh(): void;
        protected _onDisable(): void;
    }
    enum PhysicsShape {
        BoxShape = 0,
        CircleShape = 1,
        PolygonShape = 2,
        ChainShape = 3,
        EdgeShape = 4
    }
    class FixtureBox2DDef {
        density: number;
        friction: number;
        isSensor: boolean;
        restitution: number;
        shape: PhysicsShape;
        groupIndex: number;
    }
    /**
     * 2D边框碰撞体
     */
    class EdgeCollider extends ColliderBase {
        /**
         * @deprecated
         * 用逗号隔开的点的集合，注意只有两个点，格式：x,y,x,y
         */
        private _points;
        /**顶点数据*/
        private _datas;
        constructor();
        /**
         * @override
         */
        protected _setShapeData(shape: any): void;
        /**
         * @deprecated
         * 用逗号隔开的点的集合，注意只有两个点，格式：x,y,x,y*/
        get points(): string;
        set points(value: string);
        /**顶点数据 x,y,x,y ...*/
        get datas(): number[];
        set datas(value: number[]);
    }
    /**
     * 2D多边形碰撞体，暂时不支持凹多边形，如果是凹多边形，先手动拆分为多个凸多边形
     * 节点个数最多是b2_maxPolygonVertices，这数值默认是8，所以点的数量不建议超过8个，也不能小于3个
     */
    class PolygonCollider extends ColliderBase {
        /**
         * @deprecated
         * 用逗号隔开的点的集合，格式：x,y,x,y ...
         */
        private _points;
        /**顶点数据*/
        private _datas;
        constructor();
        onAdded(): void;
        /**
        * @override
        */
        protected _setShapeData(shape: any): void;
        /**
         * @deprecated
         * 用逗号隔开的点的集合，格式：x,y,x,y ...
         */
        get points(): string;
        set points(value: string);
        /**顶点数据 x,y,x,y ...*/
        get datas(): number[];
        set datas(value: number[]);
    }
    /**
     * 实现Box2D c++  2.4.1 版本
     */
    class physics2DwasmFactory implements IPhysiscs2DFactory {
        private _tempVe21;
        private _tempVe22;
        set gravity(value: Vector2);
        set allowSleeping(value: boolean);
        /**
         * initial box2D physics Engine
         * @returns
         */
        initialize(): Promise<void>;
        /**
         * create Box2D world
         */
        start(): void;
        /**
         * update Frame
         * @param delta
         */
        update(delta: number): void;
        /**
         * set Event CallBack
         * @param type
         * @param contact
         */
        sendEvent(type: string, contact: any): void;
        /**
         * create Box2D Body
         * @param def
         * @returns
         */
        createBody(def: any): any;
        /**
         * remove Box2D Body
         * @param body
         */
        removeBody(body: any): void;
        /**
        * create Box2D Joint
        * @param def
        * @returns
        */
        createJoint(def: any, cls?: any): any;
        /**
         * Remove Box2D Joint
         * @param joint
         */
        removeJoint(joint: any): void;
        /**
         * @param joint
         */
        getJoint_userData(joint: any): any;
        /**
         * @param joint
         */
        getJoint_userData_destroy(joint: any): boolean;
        /**
         * @param joint
         * @param enableMotor
         */
        set_Joint_EnableMotor(joint: any, enableMotor: boolean): void;
        /**
         * @param joint
         * @param motorSpeed
         */
        set_Joint_SetMotorSpeed(joint: any, motorSpeed: number): void;
        /**
         * @param joint
         * @param maxTorque
         */
        set_Joint_SetMaxMotorTorque(joint: any, maxTorque: number): void;
        /**
         * @param joint
         * @param enableLimit
         */
        set_Joint_EnableLimit(joint: any, enableLimit: boolean): void;
        /**
         * @param joint
         * @param lowerAngle
         * @param upperAngle
         */
        set_Joint_SetLimits(joint: any, lowerAngle: number, upperAngle: number): void;
        /**
         * @param Joint
         * @param frequency
         * @param dampingRatio
         * @param isdamping
         */
        set_Joint_frequencyAndDampingRatio(Joint: any, frequency: number, dampingRatio: number, isdamping: boolean): void;
        /**
         * @param defStruct
         * @returns
         */
        createDistanceJoint(defStruct: physics2D_DistancJointDef): any;
        /**
         * @param joint
         * @param length
         */
        set_DistanceJoint_length(joint: any, length: number): void;
        /**
         * @param joint
         * @param length
         */
        set_DistanceJoint_MaxLength(joint: any, length: number): void;
        /**
         * @param joint
         * @param length
         */
        set_DistanceJoint_MinLength(joint: any, length: number): void;
        /**
         * @param joint
         * @param steffness
         * @param damping
         */
        set_DistanceJointStiffnessDamping(joint: any, steffness: number, damping: number): void;
        /**
         * @param defStruct
         * @returns
         */
        create_GearJoint(defStruct: physics2D_GearJointDef): void;
        /**
         * @param joint
         * @param radio
         */
        set_GearJoint_SetRatio(joint: any, radio: number): void;
        /**
         * @param defStruct
         * @returns
         */
        create_PulleyJoint(defStruct: physics2D_PulleyJointDef): void;
        /**
         * @param defStruct
         * @returns
         */
        create_WheelJoint(defStruct: physics2D_WheelJointDef): any;
        /**
         * @param defStruct
         * @returns
         */
        create_WeldJoint(defStruct: physics2D_WeldJointDef): any;
        /**
         * @param def
         * @returns
         */
        create_MouseJoint(defStruct: physics2D_MouseJointJointDef): any;
        /**
         * @param joint
         * @param x
         * @param y
         */
        set_MouseJoint_target(joint: any, x: number, y: number): void;
        /**
         * @param Joint
         * @param frequency
         * @param dampingRatio
         */
        set_MouseJoint_frequencyAndDampingRatio(Joint: any, frequency: number, dampingRatio: number): void;
        /**
         * @param defStruct
         * @returns
         */
        create_RevoluteJoint(defStruct: physics2D_RevoluteJointDef): any;
        /**
         * @param defStruct
         * @returns
         */
        create_MotorJoint(defStruct: physics2D_MotorJointDef): any;
        /**
         * @param joint
         * @param x
         * @param y
         */
        set_MotorJoint_linearOffset(joint: any, x: number, y: number): void;
        /**
         * @param joint
         * @param angular
         */
        set_MotorJoint_SetAngularOffset(joint: any, angular: number): void;
        /**
         * @param joint
         * @param maxForce
         */
        set_MotorJoint_SetMaxForce(joint: any, maxForce: number): void;
        /**
         * @param joint
         * @param maxTorque
         */
        set_MotorJoint_SetMaxTorque(joint: any, maxTorque: number): void;
        /**
         * @param joint
         * @param correctionFactor
         */
        set_MotorJoint_SetCorrectionFactor(joint: any, correctionFactor: number): void;
        /**
         * @param def
         * @returns
         */
        create_PrismaticJoint(def: physics2D_PrismaticJointDef): any;
        /**
         * @returns
         */
        create_boxColliderShape(): any;
        /**
         * @param shape
         * @param width
         * @param height
         * @param pos
         *
         */
        set_collider_SetAsBox(shape: any, width: number, height: number, pos: IV2, scaleX: number, scaleY: number): void;
        /**
         * @returns
         */
        create_ChainShape(): any;
        /**
         * @param shape
         * @param x
         * @param y
         * @param arr
         * @param loop
         */
        set_ChainShape_data(shape: any, x: number, y: number, arr: number[], loop: boolean, scaleX: number, scaleY: number): void;
        /**
         * @returns
         */
        create_CircleShape(): any;
        /**
         * @param shape
         * @param radius
         */
        set_CircleShape_radius(shape: any, radius: number, scale: number): void;
        /**
         * @param shape
         * @param x
         * @param y
         */
        set_CircleShape_pos(shape: any, x: number, y: number, scale: number): void;
        /**
         * @returns
         */
        create_EdgeShape(): any;
        /**
         * @param shape
         * @param x
         * @param y
         * @param arr
         */
        set_EdgeShape_data(shape: any, x: number, y: number, arr: number[], scaleX: number, scaleY: number): void;
        /**
         * @returns
         */
        create_PolygonShape(): any;
        /**
        * @param shape
        * @param x
        * @param y
        * @param arr
        */
        set_PolygonShape_data(shape: any, x: number, y: number, arr: number[], scaleX: number, scaleY: number): void;
        /**
         * create fixture descript
         * @param fixtureDef
         * @returns
         */
        createFixtureDef(fixtureDef: FixtureBox2DDef): any;
        /**
         * @param def
         * @param groupIndex
         */
        set_fixtureDef_GroupIndex(def: any, groupIndex: number): void;
        /**
         * @param def
         * @param categoryBits
         */
        set_fixtureDef_CategoryBits(def: any, categoryBits: number): void;
        /**
         * @param def
         * @param maskbits
         */
        set_fixtureDef_maskBits(def: any, maskbits: number): void;
        /**
        * create fixture by body and def
        * @param body
        * @param def
        */
        createfixture(body: any, fixtureDef: any): any;
        /**
         * @param fixture
         * @param instance
         */
        set_fixture_collider(fixture: any, instance: ColliderBase): void;
        /**
         * @param fixture
         */
        get_fixture_body(fixture: any): any;
        /**
         * @param body
         * @param fixture
         */
        rigidBody_DestroyFixture(body: any, fixture: any): void;
        /**
         * @param rigidbodyDef
         * @returns
         */
        rigidBodyDef_Create(rigidbodyDef: RigidBody2DInfo): any;
        /**
         * @param body
         * @param v2
         */
        get_RigidBody_Position(body: any, v2: Vector2): void;
        /**
         * @param body
         * @returns
         */
        get_RigidBody_Angle(body: any): number;
        /**
         * @param body
         * @param x
         * @param y
         * @param angle
         */
        set_RigibBody_Transform(body: any, x: number, y: number, angle: any): void;
        /**
         * @param body
         * @param x
         * @param y
         * @returns
         */
        get_rigidBody_WorldPoint(body: any, x: number, y: number): IV2;
        /**
         * @param body
         * @param x
         * @param y
         */
        get_rigidBody_LocalPoint(body: any, x: number, y: number): IV2;
        /**
         * @param body
         * @param force
         * @param position
         */
        rigidBody_applyForce(body: any, force: IV2, position: IV2): void;
        /**
         * @param body
         * @param force
         */
        rigidBody_applyForceToCenter(body: any, force: IV2): void;
        /**
         * @param body
         * @param impulse
         * @param position
         */
        rigidbody_ApplyLinearImpulse(body: any, impulse: IV2, position: IV2): void;
        /**
         * @param body
         */
        rigidbody_ApplyLinearImpulseToCenter(body: any, impulse: IV2): void;
        /**
        * 对刚体施加扭矩，使其旋转
        * @param	torque	施加的扭矩
        */
        rigidbody_applyTorque(body: any, torque: number): void;
        /**
         * 设置速度，比如{x:10,y:10}
         * @param	velocity
         */
        set_rigidbody_Velocity(body: any, velocity: IV2): void;
        /**
         * 设置角度
         * @param	value 单位为弧度
         */
        set_rigidbody_Awake(body: any, awake: boolean): void;
        /**
         * 获得刚体质量
         * @param body
         * @returns
         */
        get_rigidbody_Mass(body: any): number;
        /**
         * 获得质心的相对节点0,0点的位置偏移
         * @param body
         * @returns
         */
        get_rigidBody_Center(body: any): IV2;
        /**
         * @param body
         */
        get_rigidBody_IsAwake(body: any): any;
        /**
         * 获得质心的世界坐标，相对于Physics.I.worldRoot节点
         * @param body
         * @returns
         */
        get_rigidBody_WorldCenter(body: any): IV2;
        /**
         * @param body
         * @param value
         */
        set_rigidBody_type(body: any, value: string): void;
        /**
         * @param body
         * @param value
         */
        set_rigidBody_gravityScale(body: any, value: number): void;
        /**
         * @param body
         * @param value
         */
        set_rigidBody_allowRotation(body: any, value: boolean): void;
        /**
         * @param body
         * @param value
         */
        set_rigidBody_allowSleep(body: any, value: boolean): void;
        /**
         * @param body
         * @param value
         */
        set_rigidBody_angularDamping(body: any, value: number): void;
        /**
         * @param body
         * @returns
         */
        get_rigidBody_angularVelocity(body: any): number;
        /**
         * @param body
         * @param value
         */
        set_rigidBody_angularVelocity(body: any, value: number): void;
        /**
         * @param body
         * @param value
         */
        set_rigidBody_linearDamping(body: any, value: number): void;
        /**
         * @param body
         * @returns
         */
        get_rigidBody_linearVelocity(body: any): IV2;
        /**
         * @param body
         * @param value
         */
        set_rigidBody_linearVelocity(body: any, value: IV2): void;
        /**
         * @param body
         * @param value
         */
        set_rigidBody_bullet(body: any, value: boolean): void;
        /**
        * @param body
        */
        retSet_rigidBody_MassData(body: any): void;
    }
    interface IPhysiscs2DFactory {
    }
    /**
     * 距离关节：两个物体上面各自有一点，两点之间的距离固定不变
     */
    class DistanceJoint extends JointBase {
        /**@private */
        private static _temp;
        /**[首次设置有效]关节的自身刚体*/
        selfBody: RigidBody;
        /**[首次设置有效]关节的连接刚体，可不设置，默认为左上角空刚体*/
        otherBody: RigidBody;
        /**[首次设置有效]自身刚体链接点，是相对于自身刚体的左上角位置偏移*/
        selfAnchor: any[];
        /**[首次设置有效]链接刚体链接点，是相对于otherBody的左上角位置偏移*/
        otherAnchor: any[];
        /**[首次设置有效]两个刚体是否可以发生碰撞，默认为false*/
        collideConnected: boolean;
        /**约束的目标静止长度*/
        private _length;
        /**约束的最小长度，-1表示使用默认值*/
        private _maxLength;
        /**约束的最大长度，-1表示使用默认值*/
        private _minLength;
        /**弹簧系统的震动频率，可以视为弹簧的弹性系数，通常频率应该小于时间步长频率的一半*/
        private _frequency;
        /**刚体在回归到节点过程中受到的阻尼比，建议取值0~1*/
        private _dampingRatio;
        /**
         * @override
         */
        protected _createJoint(): void;
        onDestroy(): void;
        /**约束的目标静止长度*/
        get length(): number;
        set length(value: number);
        /**约束的最小长度*/
        get minLength(): number;
        set minLength(value: number);
        /**约束的最大长度*/
        get maxLength(): number;
        set maxLength(value: number);
        /**弹簧系统的震动频率，可以视为弹簧的弹性系数，通常频率应该小于时间步长频率的一半*/
        get frequency(): number;
        set frequency(value: number);
        /**刚体在回归到节点过程中受到的阻尼比，建议取值0~1*/
        get damping(): number;
        set damping(value: number);
        /**刚体当前长度*/
        get jointLength(): number;
    }
    /**
     * 齿轮关节：用来模拟两个齿轮间的约束关系，齿轮旋转时，产生的动量有两种输出方式，一种是齿轮本身的角速度，另一种是齿轮表面的线速度
     */
    class GearJoint extends JointBase {
        /**@private */
        private static _temp;
        /**[首次设置有效]要绑定的第1个关节，类型可以是RevoluteJoint或者PrismaticJoint*/
        joint1: RevoluteJoint | PrismaticJoint;
        /**[首次设置有效]要绑定的第2个关节，类型可以是RevoluteJoint或者PrismaticJoint*/
        joint2: RevoluteJoint | PrismaticJoint;
        /**[首次设置有效]两个刚体是否可以发生碰撞，默认为false*/
        collideConnected: boolean;
        /**两个齿轮角速度比例，默认1*/
        private _ratio;
        /**
         * @override
         *
         */
        protected _createJoint(): void;
        /**两个齿轮角速度比例，默认1*/
        get ratio(): number;
        set ratio(value: number);
    }
    /**
     * 关节基类
     */
    class JointBase extends Component {
        /**原生关节对象*/
        protected _joint: any;
        protected _factory: IPhysiscs2DFactory;
        constructor();
        protected getBodyAnchor(body: RigidBody, anchorx: number, anchory: number): Point;
        /**[只读]原生关节对象*/
        get joint(): any;
        protected _onEnable(): void;
        protected _onAwake(): void;
        protected _createJoint(): void;
        protected _onDisable(): void;
    }
    /**
     * Box2D distance Joint def Struct
     */
    class physics2D_DistancJointDef {
        bodyA: any;
        bodyB: any;
        localAnchorA: Vector2;
        localAnchorB: Vector2;
        frequency: number;
        dampingRatio: number;
        collideConnected: boolean;
        length: number;
        maxLength: number;
        minLength: number;
        isLocalAnchor: boolean;
    }
    class physics2D_GearJointDef {
        bodyA: any;
        bodyB: any;
        joint1: any;
        joint2: any;
        ratio: number;
        collideConnected: boolean;
    }
    class physics2D_MotorJointDef {
        bodyA: any;
        bodyB: any;
        linearOffset: Vector2;
        angularOffset: number;
        maxForce: number;
        maxTorque: number;
        correctionFactor: number;
        collideConnected: boolean;
    }
    class physics2D_MouseJointJointDef {
        bodyA: any;
        bodyB: any;
        maxForce: number;
        frequency: number;
        dampingRatio: number;
        target: Vector2;
    }
    class physics2D_PrismaticJointDef {
        bodyA: any;
        bodyB: any;
        anchor: Vector2;
        axis: Vector2;
        enableMotor: boolean;
        motorSpeed: number;
        maxMotorForce: number;
        enableLimit: boolean;
        lowerTranslation: number;
        upperTranslation: number;
        collideConnected: boolean;
    }
    class physics2D_PulleyJointDef {
        bodyA: any;
        bodyB: any;
        groundAnchorA: Vector2;
        groundAnchorB: Vector2;
        localAnchorA: Vector2;
        localAnchorB: Vector2;
        ratio: number;
        collideConnected: boolean;
    }
    class physics2D_RevoluteJointDef {
        bodyA: any;
        bodyB: any;
        anchor: Vector2;
        enableMotor: boolean;
        motorSpeed: number;
        maxMotorTorque: number;
        enableLimit: boolean;
        lowerAngle: number;
        upperAngle: number;
        collideConnected: boolean;
    }
    class physics2D_WeldJointDef {
        bodyA: any;
        bodyB: any;
        anchor: Vector2;
        frequency: number;
        dampingRatio: number;
        collideConnected: boolean;
    }
    class physics2D_WheelJointDef {
        bodyA: any;
        bodyB: any;
        anchor: Vector2;
        axis: Vector2;
        enableMotor: boolean;
        motorSpeed: number;
        maxMotorTorque: number;
        enableLimit: boolean;
        lowerTranslation: number;
        upperTranslation: number;
        frequency: number;
        dampingRatio: number;
        collideConnected: boolean;
    }
    /**
     * 马达关节：用来限制两个刚体，使其相对位置和角度保持不变
     */
    class MotorJoint extends JointBase {
        /**@private */
        private static _temp;
        /**[首次设置有效]关节的自身刚体*/
        selfBody: RigidBody;
        /**[首次设置有效]关节的连接刚体*/
        otherBody: RigidBody;
        /**[首次设置有效]两个刚体是否可以发生碰撞，默认为false*/
        collideConnected: boolean;
        /**基于otherBody坐标位置的偏移量，也是selfBody的目标位置*/
        private _linearOffset;
        /**基于otherBody的角度偏移量，也是selfBody的目标角度*/
        private _angularOffset;
        /**当selfBody偏离目标位置时，为使其恢复到目标位置，马达关节所施加的最大作用力*/
        private _maxForce;
        /**当selfBody角度与目标角度不同时，为使其达到目标角度，马达关节施加的最大扭力*/
        private _maxTorque;
        /**selfBody向目标位置移动时的缓动因子，取值0~1，值越大速度越快*/
        private _correctionFactor;
        /**
         * @override
         *
         */
        protected _createJoint(): void;
        /**基于otherBody坐标位置的偏移量，也是selfBody的目标位置*/
        get linearOffset(): any[];
        set linearOffset(value: any[]);
        /**基于otherBody的角度偏移量，也是selfBody的目标角度*/
        get angularOffset(): number;
        set angularOffset(value: number);
        /**当selfBody偏离目标位置时，为使其恢复到目标位置，马达关节所施加的最大作用力*/
        get maxForce(): number;
        set maxForce(value: number);
        /**当selfBody角度与目标角度不同时，为使其达到目标角度，马达关节施加的最大扭力*/
        get maxTorque(): number;
        set maxTorque(value: number);
        /**selfBody向目标位置移动时的缓动因子，取值0~1，值越大速度越快*/
        get correctionFactor(): number;
        set correctionFactor(value: number);
    }
    /**
     * 鼠标关节：鼠标关节用于通过鼠标来操控物体。它试图将物体拖向当前鼠标光标的位置。而在旋转方面就没有限制。
     */
    class MouseJoint extends JointBase {
        /**@private */
        private static _temp;
        /**[首次设置有效]关节的自身刚体*/
        selfBody: RigidBody;
        /**[首次设置有效]关节的链接点，是相对于自身刚体的左上角位置偏移，如果不设置，则根据鼠标点击点作为连接点*/
        anchor: any[];
        /**鼠标关节在拖曳刚体bodyB时施加的最大作用力*/
        private _maxForce;
        /**弹簧系统的震动频率，可以视为弹簧的弹性系数，通常频率应该小于时间步长频率的一半*/
        private _frequency;
        /**刚体在回归到节点过程中受到的阻尼比，建议取值0~1*/
        private _dampingRatio;
        protected _onEnable(): void;
        protected _onAwake(): void;
        private onMouseDown;
        /**
         * @override
         *
         */
        protected _createJoint(): void;
        private onStageMouseUp;
        private onMouseMove;
        protected _onDisable(): void;
        /**鼠标关节在拖曳刚体bodyB时施加的最大作用力*/
        get maxForce(): number;
        set maxForce(value: number);
        /**弹簧系统的震动频率，可以视为弹簧的弹性系数，通常频率应该小于时间步长频率的一半*/
        get frequency(): number;
        set frequency(value: number);
        /**刚体在回归到节点过程中受到的阻尼比，建议取值0~1*/
        get damping(): number;
        set damping(value: number);
    }
    /**
     * 平移关节：移动关节允许两个物体沿指定轴相对移动，它会阻止相对旋转
     */
    class PrismaticJoint extends JointBase {
        /**@private */
        private static _temp;
        /**[首次设置有效]关节的自身刚体*/
        selfBody: RigidBody;
        /**[首次设置有效]关节的连接刚体，可不设置，默认为左上角空刚体*/
        otherBody: RigidBody;
        /**[首次设置有效]关节的控制点，是相对于自身刚体的左上角位置偏移*/
        anchor: any[];
        /**
         * @deprecated
         * [首次设置有效]一个向量值，描述运动方向，比如1,0是沿X轴向右*/
        _axis: any[];
        /**[首次设置有效]一个角度，描述运动方向，比如0是沿X轴向右*/
        angle: number;
        /**[首次设置有效]两个刚体是否可以发生碰撞，默认为false*/
        collideConnected: boolean;
        /**是否开启马达，开启马达可使目标刚体运动*/
        private _enableMotor;
        /**启用马达后，在axis坐标轴上移动可以达到的最大速度*/
        private _motorSpeed;
        /**启用马达后，可以施加的最大作用力*/
        private _maxMotorForce;
        /**是否对刚体的移动范围加以约束*/
        private _enableLimit;
        /**启用约束后，刚体移动范围的下限，是距离anchor的偏移量*/
        private _lowerTranslation;
        /**启用约束后，刚体移动范围的上限，是距离anchor的偏移量*/
        private _upperTranslation;
        /**
         * @override
         *
         */
        protected _createJoint(): void;
        /**是否开启马达，开启马达可使目标刚体运动*/
        get enableMotor(): boolean;
        set enableMotor(value: boolean);
        /**启用马达后，在axis坐标轴上移动可以达到的最大速度*/
        get motorSpeed(): number;
        set motorSpeed(value: number);
        /**启用马达后，可以施加的最大作用力*/
        get maxMotorForce(): number;
        set maxMotorForce(value: number);
        /**是否对刚体的移动范围加以约束*/
        get enableLimit(): boolean;
        set enableLimit(value: boolean);
        /**启用约束后，刚体移动范围的下限，是距离anchor的偏移量*/
        get lowerTranslation(): number;
        set lowerTranslation(value: number);
        /**启用约束后，刚体移动范围的上限，是距离anchor的偏移量*/
        get upperTranslation(): number;
        set upperTranslation(value: number);
        /**
         * @deprecated
         * 启用约束后，刚体移动范围的上限，是距离anchor的偏移量*/
        get axis(): any;
        set axis(value: any);
    }
    /**
     * 滑轮关节：它将两个物体接地(ground)并彼此连接，当一个物体上升，另一个物体就会下降
     */
    class PulleyJoint extends JointBase {
        /**@private */
        private static _temp;
        /**[首次设置有效]关节的自身刚体*/
        selfBody: RigidBody;
        /**[首次设置有效]关节的连接刚体*/
        otherBody: RigidBody;
        /**[首次设置有效]自身刚体链接点，是相对于自身刚体的左上角位置偏移*/
        selfAnchor: any[];
        /**[首次设置有效]链接刚体链接点，是相对于otherBody的左上角位置偏移*/
        otherAnchor: any[];
        /**[首次设置有效]滑轮上与节点selfAnchor相连接的节点，是相对于自身刚体的左上角位置偏移*/
        selfGroundPoint: any[];
        /**[首次设置有效]滑轮上与节点otherAnchor相连接的节点，是相对于otherBody的左上角位置偏移*/
        otherGroundPoint: any[];
        /**[首次设置有效]两刚体移动距离比率*/
        ratio: number;
        /**[首次设置有效]两个刚体是否可以发生碰撞，默认为false*/
        collideConnected: boolean;
        /**
         * @override
         */
        protected _createJoint(): void;
    }
    /**
     * 旋转关节强制两个物体共享一个锚点，两个物体相对旋转
     */
    class RevoluteJoint extends JointBase {
        /**@private */
        private static _temp;
        /**[首次设置有效]关节的自身刚体*/
        selfBody: RigidBody;
        /**[首次设置有效]关节的连接刚体，可不设置*/
        otherBody: RigidBody;
        /**[首次设置有效]关节的链接点，是相对于自身刚体的左上角位置偏移*/
        anchor: any[];
        /**[首次设置有效]两个刚体是否可以发生碰撞，默认为false*/
        collideConnected: boolean;
        /**是否开启马达，开启马达可使目标刚体运动*/
        private _enableMotor;
        /**启用马达后，可以达到的最大旋转速度*/
        private _motorSpeed;
        /**启用马达后，可以施加的最大扭距，如果最大扭矩太小，会导致不旋转*/
        private _maxMotorTorque;
        /**是否对刚体的旋转范围加以约束*/
        private _enableLimit;
        /**启用约束后，刚体旋转范围的下限角度*/
        private _lowerAngle;
        /**启用约束后，刚体旋转范围的上限角度*/
        private _upperAngle;
        /**
         * @override
         */
        protected _createJoint(): void;
        /**是否开启马达，开启马达可使目标刚体运动*/
        get enableMotor(): boolean;
        set enableMotor(value: boolean);
        /**启用马达后，可以达到的最大旋转速度*/
        get motorSpeed(): number;
        set motorSpeed(value: number);
        /**启用马达后，可以施加的最大扭距，如果最大扭矩太小，会导致不旋转*/
        get maxMotorTorque(): number;
        set maxMotorTorque(value: number);
        /**是否对刚体的旋转范围加以约束*/
        get enableLimit(): boolean;
        set enableLimit(value: boolean);
        /**启用约束后，刚体旋转范围的下限角度*/
        get lowerAngle(): number;
        set lowerAngle(value: number);
        /**启用约束后，刚体旋转范围的上限角度*/
        get upperAngle(): number;
        set upperAngle(value: number);
    }
    /**
     * 焊接关节：焊接关节的用途是使两个物体不能相对运动，受到关节的限制，两个刚体的相对位置和角度都保持不变，看上去像一个整体
     */
    class WeldJoint extends JointBase {
        /**@private */
        private static _temp;
        /**[首次设置有效]关节的自身刚体*/
        selfBody: RigidBody;
        /**[首次设置有效]关节的连接刚体*/
        otherBody: RigidBody;
        /**[首次设置有效]关节的链接点，是相对于自身刚体的左上角位置偏移*/
        anchor: any[];
        /**[首次设置有效]两个刚体是否可以发生碰撞，默认为false*/
        collideConnected: boolean;
        /**弹簧系统的震动频率，可以视为弹簧的弹性系数，通常频率应该小于时间步长频率的一半*/
        private _frequency;
        /**刚体在回归到节点过程中受到的阻尼比，建议取值0~1*/
        private _dampingRatio;
        /**
         * @override
         */
        protected _createJoint(): void;
        /**弹簧系统的震动频率，可以视为弹簧的弹性系数，通常频率应该小于时间步长频率的一半*/
        get frequency(): number;
        set frequency(value: number);
        /**刚体在回归到节点过程中受到的阻尼比，建议取值0~1*/
        get damping(): number;
        set damping(value: number);
    }
    /**
     * 轮子关节：围绕节点旋转，包含弹性属性，使得刚体在节点位置发生弹性偏移
     */
    class WheelJoint extends JointBase {
        /**@private */
        private static _temp;
        /**[首次设置有效]关节的自身刚体*/
        selfBody: RigidBody;
        /**[首次设置有效]关节的连接刚体*/
        otherBody: RigidBody;
        /**[首次设置有效]关节的链接点，是相对于自身刚体的左上角位置偏移*/
        anchor: any[];
        /**[首次设置有效]两个刚体是否可以发生碰撞，默认为false*/
        collideConnected: boolean;
        /**
         * @deprecated
         * [首次设置有效]一个向量值，用于定义弹性运动方向，即轮子在哪个方向可以如弹簧一样压缩和伸展，比如1,0是沿X轴向右，0,1是沿Y轴向下*/
        _axis: any[];
        /**[首次设置有效]一个角度值，用于定义弹性运动方向，即轮子在哪个方向可以如弹簧一样压缩和伸展，比如0是沿X轴向右, 90是沿Y轴向下*/
        angle: number;
        /**弹簧系统的震动频率，可以视为弹簧的弹性系数，通常频率应该小于时间步长频率的一半*/
        private _frequency;
        /**刚体在回归到节点过程中受到的阻尼比，建议取值0~1*/
        private _dampingRatio;
        /**是否开启马达，开启马达可使目标刚体运动*/
        private _enableMotor;
        /**启用马达后，可以达到的最大旋转速度*/
        private _motorSpeed;
        /**启用马达后，可以施加的最大扭距，如果最大扭矩太小，会导致不旋转*/
        private _maxMotorTorque;
        /**是否对刚体的移动范围加以约束*/
        private _enableLimit;
        /**启用约束后，刚体移动范围的下限，是距离anchor的偏移量*/
        private _lowerTranslation;
        /**启用约束后，刚体移动范围的上限，是距离anchor的偏移量*/
        private _upperTranslation;
        /**
         * @override
         */
        protected _createJoint(): void;
        /**弹簧系统的震动频率，可以视为弹簧的弹性系数，通常频率应该小于时间步长频率的一半*/
        get frequency(): number;
        set frequency(value: number);
        /**刚体在回归到节点过程中受到的阻尼比，建议取值0~1*/
        get damping(): number;
        set damping(value: number);
        /**是否开启马达，开启马达可使目标刚体运动*/
        get enableMotor(): boolean;
        set enableMotor(value: boolean);
        /**启用马达后，可以达到的最大旋转速度*/
        get motorSpeed(): number;
        set motorSpeed(value: number);
        /**启用马达后，可以施加的最大扭距，如果最大扭矩太小，会导致不旋转*/
        get maxMotorTorque(): number;
        set maxMotorTorque(value: number);
        /**是否对刚体的移动范围加以约束*/
        get enableLimit(): boolean;
        set enableLimit(value: boolean);
        /**启用约束后，刚体移动范围的下限，是距离anchor的偏移量*/
        get lowerTranslation(): number;
        set lowerTranslation(value: number);
        /**启用约束后，刚体移动范围的上限，是距离anchor的偏移量*/
        get upperTranslation(): number;
        set upperTranslation(value: number);
        /**
         * @deprecated
         * 启用约束后，刚体移动范围的上限，是距离anchor的偏移量*/
        get axis(): any;
        set axis(value: any);
    }
    /**
     * 2D物理引擎
     */
    class Physics2D extends EventDispatcher {
        /**@private */
        private static _I;
        /**@private 是否已经激活*/
        private _enabled;
        /**@private 根容器*/
        private _worldRoot;
        /**@private 空的body节点，给一些不需要节点的关节使用*/
        _emptyBody: any;
        /**@private */
        _eventList: any[];
        _factory: IPhysiscs2DFactory;
        /**@private 需要同步实时跟新数据列表*/
        _rigiBodyList: SingletonList<RigidBody>;
        /**@private 需要同步物理数据的列表；使用后会及时释放*/
        _updataattributeLists: SingletonList<RigidBody>;
        /**全局物理单例*/
        static get I(): Physics2D;
        /**
         * 设置物理绘制
         */
        set enableDebugDraw(enable: boolean);
        /**
         * 是否绘制Shape
         */
        set drawShape(enable: boolean);
        /**
         * 是否绘制Joint
         */
        set drawJoint(enable: boolean);
        /**
         * 是否绘制AABB
         */
        set drawAABB(enable: boolean);
        /**
        * 是否绘制Pair
        */
        set drawPair(enable: boolean);
        /**
        * 是否绘制CenterOfMass
        */
        set drawCenterOfMass(enable: boolean);
        enable(): Promise<void>;
        /**
        * 销毁当前物理世界
        */
        destroyWorld(): void;
        /**
         * 开启物理世界
         */
        start(): void;
        /**@private*/
        private _update;
        /**@private*/
        _updatePhysicsTransformToRender(): void;
        /**
         * 停止物理世界
         */
        stop(): void;
        /**
         * 设置是否允许休眠，休眠可以提高稳定性和性能，但通常会牺牲准确性
         */
        get allowSleeping(): boolean;
        set allowSleeping(value: boolean);
        /**
        * 物理世界重力环境，默认值为{x:0,y:10}
        * 如果修改y方向重力方向向上，可以直接设置gravity.y=-10;
        */
        get gravity(): any;
        set gravity(value: Vector2);
        /**获得刚体总数量*/
        getBodyCount(): number;
        /**获得碰撞总数量*/
        getContactCount(): number;
        /**获得关节总数量*/
        getJointCount(): number;
        /**物理世界根容器，将根据此容器作为物理世界坐标世界，进行坐标变换，默认值为stage
         * 设置特定容器后，就可整体位移物理对象，保持物理世界不变。
         * 注意，仅会在 set worldRoot 时平移一次，其他情况请配合 updatePhysicsByWorldRoot 函数使用*/
        get worldRoot(): Sprite;
        set worldRoot(value: Sprite);
        /**
         * 设定 worldRoot 后，手动触发物理世界更新
         */
        updatePhysicsByWorldRoot(): void;
    }
    /**
     * 物理辅助线
     */
    class Physics2DDebugDraw extends Sprite {
        DrawString_color: string;
        Red: string;
        Green: string;
        /**@protected */
        protected _camera: any;
        /**@protected */
        protected _mG: Graphics;
        /**@private */
        private _textSp;
        /**@protected */
        protected _textG: Graphics;
        /**@protected */
        protected _factory: IPhysiscs2DFactory;
        /**@protected */
        protected _lineWidth: number;
        constructor(factory: IPhysiscs2DFactory);
        /**@private
         * @override
        */
        render(ctx: Context, x: number, y: number): void;
        /**@private */
        private _renderToGraphic;
        PushTransform(tx: number, ty: number, angle: number): void;
        PopTransform(): void;
        get mG(): Graphics;
        get textG(): Graphics;
        get lineWidth(): number;
        get camera(): any;
    }
    /**
     *  Physics2DOption 用于配置2D物理的默认参数
     */
    class Physics2DOption {
        /**设置是否允许休眠，休眠可以提高稳定性和性能，但通常会牺牲准确性*/
        static allowSleeping: boolean;
        /**重力 （单位：像素）*/
        static gravity: {
            x: number;
            y: number;
        };
        /**是否由外部跟新*/
        static customUpdate: boolean;
        /**旋转迭代次数，增大数字会提高精度，但是会降低性能*/
        static velocityIterations: number;
        /**位置迭代次数，增大数字会提高精度，但是会降低性能*/
        static positionIterations: number;
        /**2D游戏默认单位为像素，物理默认单位为米，此值设置了像素和米的转换比率，默认50像素=1米*/
        static pixelRatio: number;
        /**是否开启物理绘制*/
        static debugDraw: boolean;
        /**是否绘制形状*/
        static drawShape: boolean;
        /**是否绘制关节*/
        static drawJoint: boolean;
        /**是否绘制包围盒*/
        static drawAABB: boolean;
        /**是否绘制质心*/
        static drawCenterOfMass: boolean;
    }
    /**
     * 2D刚体，显示对象通过RigidBody和物理世界进行绑定，保持物理和显示对象之间的位置同步
     * 物理世界的位置变化会自动同步到显示对象，显示对象本身的位移，旋转（父对象位移无效）也会自动同步到物理世界
     * 如果想整体位移物理世界，可以Physics2D.I.worldRoot=场景，然后移动场景即可
     * 可以通过IDE-"项目设置"-"2D物理"-"是否开启2D物理绘制" 开启物理辅助线显示，或者通过代码Physics2D.I.enableDebugDraw=true;
     */
    class RigidBody extends Component {
        /** 用于判断节点属性更改时更新物理属性*/
        private static changeFlag;
        /**
         * 刚体类型，支持三种类型static，dynamic和kinematic类型，默认为dynamic类型
         * static为静态类型，静止不动，不受重力影响，质量无限大，可以通过节点移动，旋转，缩放进行控制
         * dynamic为动态类型，受重力影响
         * kinematic为运动类型，不受重力影响，可以通过施加速度或者力的方式使其运动
         */
        protected _type: string;
        /**是否允许休眠，允许休眠能提高性能*/
        protected _allowSleep: boolean;
        /**角速度，设置会导致旋转*/
        protected _angularVelocity: number;
        /**旋转速度阻尼系数，范围可以在0到无穷大之间，0表示没有阻尼，无穷大表示满阻尼，通常阻尼的值应该在0到0.1之间*/
        protected _angularDamping: number;
        /**线性运动速度，比如{x:10,y:10}*/
        protected _linearVelocity: any;
        /**线性速度阻尼系数，范围可以在0到无穷大之间，0表示没有阻尼，无穷大表示满阻尼，通常阻尼的值应该在0到0.1之间*/
        protected _linearDamping: number;
        /**是否高速移动的物体，设置为true，可以防止高速穿透*/
        protected _bullet: boolean;
        /**是否允许旋转，如果不希望刚体旋转，这设置为false*/
        protected _allowRotation: boolean;
        /**重力缩放系数，设置为0为没有重力*/
        protected _gravityScale: number;
        /**[只读] 指定了该主体所属的碰撞组，默认为0，碰撞规则如下：
         * 1.如果两个对象group相等
         * 		group值大于零，它们将始终发生碰撞
         * 		group值小于零，它们将永远不会发生碰撞
         * 		group值等于0，则使用规则3
         * 2.如果group值不相等，则使用规则3
         * 3.每个刚体都有一个category类别，此属性接收位字段，范围为[1,2^31]范围内的2的幂
         * 每个刚体也都有一个mask类别，指定与其碰撞的类别值之和（值是所有category按位AND的值）
         */
        group: number;
        /**[只读]碰撞类别，使用2的幂次方值指定，有32种不同的碰撞类别可用*/
        category: number;
        /**[只读]指定冲突位掩码碰撞的类别，category位操作的结果*/
        mask: number;
        /**[只读]自定义标签*/
        label: string;
        /**[只读]原始刚体*/
        protected _body: any;
        /**
         * @private
         */
        private _createBody;
        /**
         * @private
         * 同步Body 类型
         */
        private _updateBodyType;
        /** @override */
        protected _onAwake(): void;
        /** @private */
        private _globalChangeHandler;
        /** @override */
        protected _onEnable(): void;
        /** @override */
        protected _onDisable(): void;
        /** @override */
        protected _onDestroy(): void;
        /**获得原始body对象 */
        getBody(): any;
        _getOriBody(): any;
        /**[只读]获得原始body对象 */
        get body(): any;
        /**
         * 对刚体施加力
         * @param	position 施加力的点，如{x:100,y:100}，全局坐标
         * @param	force	施加的力，如{x:0.1,y:0.1}
         */
        applyForce(position: IV2, force: IV2): void;
        /**
         * 从中心点对刚体施加力，防止对象旋转
         * @param	force	施加的力，如{x:0.1,y:0.1}
         */
        applyForceToCenter(force: IV2): void;
        /**
         * 施加速度冲量，添加的速度冲量会与刚体原有的速度叠加，产生新的速度
         * @param	position 施加力的点，如{x:100,y:100}，全局坐标
         * @param	impulse	施加的速度冲量，如{x:0.1,y:0.1}
         */
        applyLinearImpulse(position: IV2, impulse: IV2): void;
        /**
         * 施加速度冲量，添加的速度冲量会与刚体原有的速度叠加，产生新的速度
         * @param	impulse	施加的速度冲量，如{x:0.1,y:0.1}
         */
        applyLinearImpulseToCenter(impulse: IV2): void;
        /**
         * 对刚体施加扭矩，使其旋转
         * @param	torque	施加的扭矩
         */
        applyTorque(torque: number): void;
        /**
         * 设置速度，比如{x:10,y:10}
         * @param	velocity
         */
        setVelocity(velocity: IV2): void;
        /**
         * 设置角度
         * @param	value 单位为角度
         */
        setAngle(value: any): void;
        /**获得刚体质量*/
        getMass(): number;
        /**
         * 获得质心的相对节点0,0点的位置偏移
         */
        getCenter(): any;
        /**
         * 获得质心的世界坐标，相对于Physics2D.I.worldRoot节点
         */
        getWorldCenter(): any;
        /**
         * 刚体类型，支持三种类型static，dynamic和kinematic类型
         * static为静态类型，静止不动，不受重力影响，质量无限大，可以通过节点移动，旋转，缩放进行控制
         * dynamic为动态类型，接受重力影响
         * kinematic为运动类型，不受重力影响，可以通过施加速度或者力的方式使其运动
         */
        get type(): string;
        set type(value: string);
        /**重力缩放系数，设置为0为没有重力*/
        get gravityScale(): number;
        set gravityScale(value: number);
        /**是否允许旋转，如果不希望刚体旋转，这设置为false*/
        get allowRotation(): boolean;
        set allowRotation(value: boolean);
        /**是否允许休眠，允许休眠能提高性能*/
        get allowSleep(): boolean;
        set allowSleep(value: boolean);
        /**旋转速度阻尼系数，范围可以在0到无穷大之间，0表示没有阻尼，无穷大表示满阻尼，通常阻尼的值应该在0到0.1之间*/
        get angularDamping(): number;
        set angularDamping(value: number);
        /**角速度，设置会导致旋转*/
        get angularVelocity(): number;
        set angularVelocity(value: number);
        /**线性速度阻尼系数，范围可以在0到无穷大之间，0表示没有阻尼，无穷大表示满阻尼，通常阻尼的值应该在0到0.1之间*/
        get linearDamping(): number;
        set linearDamping(value: number);
        /**线性运动速度，比如{x:5,y:5}*/
        get linearVelocity(): IV2;
        set linearVelocity(value: any);
        /**是否高速移动的物体，设置为true，可以防止高速穿透*/
        get bullet(): boolean;
        set bullet(value: boolean);
        /**
         * 获得相对body的世界坐标
         * @param x (单位： 像素)
         * @param y (单位： 像素)
        */
        getWorldPoint(x: number, y: number): Point;
        /**
         * 获得相对body的本地坐标
         * @param x (单位： 像素)
         * @param y (单位： 像素)
        */
        getLocalPoint(x: number, y: number): Point;
    }
    class RigidBody2DInfo {
        position: Vector2;
        angle: number;
        allowSleep: boolean;
        angularDamping: number;
        angularVelocity: number;
        bullet: boolean;
        fixedRotation: boolean;
        gravityScale: number;
        linearDamping: number;
        linearVelocity: Vector2;
        type: string;
        group: number;
    }
    interface IPhyDebugDrawer {
        /**
         * 设置颜色
         * @param c
         */
        color(c: number): void;
        /**
         * 画线
         * @param sx
         * @param sy
         * @param sz
         * @param ex
         * @param ey
         * @param ez
         */
        line(sx: number, sy: number, sz: number, ex: number, ey: number, ez: number): void;
        /**
         * 清除画线结果
         */
        clear(): void;
    }
    class btPhysicsCreateUtil implements IPhysicsCreateUtil {
        protected _physicsEngineCapableMap: Map<any, any>;
        initPhysicsCapable(): void;
        getPhysicsCapable(value: EPhysicsCapable): boolean;
        initialize(): Promise<void>;
        createPhysicsManger(physicsSettings: PhysicsSettings): btPhysicsManager;
        createDynamicCollider(manager: btPhysicsManager): btRigidBodyCollider;
        createStaticCollider(manager: btPhysicsManager): btStaticCollider;
        createCharacterController(manager: btPhysicsManager): btCharacterCollider;
        createFixedJoint(manager: btPhysicsManager): btFixedJoint;
        createHingeJoint(manager: btPhysicsManager): IHingeJoint;
        createSpringJoint(manager: btPhysicsManager): btSpringJoint;
        createD6Joint(manager: btPhysicsManager): ID6Joint;
        createBoxColliderShape(): btBoxColliderShape;
        createSphereColliderShape(): btSphereColliderShape;
        createCapsuleColliderShape(): btCapsuleColliderShape;
        createMeshColliderShape(): btMeshColliderShape;
        createPlaneColliderShape(): IPlaneColliderShape;
        createCylinderColliderShape(): btCylinderColliderShape;
        createConeColliderShape(): btConeColliderShape;
        createCorveMesh(mesh: Mesh): Mesh;
    }
    class btPhysicsManager implements IPhysicsManager {
        /**默认碰撞组 */
        static COLLISIONFILTERGROUP_DEFAULTFILTER: number;
        /**静态碰撞组 */
        static COLLISIONFILTERGROUP_STATICFILTER: number;
        /**运动学刚体碰撞组 */
        static COLLISIONFILTERGROUP_KINEMATICFILTER: number;
        /**碎片碰撞组 */
        static COLLISIONFILTERGROUP_DEBRISFILTER: number;
        /**传感器触发器*/
        static COLLISIONFILTERGROUP_SENSORTRIGGER: number;
        /**字符过滤器 */
        static COLLISIONFILTERGROUP_CHARACTERFILTER: number;
        /**自定义过滤1 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER1: number;
        /**自定义过滤2 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER2: number;
        /**自定义过滤3 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER3: number;
        /**自定义过滤4 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER4: number;
        /**自定义过滤5 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER5: number;
        /**自定义过滤6 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER6: number;
        /**自定义过滤7 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER7: number;
        /**自定义过滤8 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER8: number;
        /**自定义过滤9 */
        static COLLISIONFILTERGROUP_CUSTOMFILTER9: number;
        /**自定义过滤10*/
        static COLLISIONFILTERGROUP_CUSTOMFILTER10: number;
        /**所有过滤 */
        static COLLISIONFILTERGROUP_ALLFILTER: number;
        static init(): void;
        /**物理引擎在一帧中用于补偿减速的最大次数：模拟器每帧允许的最大模拟次数，如果引擎运行缓慢,可能需要增加该次数，否则模拟器会丢失“时间",引擎间隔时间小于maxSubSteps*fixedTimeStep非常重要。*/
        maxSubSteps: number;
        /**物理模拟器帧的间隔时间:通过减少fixedTimeStep可增加模拟精度，默认是1.0 / 60.0。*/
        fixedTimeStep: number;
        /**是否开启连续碰撞检测 */
        enableCCD: boolean;
        /**连续碰撞检测阈值 */
        ccdThreshold: number;
        /**连续碰撞检测球半径 */
        ccdSphereRadius: number;
        /**delta */
        dt: number;
        protected _updateCount: number;
        _characters: btCharacterCollider[];
        protected _physicsEngineCapableMap: Map<any, any>;
        constructor(physicsSettings: PhysicsSettings);
        /**
         * 这个只是给对象发送事件，不会挨个组件调用碰撞函数
         * 组件要响应碰撞的话，要通过监听事件
         */
        dispatchCollideEvent(): void;
        /**
         * debugger Function
         * @param value
         */
        enableDebugDrawer(value: boolean): void;
        getPhysicsCapable(value: EPhysicsCapable): boolean;
        initPhysicsCapable(): void;
        /**
         * gravity
         * @param gravity
         */
        setGravity(gravity: Vector3): void;
        addCollider(collider: ICollider): void;
        removeCollider(collider: ICollider): void;
        addJoint(joint: btJoint): void;
        removeJoint(joint: btJoint): void;
        update(elapsedTime: number): void;
        rayCast(ray: Ray, outHitResult: HitResult, distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        rayCastAll(ray: Ray, out: HitResult[], distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        destroy(): void;
    }
    class btCharacterCollider extends btCollider implements ICharacterController {
        static __init__(): void;
        getCapable(value: number): boolean;
        constructor(physicsManager: btPhysicsManager);
        setShapelocalOffset(value: Vector3): void;
        setSkinWidth?(width: number): void;
        setPosition(value: Vector3): void;
        getPosition(): Vector3;
        setRadius?(value: number): void;
        setHeight?(value: number): void;
        setminDistance(value: number): void;
        setDynamicFriction?(value: number): void;
        setStaticFriction?(value: number): void;
        setFrictionCombine?(value: PhysicsCombineMode): void;
        setBounceCombine?(value: PhysicsCombineMode): void;
        static getCharacterCapable(value: ECharacterCapable): boolean;
        static initCapable(): void;
        protected getColliderType(): btColliderType;
        protected _initCollider(): void;
        protected _onShapeChange(): void;
        move(disp: Vector3): void;
        jump(velocity: Vector3): void;
        setJumpSpeed(value: number): void;
        setStepOffset(offset: number): void;
        setUpDirection(up: Vector3): void;
        getVerticalVel(): number;
        setSlopeLimit(slopeLimit: number): void;
        setfallSpeed(value: number): void;
        setPushForce(value: number): void;
        setGravity(value: Vector3): void;
        /**
         * 获得角色碰撞的对象
         * @param cb
         */
        getOverlappingObj(cb: (body: btCollider) => void): void;
        setColliderShape(shape: btColliderShape): void;
        destroy(): void;
    }
    enum btColliderType {
        RigidbodyCollider = 0,
        CharactorCollider = 1,
        StaticCollider = 2
    }
    class btCollider implements ICollider {
        component: PhysicsColliderComponent;
        static _colliderID: number;
        static _addUpdateList: boolean;
        static TYPE_STATIC: number;
        static TYPE_DYNAMIC: number;
        static TYPE_KINEMATIC: number;
        protected static _btVector30: number;
        _btCollider: any;
        _btColliderShape: btColliderShape;
        _collisionGroup: number;
        _canCollideWith: number;
        _physicsManager: btPhysicsManager;
        _isSimulate: boolean;
        _type: btColliderType;
        inPhysicUpdateListIndex: number;
        _id: number;
        /**触发器 */
        _isTrigger: boolean;
        _enableProcessCollisions: boolean;
        _destroyed: boolean;
        owner: Sprite3D;
        _transform: Transform3D;
        constructor(physicsManager: btPhysicsManager);
        getCapable(value: number): boolean;
        setOwner(node: Sprite3D): void;
        setCollisionGroup(value: number): void;
        setCanCollideWith(value: number): void;
        protected _initCollider(): void;
        protected getColliderType(): btColliderType;
        protected _onShapeChange(): void;
        setColliderShape(shape: btColliderShape): void;
        destroy(): void;
        transformChanged(flag: number): void;
        setBounciness(value: number): void;
        setfriction(value: number): void;
        setRollingFriction(value: number): void;
        setCcdMotionThreshold(value: number): void;
        setCcdSweptSphereRadius(value: number): void;
    }
    class btRigidBodyCollider extends btCollider implements IDynamicCollider {
        constructor(manager: btPhysicsManager);
        getCapable(value: number): boolean;
        static getRigidBodyCapable(value: EColliderCapable): boolean;
        static initCapable(): void;
        setWorldPosition(value: Vector3): void;
        setWorldRotation(value: Quaternion): void;
        sleep(): void;
        protected getColliderType(): btColliderType;
        /**
        * 是否重载重力。
        */
        private _setoverrideGravity;
        /**
         * 是否处于睡眠状态。
         */
        private isSleeping;
        protected _initCollider(): void;
        protected _onShapeChange(): void;
        setLinearDamping(value: number): void;
        setAngularDamping(value: number): void;
        setLinearVelocity(value: Vector3): void;
        getLinearVelocity(): Vector3;
        /**
         * 设置睡眠刚体线速度阈值
         * @param value
         */
        setSleepLinearVelocity(value: Vector3): void;
        setAngularVelocity(value: Vector3): void;
        getAngularVelocity(): Vector3;
        setMass(value: number): void;
        setInertiaTensor(value: Vector3): void;
        setCenterOfMass(value: Vector3): void;
        setMaxAngularVelocity(value: number): void;
        setMaxDepenetrationVelocity(value: number): void;
        setSleepThreshold(value: number): void;
        setSleepAngularVelocity(value: number): void;
        setSolverIterations(value: number): void;
        setCollisionDetectionMode(value: number): void;
        setIsKinematic(value: boolean): void;
        setConstraints(linearFactor: Vector3, angularFactor: Vector3): void;
        setTrigger(value: boolean): void;
        /**
         * 应用作用力。
         * @param	force 作用力。
         * @param	localOffset 偏移,如果为null则为中心点
         */
        private _applyForce;
        /**
       * 应用扭转力。
       * @param	torque 扭转力。
       */
        private _applyTorque;
        /**
         * 应用冲量。
         * @param	impulse 冲量。
         * @param   localOffset 偏移,如果为null则为中心点。
         */
        private _applyImpulse;
        /**
         * 应用扭转冲量。
         * @param	torqueImpulse
         */
        private _applyTorqueImpulse;
        addForce(force: Vector3, mode: PhysicsForceMode, localOffset: Vector3): void;
        addTorque(torque: Vector3, mode: PhysicsForceMode): void;
        /**
         * 清除应用到刚体上的所有力。
         */
        private clearForces;
        wakeUp(): void;
        setColliderShape(shape: btColliderShape): void;
        destroy(): void;
    }
    class btStaticCollider extends btCollider implements IStaticCollider {
        protected _initCollider(): void;
        setTrigger(value: boolean): void;
        protected getColliderType(): btColliderType;
        getCapable(value: number): boolean;
        constructor(physicsManager: btPhysicsManager);
        static getStaticColliderCapable(value: EColliderCapable): boolean;
        static initCapable(): void;
        setWorldPosition(value: Vector3): void;
    }
    /**
     * <code>CollisionMap</code> 类用于实现碰撞组合实例图。
     */
    class CollisionTool {
        /**
         * 创建一个 <code>CollisionMap</code> 实例。
         */
        constructor();
    }
    class btCustomJoint extends btJoint implements ID6Joint {
        initJoint(): void;
        protected _createJoint(): void;
        _initAllConstraintInfo(): void;
        constructor(manager: btPhysicsManager);
        setLocalPos(pos: Vector3): void;
        setConnectLocalPos(pos: Vector3): void;
        setAxis(axis: Vector3, secendary: Vector3): void;
        setMotion(axis: D6Axis, motionType: D6MotionType): void;
        setDistanceLimit(limit: number, bounceness: number, bounceThreshold: number, spring: number, damp: number): void;
        setLinearLimit(linearAxis: D6MotionType, upper: number, lower: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        setTwistLimit(upper: number, lower: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        setSwingLimit(yAngle: number, zAngle: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        setDrive(index: D6Drive, stiffness: number, damping: number, forceLimit: number): void;
        setDriveTransform(position: Vector3, rotate: Quaternion): void;
        setDriveVelocity(position: Vector3, angular: Vector3): void;
        getTwistAngle(): number;
        getSwingYAngle(): number;
        getSwingZAngle(): number;
    }
    class btFixedJoint extends btJoint implements IFixedJoint {
        constructor(manager: btPhysicsManager);
        protected _createJoint(): void;
    }
    class btHingeJoint extends btJoint implements IHingeJoint {
        protected _createJoint(): void;
        constructor(manager: btPhysicsManager);
        setLocalPos(pos: Vector3): void;
        setConnectLocalPos(pos: Vector3): void;
        setLowerLimit(lowerLimit: number): void;
        setUpLimit(value: number): void;
        setBounceness(value: number): void;
        setBouncenMinVelocity(value: number): void;
        setContactDistance(value: number): void;
        enableLimit(value: boolean): void;
        enableDrive(value: boolean): void;
        enableFreeSpin(value: boolean): void;
        setAxis(value: Vector3): void;
        setSwingOffset(value: Vector3): void;
        getAngle(): number;
        getVelocity(): Readonly<Vector3>;
        setHardLimit(lowerLimit: number, upperLimit: number, contactDist: number): void;
        setSoftLimit(lowerLimit: number, upperLimit: number, stiffness: number, damping: number): void;
        setDriveVelocity(velocity: number): void;
        setDriveForceLimit(limit: number): void;
        setDriveGearRatio(ratio: number): void;
        setHingeJointFlag(flag: number, value: boolean): void;
    }
    class btJoint implements IJoint {
        _manager: btPhysicsManager;
        /** 连接的两个物体是否进行碰撞检测 */
        _disableCollisionsBetweenLinkedBodies: boolean;
        static __init__(): void;
        static initJointCapable(): void;
        static getJointCapable(value: EJointCapable): boolean;
        constructor(manager: btPhysicsManager);
        protected _createJoint(): void;
        setCollider(collider: btCollider): void;
        setConnectedCollider(collider: btCollider): void;
        setLocalPos(pos: Vector3): void;
        setConnectLocalPos(pos: Vector3): void;
        getlinearForce(): Vector3;
        getAngularForce(): Vector3;
        isValid(): boolean;
        isEnable(value: boolean): void;
        isCollision(value: boolean): void;
        protected initJoint(): void;
        setOwner(owner: Sprite3D): void;
        _isBreakConstrained(): boolean;
        setConnectedMassScale(value: number): void;
        setConnectedInertiaScale(value: number): void;
        setMassScale(value: number): void;
        setInertiaScale(value: number): void;
        setBreakForce(value: number): void;
        setBreakTorque(value: number): void;
    }
    class btSpringJoint extends btJoint implements ISpringJoint {
        protected _createJoint(): void;
        constructor(manager: btPhysicsManager);
        setLocalPos(pos: Vector3): void;
        setConnectLocalPos(pos: Vector3): void;
        setSwingOffset(value: Vector3): void;
        setMinDistance(distance: number): void;
        setMaxDistance(distance: number): void;
        setTolerance(tolerance: number): void;
        setStiffness(stiffness: number): void;
        setDamping(damping: number): void;
    }
    class btBoxColliderShape extends btColliderShape implements IBoxColliderShape {
        /** @interanl */
        private _size;
        constructor();
        private changeBoxShape;
        protected _createShape(): void;
        protected _getType(): number;
        setSize(size: Vector3): void;
        destroy(): void;
    }
    class btCapsuleColliderShape extends btColliderShape implements ICapsuleColliderShape {
        private static _tempVector30;
        constructor();
        protected _createShape(): void;
        protected _getType(): number;
        setRadius(radius: number): void;
        setHeight(height: number): void;
        setUpAxis(upAxis: number): void;
        setWorldScale(scale: Vector3): void;
        destroy(): void;
    }
    class btColliderShape implements IColliderShape {
        /** 形状方向_X轴正向 */
        static SHAPEORIENTATION_UPX: number;
        /** 形状方向_Y轴正向 */
        static SHAPEORIENTATION_UPY: number;
        /** 形状方向_Z轴正向 */
        static SHAPEORIENTATION_UPZ: number;
        _type: number;
        _btShape: any;
        _btScale: any;
        _localOffset: Vector3;
        _worldScale: Vector3;
        _btCollider: btCollider;
        _destroyed: boolean;
        constructor();
        /**
         * @override
         */
        protected _createShape(): void;
        /**
         * @override
         */
        protected _getType(): number;
        setOffset(value: Vector3): void;
        setWorldScale(scale: Vector3): void;
        destroy(): void;
    }
    /**
     * <code>CompoundColliderShape</code> 类用于创建组合碰撞器。
     */
    class btCompoundColliderShape extends btColliderShape implements ICompoundColliderShape {
        /**
         * 创建一个新的 <code>CompoundColliderShape</code> 实例。
         */
        constructor();
        /**
         * 设置物理shape数组
         * IDE
         */
        set shapes(value: any[]);
        get shapes(): any[];
        /**
         * 添加子碰撞器形状。
         * @param	shape 子碰撞器形状。
         */
        addChildShape(shape: any): void;
        /**
         * 移除子碰撞器形状。
         * @param	shape 子碰撞器形状。
         */
        removeChildShape(shape: any): void;
        /**
         * 清空子碰撞器形状。
         */
        clearChildShape(): void;
        /**
         * 获取子形状数量。
         * @return
         */
        getChildShapeCount(): number;
        /**
         * @inheritDoc
         * @override
         */
        cloneTo(destObject: any): void;
        /**
         * @inheritDoc
         * @override
         */
        clone(): any;
        /**
         * @inheritDoc
         * @override
         */
        destroy(): void;
    }
    class btConeColliderShape extends btColliderShape implements IConeColliderShape {
        private static _tempVector30;
        constructor();
        protected _createShape(): void;
        protected _getType(): number;
        setRadius(radius: number): void;
        setHeight(height: number): void;
        setUpAxis(upAxis: number): void;
        destroy(): void;
    }
    class btCylinderColliderShape extends btColliderShape implements ICylinderColliderShape {
        private static _tempVector30;
        private _btSize;
        constructor();
        protected _createShape(): void;
        protected _getType(): number;
        setRadius(radius: number): void;
        setHeight(height: number): void;
        setUpAxis(upAxis: number): void;
        destroy(): void;
    }
    class btMeshColliderShape extends btColliderShape implements IMeshColliderShape {
        private _limitvertex;
        private _convex;
        /**
         * 网格
        */
        get mesh(): Mesh;
        set mesh(value: Mesh);
        static __init__(): void;
        constructor();
        setPhysicsMeshFromMesh(value: Mesh): void;
        setConvexMesh(value: Mesh): void;
        setLimitVertex(limit: number): void;
        private _createPhysicsMeshFromMesh;
        private _createConvexMeshFromMesh;
        protected _createTrianggleMeshGeometry(): void;
        protected _createConvexMeshGeometry(): void;
        setWorldScale(value: Vector3): void;
    }
    class btSphereColliderShape extends btColliderShape implements ISphereColliderShape {
        constructor();
        protected _getType(): number;
        protected _createShape(): void;
        setRadius(radius: number): void;
        destroy(): void;
    }
    /**
     * Base class for character controllers.
     */
    interface ICharacterController extends ICollider {
        /**
         * Moves the character using a "collide-and-slide" algorithm.
         * @param disp Displacement vector
         */
        move(disp: Vector3): void;
        /**
         * jump
         * @param velocity
         */
        jump?(velocity: Vector3): void;
        /**
         * set position of characterController
         * @param v
         */
        setPosition(value: Vector3): void;
        /**
         * get current position of characterController
         */
        getPosition?(): Vector3;
        /**
         * The step height.
         * @param offset The new step offset for the controller.
         */
        setStepOffset?(offset: number): void;
        /**
         * set skin offset
         * @param width
         */
        setSkinWidth?(width: number): void;
        /**
         * Sets the 'up' direction.
         * @param up The up direction for the controller.
         */
        setUpDirection?(up: Vector3): void;
        /**
         * get VerticalVel
         */
        getVerticalVel?(): number;
        /**
         * Sets the slope limit.
         * @param slopeLimit The slope limit for the controller.
         */
        setSlopeLimit?(slopeLimit: number): void;
        /**
         * 设置重力
         * @param value
         */
        setGravity?(value: Vector3): void;
        /**
         * 设置角色的半径
         * @param value
         */
        setRadius?(value: number): void;
        /**
         * 设置角色的高度
         * @param value
         */
        setHeight?(value: number): void;
        setminDistance(value: number): void;
        setShapelocalOffset(value: Vector3): void;
        /**
         * 设置推开的力
         */
        setPushForce?(value: number): void;
        /**
         * 设置起跳速度
         * @param value
         */
        setJumpSpeed?(value: number): void;
    }
    interface ICollider {
        owner: Node;
        inPhysicUpdateListIndex: number;
        component: PhysicsColliderComponent;
        /**
         * get capable
         * @param value
         */
        getCapable(value: number): boolean;
        setColliderShape(shape: IColliderShape): void;
        /**
         * Deletes the collider.
         */
        destroy(): void;
        /**
         * set collision Group
         * @param value
         */
        setCollisionGroup(value: number): void;
        /**
         * set can collision Group
         * @param value
         */
        setCanCollideWith(value: number): void;
        /**
         * set node
         */
        setOwner(node: Node): void;
        /**
         * transform Change
         */
        transformChanged(flag: number): void;
        setBounciness?(value: number): void;
        setfriction?(value: number): void;
        setRollingFriction?(value: number): void;
        setDynamicFriction?(value: number): void;
        setStaticFriction?(value: number): void;
        setFrictionCombine?(value: PhysicsCombineMode): void;
        setBounceCombine?(value: PhysicsCombineMode): void;
        setEventFilter?(events: string[]): void;
    }
    /**
     * Interface of physics dynamic collider.
     */
    interface IDynamicCollider extends ICollider {
        /**
         * Sets the linear damping coefficient.
         * @param value - Linear damping coefficient.
         */
        setLinearDamping(value: number): void;
        /**
         * Sets the angular damping coefficient.
         * @param value - Angular damping coefficient.
         */
        setAngularDamping(value: number): void;
        /**
         * Sets the linear velocity of the actor.
         * @param value - New linear velocity of actor.
         */
        setLinearVelocity(value: Vector3): void;
        /**
         * get the linear velocity of the actor.
         */
        getLinearVelocity(): Vector3;
        /**
         * Sets the angular velocity of the actor.
         * @param value - New angular velocity of actor.
         */
        setAngularVelocity(value: Vector3): void;
        /**
         * get the angular velocity of the actor.
         */
        getAngularVelocity(): Vector3;
        /**
         *  Sets the mass of a dynamic actor.
         * @param value - New mass value for the actor.
         */
        setMass(value: number): void;
        /**
         * Sets the pose of the center of mass relative to the actor.
         * @param value - Mass frame offset transform relative to the actor frame.
         */
        setCenterOfMass(value: Vector3): void;
        /**
         * Sets the inertia tensor, using a parameter specified in mass space coordinates.
         * @param value - New mass space inertia tensor for the actor.
         */
        setInertiaTensor(value: Vector3): void;
        /**
         * Sets the mass-normalized kinetic energy threshold below which an actor may go to sleep.
         * @param value - Energy below which an actor may go to sleep.
         */
        setSleepThreshold(value: number): void;
        /**
         * Sets the colliders' collision detection mode.
         * @param value - rigid body flag
         */
        setCollisionDetectionMode(value: number): void;
        /**
         * Controls whether physics affects the dynamic collider.
         * @param value - is or not
         */
        setIsKinematic(value: boolean): void;
        /**
         * Raises or clears a particular rigid dynamic lock flag.
         * @param flags - the flag to raise(set) or clear.
         */
        setConstraints(linearFactor: Vector3, angularFactor: Vector3): void;
        /**
         * Apply a force to the dynamic collider.
         * @param force - The force make the collider move
         */
        addForce(force: Vector3, mode: PhysicsForceMode, localOffset: Vector3): void;
        /**
         * Apply a torque to the dynamic collider.
         * @param torque - The force make the collider rotate
         */
        addTorque(torque: Vector3, mode: PhysicsForceMode): void;
        /**
         * Forces a collider to sleep at least one frame.
         */
        sleep?(): void;
        /**
         * Forces a collider to wake up.
         */
        wakeUp(): void;
        /**
         * set world position
         * @param value
         */
        setWorldPosition(value: Vector3): void;
        /**
         * set world rotation
         * @param value
         */
        setWorldRotation(value: Quaternion): void;
        /**
         * set trigger
         * @param value
         */
        setTrigger(value: boolean): void;
    }
    interface IPhysicsCreateUtil {
        /**
         * 初始化物理
         */
        initialize(): Promise<void>;
        /**
         * set PhysicsEngine Capable
         */
        initPhysicsCapable(): void;
        /**
         * get PhysicsEngine Capable
         * @param value
         */
        getPhysicsCapable(value: EPhysicsCapable): boolean;
        /**
         * 创建物理管理类
         */
        createPhysicsManger(physicsSettings: PhysicsSettings): IPhysicsManager;
        /**
         * 创建动态碰撞体
         */
        createDynamicCollider(manager: IPhysicsManager): IDynamicCollider;
        /**
         * 创建静态碰撞体
         */
        createStaticCollider(manager: IPhysicsManager): IStaticCollider;
        /**
         * 创建角色碰撞器
         */
        createCharacterController(manager: IPhysicsManager): ICharacterController;
        /**
         * Create fixed joint.
         * @param collider - Affector of joint
         */
        createFixedJoint(manager: IPhysicsManager): IFixedJoint;
        /**
         * Create hinge joint.
         * @param collider - Affector of joint
         */
        createHingeJoint(manager: IPhysicsManager): IHingeJoint;
        /**
         * Create spring joint
         * @param collider - Affector of joint
         */
        createSpringJoint(manager: IPhysicsManager): ISpringJoint;
        /**
         * Create Custom Joint
         */
        createD6Joint(manager: IPhysicsManager): ID6Joint;
        /**
         * Create box collider shape.
         * @param uniqueID - Shape unique id
         * @param size - Size of the box
         * @param material - The material of this shape
         */
        createBoxColliderShape(): IBoxColliderShape;
        /**
         * Create sphere collider shape.
         * @param uniqueID - Shape unique id
         * @param radius - Radius of the sphere
         * @param material - The material of this shape
         */
        createSphereColliderShape(): ISphereColliderShape;
        /**
         * Create plane collider shape.
         * @param uniqueID - Shape unique id
         * @param material - The material of this shape
         */
        createPlaneColliderShape(): IPlaneColliderShape;
        /**
         * Create capsule collider shape.
         * @param uniqueID - Shape unique id
         * @param radius - Radius of capsule
         * @param height - Height of capsule
         * @param material - The material of this shape
         */
        createCapsuleColliderShape?(): ICapsuleColliderShape;
        /**
         * create Mesh Collider shape
         */
        createMeshColliderShape?(): IMeshColliderShape;
        /**
         * create Cylinder Collider Shape
         */
        createCylinderColliderShape?(): ICylinderColliderShape;
        /**
         * create Cone Collider Shape
         */
        createConeColliderShape?(): IConeColliderShape;
        /**
         * create Height Field Collider
         */
        createHeightFieldShape?(): IHeightFieldShape;
        /**
         * create Corve Mesh
         */
        createCorveMesh?(mesh: Mesh): Mesh;
    }
    interface IPhysicsManager {
        /**
        * Set gravity.
        * @param gravity - Physics gravity
        */
        setGravity(gravity: Vector3): void;
        /**
         * Add ICollider into the manager.
         * @param collider - StaticCollider or DynamicCollider.
         */
        addCollider(collider: ICollider): void;
        /**
         * Remove ICollider.
         * @param collider - StaticCollider or DynamicCollider.
         */
        removeCollider(collider: ICollider): void;
        /**
         * Call on every frame to update pose of objects.
         * @param elapsedTime - Step time of update.
         */
        update(elapsedTime: number): void;
        /**
         * ray cast first one collision
         * @param ray
         * @param outHitResult
         * @param distance
         * @param collisonGroup
         * @param collisionMask
         */
        rayCast?(ray: Ray, outHitResult: HitResult, distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        /**
         * ray cast all collision
         * @param ray
         * @param out
         * @param distance
         * @param collisonGroup
         * @param collisionMask
         */
        rayCastAll?(ray: Ray, out: HitResult[], distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        /**
         * debugger
         * @param value
         */
        enableDebugDrawer?(value: boolean): void;
        /**
         * Query
         * @param pos
         * @param radius
         * @param result
         * @param collisionmask
         */
        sphereQuery?(pos: Vector3, radius: number, result: ICollider[], collisionmask: number): void;
        /**
         * destroy
         */
        destroy(): void;
    }
    interface IPhysicsMaterial {
        /**
         * 设置弹力
         * @param value - The bounciness
         */
        setBounciness(value: number): void;
        /**
         * 设置动态摩擦力
         * @param value - The dynamic friction
         */
        setDynamicFriction(value: number): void;
        /**
         * 设置静态摩擦力
         * @param value - The static friction
         */
        setStaticFriction(value: number): void;
        /**
         * 设置弹性组合模式
         * @param value - The combine mode
         */
        setBounceCombine(value: number): void;
        /**
         * 设置摩擦组合模式
         * @param value - The combine mode
         */
        setFrictionCombine(value: number): void;
        /**
         * Decrements the reference count of a material and releases it if the new reference count is zero.
         */
        destroy(): void;
    }
    interface IStaticCollider extends ICollider {
        /**
         * set trigger
         * @param value
         */
        setTrigger(value: boolean): void;
    }
    interface ICustomJoint extends IJoint {
    }
    enum D6MotionType {
        eX = 0,
        eY = 1,
        eZ = 2,
        eTWIST = 3,
        eSWING1 = 4,
        eSWING2 = 5
    }
    enum D6Axis {
        eLOCKED = 0,
        eLIMITED = 1,
        eFREE = 2
    }
    enum D6Drive {
        eX = 0,
        eY = 1,
        eZ = 2,
        eSWING = 3,
        eTWIST = 4,
        eSLERP = 5
    }
    interface ID6Joint extends IJoint {
        setAxis(axis: Vector3, secendary: Vector3): void;
        setMotion(axis: D6Axis, motionType: D6MotionType): void;
        setDistanceLimit(limit: number, bounceness: number, bounceThreshold: number, spring: number, damp: number): void;
        setLinearLimit(linearAxis: D6MotionType, upper: number, lower: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        setTwistLimit(upper: number, lower: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        setSwingLimit(yAngle: number, zAngle: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        setDrive(index: D6Drive, stiffness: number, damping: number, forceLimit: number): void;
        setDriveTransform(position: Vector3, rotate: Quaternion): void;
        setDriveVelocity(position: Vector3, angular: Vector3): void;
        getTwistAngle(): number;
        getSwingYAngle(): number;
        getSwingZAngle(): number;
    }
    interface IFixedJoint extends IJoint {
    }
    interface IHingeJoint extends IJoint {
        /**
         * The anchor rotation.
         */
        setAxis(value: Vector3): void;
        /**
         * The current angle in degrees of the joint relative to its rest position.
         */
        getAngle(): number;
        /**
         * The angular velocity of the joint in degrees per second.
         */
        getVelocity(): Readonly<Vector3>;
        /**
         * set limitLower
         * @param lowerLimit
         */
        setLowerLimit(lowerLimit: number): void;
        /**
         * @param value
         */
        setUpLimit(value: number): void;
        /**
         * @param value
         */
        setBounceness(value: number): void;
        /**
         * @param value
         */
        setBouncenMinVelocity(value: number): void;
        /**
         * @param value
         */
        setContactDistance(value: number): void;
        /**
         * @param value
         */
        enableLimit(value: boolean): void;
        /**
         * @param value
         */
        enableDrive(value: boolean): void;
        /**
         * @param value
         */
        enableFreeSpin(value: boolean): void;
        /**
         * set the target velocity for the drive model.
         * @param velocity the drive target velocity
         */
        setDriveVelocity(velocity: number): void;
        /**
         * sets the maximum torque the drive can exert.
         * @param limit the maximum torque
         */
        setDriveForceLimit(limit: number): void;
    }
    interface IJoint {
        /**
         * set owner
         * @param value
         */
        setOwner(value: Node): void;
        /**
         * the Collider
         * @param owner
         */
        setCollider(owner: ICollider): void;
        /**
         * The connected collider.
         */
        setConnectedCollider(owner: ICollider): void;
        /**
         *  The scale to apply to the inverse mass of collider 0 for resolving this constraint.
         */
        setConnectedMassScale(value: number): void;
        /**
         * The scale to apply to the inverse inertia of collider0 for resolving this constraint.
         */
        setConnectedInertiaScale(value: number): void;
        /**
         * The scale to apply to the inverse mass of collider 1 for resolving this constraint.
         */
        setMassScale(value: number): void;
        /**
         * The scale to apply to the inverse inertia of collider1 for resolving this constraint.
         */
        setInertiaScale(value: number): void;
        /**
         * The maximum force the joint can apply before breaking.
         */
        setBreakForce(value: number): void;
        /**
         * The maximum torque the joint can apply before breaking.
         */
        setBreakTorque(value: number): void;
        /**
         * set Actor0 local anchor/Frame Pos
         * @param pos
         */
        setLocalPos(pos: Vector3): void;
        /**
         * set Actor1 local anchor/Frame Pos
         * @param pos
         */
        setConnectLocalPos(pos: Vector3): void;
        /**
         * get linear force
         */
        getlinearForce(): Vector3;
        /**
         * get angular force
         */
        getAngularForce(): Vector3;
        /**
         * is breaked
         */
        isValid(): boolean;
        isEnable(value: boolean): void;
        isCollision(value: boolean): void;
    }
    interface ISpringJoint extends IJoint {
        /**
         * Set the allowed minimum distance for the joint.
         * @param distance the minimum distance
         */
        setMinDistance(distance: number): void;
        /**
         * Set the allowed maximum distance for the joint.
         * @param distance the maximum distance
         */
        setMaxDistance(distance: number): void;
        /**
         * Set the error tolerance of the joint.
         * @param tolerance the distance beyond the allowed range at which the joint becomes active
         */
        setTolerance(tolerance: number): void;
        /**
         * Set the strength of the joint spring.
         * @param stiffness the spring strength of the joint
         */
        setStiffness(stiffness: number): void;
        /**
         * Set the damping of the joint spring.
         * @param damping the degree of damping of the joint spring of the joint
         */
        setDamping(damping: number): void;
    }
    interface IBoxColliderShape extends IColliderShape {
        /**
          * Set size of Box Shape.
          * @param size - The size
          */
        setSize(size: Vector3): void;
    }
    interface ICapsuleColliderShape extends IColliderShape {
        /**
         * Set radius of capsule.
         * @param radius - The radius
         */
        setRadius(radius: number): void;
        /**
         * Set height of capsule.
         * @param height - The height
         */
        setHeight(height: number): void;
        /**
         * Set up axis of capsule.
         * @param upAxis - The up axis
         */
        setUpAxis(upAxis: number): void;
    }
    interface IColliderShape {
        /**
         * Set local position.
         * @param position - The local position
         */
        setOffset(position: Vector3): void;
        /**
         * Decrements the reference count of a shape and releases it if the new reference count is zero.
         */
        destroy(): void;
    }
    interface ICompoundColliderShape {
    }
    interface IConeColliderShape extends IColliderShape {
        /**
        * Set radius of capsule.
        * @param radius - The radius
        */
        setRadius(radius: number): void;
        /**
         * Set height of capsule.
         * @param height - The height
         */
        setHeight(height: number): void;
        /**
         * Set up axis of capsule.
         * @param upAxis - The up axis
         */
        setUpAxis(upAxis: number): void;
    }
    interface ICylinderColliderShape extends IColliderShape {
        /**
        * Set radius of capsule.
        * @param radius - The radius
        */
        setRadius(radius: number): void;
        /**
         * Set height of capsule.
         * @param height - The height
         */
        setHeight(height: number): void;
        /**
         * Set up axis of capsule.
         * @param upAxis - The up axis
         */
        setUpAxis(upAxis: number): void;
    }
    interface IHeightFieldShape extends IColliderShape {
        /**
         * 设置高度数据
         * @param numRows
         * @param numCols
         * @param heightData
         * @param _scale
         */
        setHeightFieldData(numRows: number, numCols: number, heightData: Float32Array, flag: Uint8Array, scale: Vector3): void;
        /**
         * NBRows
         */
        getNbRows(): number;
        /**
         * NBColumns
         */
        getNbColumns(): number;
        /**
         * height
         * @param rows
         * @param cols
         */
        getHeight(rows: number, cols: number): number;
    }
    interface IMeshColliderShape extends IColliderShape {
        /**
         * create physicsMesh from Mesh
         * @param value
         */
        setPhysicsMeshFromMesh(value: Mesh): void;
        /**
         *
         * @param value
         */
        setConvexMesh(value: Mesh): void;
        /**
         * create limit Vertex
         * @param limit
         */
        setLimitVertex(limit: number): void;
    }
    interface IPlaneColliderShape extends IColliderShape {
    }
    interface ISphereColliderShape extends IColliderShape {
        /**
         * Set radius of sphere.
         * @param radius - The radius
         */
        setRadius(radius: number): void;
    }
    enum ECharacterCapable {
        Charcater_Gravity = 0,
        Charcater_CollisionGroup = 1,
        Charcater_WorldPosition = 2,
        Charcater_Move = 3,
        Charcater_Jump = 4,
        Charcater_StepOffset = 5,
        Character_UpDirection = 6,
        Character_FallSpeed = 7,
        Character_SlopeLimit = 8,
        Character_PushForce = 9,
        Character_Radius = 10,
        Character_Height = 11,
        Character_offset = 12,
        Character_Skin = 13,
        Character_minDistance = 14,
        Character_EventFilter = 15,
        Character_SimulateGravity = 16
    }
    enum EColliderCapable {
        Collider_CollisionGroup = 0,
        Collider_Friction = 1,
        Collider_RollingFriction = 2,
        Collider_Restitution = 3,
        Collider_AllowTrigger = 4,
        Collider_DynamicFriction = 5,
        Collider_StaticFriction = 6,
        Collider_BounceCombine = 7,
        Collider_FrictionCombine = 8,
        Collider_EventFilter = 9,
        Collider_CollisionDetectionMode = 10,
        RigidBody_CanKinematic = 11,
        RigidBody_AllowSleep = 12,
        RigidBody_Gravity = 13,
        RigidBody_LinearDamp = 14,
        RigidBody_AngularDamp = 15,
        RigidBody_LinearVelocity = 16,
        RigidBody_AngularVelocity = 17,
        RigidBody_Mass = 18,
        RigidBody_WorldPosition = 19,
        RigidBody_WorldOrientation = 20,
        RigidBody_InertiaTensor = 21,
        RigidBody_MassCenter = 22,
        RigidBody_MaxAngularVelocity = 23,
        RigidBody_MaxDepenetrationVelocity = 24,
        RigidBody_SleepThreshold = 25,
        RigidBody_SleepAngularVelocity = 26,
        RigidBody_SolverIterations = 27,
        RigidBody_AllowDetectionMode = 28,
        RigidBody_AllowKinematic = 29,
        RigidBody_AllowCharacter = 30,
        RigidBody_LinearFactor = 31,
        RigidBody_AngularFactor = 32,
        RigidBody_ApplyForce = 33,
        RigidBody_ClearForce = 34,
        RigidBody_ApplyForceWithOffset = 35,
        RigidBody_ApplyTorque = 36,
        RigidBody_ApplyImpulse = 37,
        RigidBody_ApplyTorqueImpulse = 38
    }
    enum EJointCapable {
        Joint_Anchor = 0,
        Joint_ConnectAnchor = 1
    }
    enum EPhysicsCapable {
        Physics_Gravity = 0,
        Physics_StaticCollider = 1,
        Physics_DynamicCollider = 2,
        Physics_CharacterCollider = 3,
        Physics_BoxColliderShape = 4,
        Physics_SphereColliderShape = 5,
        Physics_CapsuleColliderShape = 6,
        Physics_CylinderColliderShape = 7,
        Physics_ConeColliderShape = 8,
        Physics_MeshColliderShape = 9,
        Physics_CompoundColliderShape = 10,
        Physics_CreateCorveMesh = 11,
        physics_heightFieldColliderShape = 12,
        Physics_Joint = 13,
        Physics_FixedJoint = 14,
        Physics_SpringJoint = 15,
        Physics_HingeJoint = 16,
        Physics_D6Joint = 17
    }
    enum ControllerNonWalkableMode {
        ePREVENT_CLIMBING = 0,
        ePREVENT_CLIMBING_AND_FORCE_SLIDING = 1
    }
    enum ECharacterCollisionFlag {
        eCOLLISION_SIDES = 1,
        eCOLLISION_UP = 2,
        eCOLLISION_DOWN = 4
    }
    class pxCharactorCollider extends pxCollider implements ICharacterController {
        static tempV3: Vector3;
        _shapeID: number;
        private _nonWalkableMode;
        private _gravity;
        private _characterCollisionFlags;
        constructor(manager: pxPhysicsManager);
        private _getNodeScale;
        protected _initCollider(): void;
        getCapable(value: number): boolean;
        static getCharacterCapable(value: ECharacterCapable): boolean;
        static initCapable(): void;
        /**
         * create from physics Engine
         */
        _createController(): void;
        /**
         * 设置角色控制器的碰撞类型
         * @param value
         */
        _setCharacterCollisonFlag(value: ECharacterCollisionFlag): void;
        /**
         * remove from physics Engine
         */
        _releaseController(): void;
        move(disp: Vector3): void;
        jump?(velocity: Vector3): void;
        setStepOffset(offset: number): void;
        setUpDirection(up: Vector3): void;
        setSlopeLimit(value: number): void;
        setGravity(value: Vector3): void;
        setPushForce(value: number): void;
        getWorldTransform(): void;
        setSkinWidth(width: number): void;
        destroy(): void;
        setPosition(value: Vector3): void;
        getPosition(): Vector3;
        setShapelocalOffset(value: Vector3): void;
        setHeight(value: number): void;
        setRadius(value: number): void;
        setminDistance(value: number): void;
        setNonWalkableMode(value: ControllerNonWalkableMode): void;
        setEventFilter(events: [
        ]): void;
        release(): void;
    }
    /**
     * collider type
     */
    enum pxColliderType {
        RigidbodyCollider = 0,
        CharactorCollider = 1,
        StaticCollider = 2
    }
    /**
     *physX actor flag
     */
    enum pxActorFlag {
        eVISUALIZATION = 1,
        eDISABLE_GRAVITY = 2,
        eSEND_SLEEP_NOTIFIES = 4,
        eDISABLE_SIMULATION = 8
    }
    class pxCollider implements ICollider {
        /**temp tranform object */
        private static _tempTransform;
        owner: Sprite3D;
        component: PhysicsColliderComponent;
        /**actor */
        _pxActor: any;
        /**owner transform */
        _transform: Transform3D;
        /**type data */
        _type: pxColliderType;
        /**触发器 */
        _isTrigger: boolean;
        /**can collision Group*/
        _canCollisionWith: number;
        /**collision group */
        _collisionGroup: number;
        /**pxshape */
        _shape: pxColliderShape;
        /**manager */
        _physicsManager: pxPhysicsManager;
        /**check destroy */
        _destroyed: boolean;
        inPhysicUpdateListIndex: number;
        /**id */
        _id: number;
        private _bounciness;
        constructor(manager: pxPhysicsManager);
        protected setActorFlag(flag: pxActorFlag, value: boolean): void;
        getCapable(value: number): boolean;
        setColliderShape(shape: pxColliderShape): void;
        protected _initColliderShapeByCollider(): void;
        destroy(): void;
        setCollisionGroup(value: number): void;
        setCanCollideWith(value: number): void;
        setEventFilter(events: [
        ]): void;
        setOwner(node: Sprite3D): void;
        protected _initCollider(): void;
        transformChanged(flag: number): void;
        /**
         * {@inheritDoc ICollider.setWorldTransform }
         */
        setWorldTransform(focus: boolean): void;
        setBounciness(value: number): void;
        setDynamicFriction(value: number): void;
        setStaticFriction(value: number): void;
        setFrictionCombine(value: PhysicsCombineMode): void;
        setBounceCombine(value: PhysicsCombineMode): void;
    }
    /**
     * The collision detection mode constants.
     */
    enum CollisionDetectionMode {
        /** Continuous collision detection is off for this dynamic collider. */
        Discrete = 0,
        /** Continuous collision detection is on for colliding with static mesh geometry. */
        Continuous = 1,
        /** Continuous collision detection is on for colliding with static and dynamic geometry. */
        ContinuousDynamic = 2,
        /** Speculative continuous collision detection is on for static and dynamic geometries */
        ContinuousSpeculative = 3
    }
    /**
     * Use these flags to constrain motion of dynamic collider.
     */
    enum DynamicColliderConstraints {
        /** Not Freeze. */
        None = 0,
        /** Freeze motion along the X-axis. */
        FreezePositionX = 1,
        /** Freeze motion along the Y-axis. */
        FreezePositionY = 2,
        /** Freeze motion along the Z-axis. */
        FreezePositionZ = 4,
        /** Freeze rotation along the X-axis. */
        FreezeRotationX = 8,
        /** Freeze rotation along the Y-axis. */
        FreezeRotationY = 16,
        /** Freeze rotation along the Z-axis. */
        FreezeRotationZ = 32
    }
    class pxDynamicCollider extends pxCollider implements IDynamicCollider {
        static getStaticColliderCapable(value: EColliderCapable): boolean;
        static initCapable(): void;
        static _tempTranslation: Vector3;
        private static _tempRotation;
        IsKinematic: boolean;
        constructor(manager: pxPhysicsManager);
        getCapable(value: number): boolean;
        protected _initCollider(): void;
        protected _initColliderShapeByCollider(): void;
        setWorldPosition(value: Vector3): void;
        setWorldRotation(value: Quaternion): void;
        getWorldTransform(): void;
        setTrigger(value: boolean): void;
        setLinearDamping(value: number): void;
        setAngularDamping(value: number): void;
        setLinearVelocity(value: Vector3): void;
        getLinearVelocity(): Vector3;
        setAngularVelocity(value: Vector3): void;
        getAngularVelocity(): Vector3;
        setMass(value: number): void;
        setCenterOfMass(value: Vector3): void;
        setInertiaTensor(value: Vector3): void;
        setSleepThreshold(value: number): void;
        setCollisionDetectionMode(value: number): void;
        setSolverIterations(value: number): void;
        setIsKinematic(value: boolean): void;
        setConstraints(linearFactor: Vector3, angularFactor: Vector3): void;
        addForce(force: Vector3, mode: PhysicsForceMode, localOffset: Vector3): void;
        addTorque(torque: Vector3, mode: PhysicsForceMode): void;
        sleep(): void;
        wakeUp(): void;
        /**
         * {@inheritDoc IDynamicCollider.move }
         */
        move(positionOrRotation: Vector3 | Quaternion, rotation?: Quaternion): void;
    }
    class pxStaticCollider extends pxCollider implements IStaticCollider {
        static getStaticColliderCapable(value: EColliderCapable): boolean;
        static initCapable(): void;
        constructor(manager: pxPhysicsManager);
        getCapable(value: number): boolean;
        protected _initCollider(): void;
        setTrigger(value: boolean): void;
        protected _initColliderShapeByCollider(): void;
    }
    enum PxD6JointDriveFlag {
        eACCELERATION = 1
    }
    class pxD6Joint extends pxJoint implements ID6Joint {
        /**
         * create Joint
         */
        protected _createJoint(): void;
        /**
         * set local Pose
         * @param actor
         * @param position
         */
        protected _setLocalPose(actor: number, position: Vector3): void;
        /**
         * set Joint axis and secendary Axis
         * @param axis
         * @param secendary
         */
        setAxis(axis: Vector3, secendary: Vector3): void;
        /**
         * set Motion Type
         * @param axis
         * @param motionType
         */
        setMotion(axis: D6Axis, motionType: D6MotionType): void;
        /**
         * set Distance Limit
         * @param limit
         * @param bounceness
         * @param bounceThreshold
         * @param spring
         * @param damp
         */
        setDistanceLimit(limit: number, bounceness: number, bounceThreshold: number, spring: number, damp: number): void;
        /**
         *
         * @param linearAxis
         * @param upper
         * @param lower
         * @param bounceness
         * @param bounceThreshold
         * @param spring
         * @param damping
         */
        setLinearLimit(linearAxis: D6MotionType, upper: number, lower: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         *
         * @param upper
         * @param lower
         * @param bounceness
         * @param bounceThreshold
         * @param spring
         * @param damping
         */
        setTwistLimit(upper: number, lower: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         *
         * @param yAngle
         * @param zAngle
         * @param bounceness
         * @param bounceThreshold
         * @param spring
         * @param damping
         */
        setSwingLimit(yAngle: number, zAngle: number, bounceness: number, bounceThreshold: number, spring: number, damping: number): void;
        /**
         *
         * @param index
         * @param stiffness
         * @param damping
         * @param forceLimit
         */
        setDrive(index: D6Drive, stiffness: number, damping: number, forceLimit: number): void;
        /**
         *
         * @param position
         * @param rotate
         */
        setDriveTransform(position: Vector3, rotate: Quaternion): void;
        /**
         *
         * @param position
         * @param angular
         */
        setDriveVelocity(position: Vector3, angular: Vector3): void;
        /**
         *
         * @returns
         */
        getTwistAngle(): number;
        /**
         *
         * @returns
         */
        getSwingYAngle(): number;
        /**
         *
         * @returns
         */
        getSwingZAngle(): number;
    }
    class pxDistanceJoint extends pxJoint implements ISpringJoint {
        /**
         * create Joint
         */
        protected _createJoint(): void;
        /**
         * min distance
         * @param distance
         */
        setMinDistance(distance: number): void;
        /**
         * max distance
         * @param distance
         */
        setMaxDistance(distance: number): void;
        /**
         * set connect Distance
         * @param distance
         */
        setConnectDistance(distance: number): void;
        /**
         * 允许弹簧具有不同的静止长度。
         * @param tolerance
         */
        setTolerance(tolerance: number): void;
        /**
         * 弹力
         * @param stiffness
         */
        setStiffness(stiffness: number): void;
        /**
         * 弹簧阻尼
         * @param damping
         */
        setDamping(damping: number): void;
    }
    class pxFixedJoint extends pxJoint implements IFixedJoint {
        /**
         * create Joint
         */
        protected _createJoint(): void;
    }
    /**
     * joint flag
     */
    enum PxConstraintFlag {
        eBROKEN = 1,
        ePROJECT_TO_ACTOR0 = 2,
        ePROJECT_TO_ACTOR1 = 4,
        ePROJECTION = 6,
        eCOLLISION_ENABLED = 8,
        eVISUALIZATION = 16,
        eDRIVE_LIMITS_ARE_FORCES = 32,
        eIMPROVED_SLERP = 128,
        eDISABLE_PREPROCESSING = 256,
        eENABLE_EXTENDED_LIMITS = 512,
        eGPU_COMPATIBLE = 1024,
        eALWAYS_UPDATE = 2048,
        eDISABLE_CONSTRAINT = 4096
    }
    class pxJoint implements IJoint {
        /**@interanl */
        static _tempTransform0: {
            translation: Vector3;
            rotation: Quaternion;
        };
        /**
         * @param manager
         */
        constructor(manager: pxPhysicsManager);
        isEnable(value: boolean): void;
        isCollision(value: boolean): void;
        isPreprocessiong(value: boolean): void;
        setOwner(value: Sprite3D): void;
        setCollider(owner: pxCollider): void;
        setConnectedCollider(owner: pxCollider): void;
        setLocalPos(value: Vector3): void;
        setConnectLocalPos(value: Vector3): void;
        setConnectedMassScale(value: number): void;
        setConnectedInertiaScale(value: number): void;
        setMassScale(value: number): void;
        setInertiaScale(value: number): void;
        setBreakForce(value: number): void;
        setBreakTorque(value: number): void;
        getlinearForce(): Vector3;
        getAngularForce(): Vector3;
        isValid(): boolean;
        release(): void;
    }
    enum PxRevoluteJointFlag {
        eLIMIT_ENABLED = 1,
        eDRIVE_ENABLED = 2,
        eDRIVE_FREESPIN = 4
    }
    class pxRevoluteJoint extends pxJoint implements IHingeJoint {
        /**
         * create Joint
         */
        protected _createJoint(): void;
        setLowerLimit(lowerLimit: number): void;
        setUpLimit(value: number): void;
        setBounceness(value: number): void;
        setBouncenMinVelocity(value: number): void;
        setContactDistance(value: number): void;
        enableLimit(value: boolean): void;
        enableDrive(value: boolean): void;
        enableFreeSpin(value: boolean): void;
        setAxis(value: Vector3): void;
        getAngle(): number;
        getVelocity(): Readonly<Vector3>;
        setDriveVelocity(velocity: number): void;
        setDriveForceLimit(limit: number): void;
    }
    class pxSphereJoint extends pxJoint {
    }
    /**
     * 实现PhysX碰撞数据内容
     */
    class pxCollisionTool {
        constructor();
        /**
         * 转换physX的LayaQuaryResult到HitResult类型
         * @param out
         * @param quaryResult
         * @returns
         */
        static getRayCastResult(out: HitResult, quaryResult: any): HitResult;
        /**
         * 转换所有physX的LayaQuaryResult到HitResult类型
         * @param out
         * @param quaryResults
         * @returns
         */
        static getRayCastResults(out: HitResult[], quaryResults: any): HitResult[];
        /**
         * 回收Collision到pool
         * @param value
         */
        static reCoverCollision(value: Collision): void;
        /**
         * 回收HitResult到pool
         * @param value
         */
        static reCoverHitresults(value: HitResult): void;
    }
    class pxPhysicsCreateUtil implements IPhysicsCreateUtil {
        static _physXPVD: boolean;
        static _PxPvdPort: any;
        static _allocator: any;
        static _tolerancesScale: any;
        protected _physicsEngineCapableMap: Map<any, any>;
        initPhysicsCapable(): void;
        getPhysicsCapable(value: EPhysicsCapable): boolean;
        initialize(): Promise<void>;
        private _init;
        createPhysicsManger(physicsSettings: PhysicsSettings): pxPhysicsManager;
        createDynamicCollider(manager: pxPhysicsManager): IDynamicCollider;
        createStaticCollider(manager: pxPhysicsManager): IStaticCollider;
        createCharacterController(manager: pxPhysicsManager): ICharacterController;
        createFixedJoint(manager: pxPhysicsManager): IFixedJoint;
        createHingeJoint(manager: pxPhysicsManager): IHingeJoint;
        createSpringJoint(manager: pxPhysicsManager): ISpringJoint;
        createD6Joint(manager: pxPhysicsManager): ID6Joint;
        createBoxColliderShape(): IBoxColliderShape;
        createSphereColliderShape(): ISphereColliderShape;
        createPlaneColliderShape(): IPlaneColliderShape;
        createCapsuleColliderShape?(): ICapsuleColliderShape;
        createMeshColliderShape?(): IMeshColliderShape;
        createCylinderColliderShape?(): ICylinderColliderShape;
        createConeColliderShape?(): IConeColliderShape;
        createHeightFieldShape(): pxHeightFieldShape;
        createCorveMesh(mesh: Mesh): Mesh;
        static createFloat32Array(length: number): {
            ptr: number;
            buffer: Float32Array;
        };
        static createUint32Array(length: number): {
            ptr: number;
            buffer: Uint32Array;
        };
        static createUint16Array(length: number): {
            ptr: number;
            buffer: Uint16Array;
        };
        static createUint8Array(length: number): {
            ptr: number;
            buffer: Uint8Array;
        };
        static freeBuffer(data: any): void;
    }
    enum partFlag {
        eSOLVE_CONTACT = 1,
        eMODIFY_CONTACTS = 2,
        eNOTIFY_TOUCH_FOUND = 4,
        eNOTIFY_TOUCH_PERSISTS = 8,
        eNOTIFY_TOUCH_LOST = 16,
        eNOTIFY_TOUCH_CCD = 32,
        eNOTIFY_THRESHOLD_FORCE_FOUND = 64,
        eNOTIFY_THRESHOLD_FORCE_PERSISTS = 128,
        eNOTIFY_THRESHOLD_FORCE_LOST = 256,
        eNOTIFY_CONTACT_POINTS = 512,
        eDETECT_DISCRETE_CONTACT = 1024,
        eDETECT_CCD_CONTACT = 2048,
        ePRE_SOLVER_VELOCITY = 4096,
        ePOST_SOLVER_VELOCITY = 8192,
        eCONTACT_EVENT_POSE = 16384,
        eNEXT_FREE = 32768,
        eCONTACT_DEFAULT = 1025,
        eTRIGGER_DEFAULT = 1044
    }
    class pxPhysicsManager implements IPhysicsManager {
        _dynamicUpdateList: PhysicsUpdateList;
        /**fixedTimeStep */
        fixedTime: number;
        /** enable CCD */
        enableCCD: boolean;
        _pxcontrollerManager: any;
        private _gravity;
        constructor(physicsSettings: PhysicsSettings);
        setDataToMap(dataCallBack: any, eventType: string, isTrigger?: boolean): void;
        setGravity(gravity: Vector3): void;
        private _addCharactorCollider;
        private _removeCharactorCollider;
        private addDynamicElementByUUID;
        private removeDynamicElementByUUID;
        addCollider(collider: ICollider): void;
        removeCollider(collider: ICollider): void;
        private _updatePhysicsEvents;
        private _updatePhysicsTransformToRender;
        private functiontest;
        update(elapsedTime: number): void;
        rayCast(ray: Ray, outHitResult: HitResult, distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        rayCastAll?(ray: Ray, out: HitResult[], distance?: number, collisonGroup?: number, collisionMask?: number): boolean;
        sphereQuery?(pos: Vector3, radius: number, result: ICollider[], collisionmask: number): void;
        destroy(): void;
    }
    class pxPhysicsMaterial {
        private _bounciness;
        private _dynamicFriction;
        private _staticFriction;
        private _bounceCombine;
        private _frictionCombine;
        constructor();
        setBounciness(value: number): void;
        setDynamicFriction(value: number): void;
        setStaticFriction(value: number): void;
        setBounceCombine(value: PhysicsCombineMode): void;
        setFrictionCombine(value: PhysicsCombineMode): void;
        destroy(): void;
    }
    class pxBoxColliderShape extends pxColliderShape implements IBoxColliderShape {
        private static _tempHalfExtents;
        /** @interanl */
        private _size;
        constructor();
        setSize(size: Vector3): void;
        setOffset(position: Vector3): void;
        destroy(): void;
    }
    class pxCapsuleColliderShape extends pxColliderShape implements ICapsuleColliderShape {
        private _upAxis;
        constructor();
        addToActor(collider: pxCollider): void;
        setRadius(radius: number): void;
        setHeight(height: number): void;
        setUpAxis(upAxis: number): void;
        setOffset(position: Vector3): void;
        destroy(): void;
    }
    /**
     * Flags which affect the behavior of Shapes.
     */
    enum ShapeFlag {
        /** The shape will partake in collision in the physical simulation. */
        SIMULATION_SHAPE = 1,
        /** The shape will partake in scene queries (ray casts, overlap tests, sweeps, ...). */
        SCENE_QUERY_SHAPE = 2,
        /** The shape is a trigger which can send reports whenever other shapes enter/leave its volume. */
        TRIGGER_SHAPE = 4
    }
    interface pxFilterData {
        word0?: number;
        word1?: number;
        word2?: number;
        word3?: number;
    }
    class pxColliderShape implements IColliderShape {
        static _shapePool: Map<number, pxColliderShape>;
        static _pxShapeID: number;
        static transform: {
            translation: Vector3;
            rotation: Quaternion;
        };
        _offset: Vector3;
        _scale: Vector3;
        _shapeFlags: ShapeFlag;
        _pxShape: any;
        _pxGeometry: any;
        _id: number;
        filterData: pxFilterData;
        constructor();
        /**
         * @override
         */
        protected _createShape(): void;
        private _modifyFlag;
        addToActor(collider: pxCollider): void;
        removeFromActor(collider: pxCollider): void;
        setOffset(position: Vector3): void;
        setIsTrigger(value: boolean): void;
        _setShapeFlags(flags: ShapeFlag): void;
        setSimulationFilterData(colliderGroup: number, colliderMask: number): void;
        setEventFilterData(filterWorld2Number: number): void;
        destroy(): void;
    }
    class pxHeightFieldShape extends pxColliderShape implements IHeightFieldShape {
        constructor();
        /**
         * get height data tranform
         * @returns
         */
        private getHeightData;
        /**
         * get flag Data
         * @returns
         */
        private getFlagData;
        /**
         * create HeightField Geometry
         */
        private _createHeightField;
        /**
         * set height field Data
         * @param numRows
         * @param numCols
         * @param heightData
         * @param flag
         * @param scale
         */
        setHeightFieldData(numRows: number, numCols: number, heightData: Float32Array, flag: Uint8Array, scale: Vector3): void;
        /**
         * get rows number
         * @returns
         */
        getNbRows(): number;
        /**
         * get cols number
         * @returns
         */
        getNbColumns(): number;
        /**
         * get height number
         * @param rows
         * @param cols
         * @returns
         */
        getHeight(rows: number, cols: number): number;
    }
    enum PxConvexFlag {
        e16_BIT_INDICES = 1,
        eCOMPUTE_CONVEX = 2,
        eCHECK_ZERO_AREA_TRIANGLES = 4,
        eQUANTIZE_INPUT = 8,
        eDISABLE_MESH_VALIDATION = 16,
        ePLANE_SHIFTING = 32,
        eFAST_INERTIA_COMPUTATION = 64,
        eGPU_COMPATIBLE = 128,
        eSHIFT_VERTICES = 256
    }
    enum PxConvexMeshGeometryFlag {
        eTIGHT_BOUNDS = 1
    }
    enum PxMeshGeometryFlag {
        eTIGHT_BOUNDS = 1,
        eDOUBLE_SIDED = 2
    }
    class pxMeshColliderShape extends pxColliderShape implements IMeshColliderShape {
        private _limitvertex;
        private _mesh;
        private _convex;
        private _meshScale;
        constructor();
        private _getMeshPosition;
        private _getIndices;
        private _createConvexMeshGeometry;
        private _createTrianggleMeshGeometry;
        /**
         * @override
         */
        protected _createShape(): void;
        private _reConfigShape;
        private _setScale;
        setOffset(position: Vector3): void;
        setPhysicsMeshFromMesh(value: Mesh): void;
        setConvexMesh(value: Mesh): void;
        setLimitVertex(limit: number): void;
    }
    class pxSphereColliderShape extends pxColliderShape implements ISphereColliderShape {
        constructor();
        setRadius(radius: number): void;
        setOffset(position: Vector3): void;
        destroy(): void;
    }
    class BlendState {
        static _blend_All_pool: any;
        static _blend_seperate_pool: any;
        static create(blendType: number, colorBlendhash: BlendComponent, alphaBlendComponent: BlendComponent): void;
        /** Whether to enable blend. */
        blendType: BlendType;
        colorBlendComponent: BlendComponent;
        alphaBlendComponent: BlendComponent;
        constructor(blendType: number);
    }
    class BlendComponent {
        static _pool: any;
        static getHash(blendOperationGLData: number, sourceBlendFactor: number, destinationFactor: number): number;
        static getBlendComponent(blendOperationGLData: number, sourceBlendFactor: number, destinationFactor: number): any;
        _blendOperation: BlendEquationSeparate;
        _blendOperationGLData: number;
        _sourceBlendFactor: BlendFactor;
        _sourceBlendFactorGLData: number;
        _destinationFactor: BlendFactor;
        _destinationFactorGLData: number;
        _hashIndex: number;
        constructor(blendOperationGLData: BlendEquationSeparate, sourceBlendFactor: BlendFactor, destinationFactor: BlendFactor, hashindex: number);
    }
    class Buffer {
        _glBuffer: IRenderBuffer;
        _buffer: Float32Array | Uint16Array | Uint8Array | Uint32Array;
        _bufferType: number;
        _bufferUsage: number;
        _byteLength: number;
        get bufferUsage(): number;
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
        /**
         * @private
         */
        bind(): boolean;
        unbind(): void;
        /**
         * @private
         */
        destroy(): void;
    }
    type UniformProperty = {
        id: number;
        propertyName: string;
        uniformtype?: ShaderDataType;
    };
    type UniformData = {
        block?: Object;
        propertyName: string;
        uniformtype?: ShaderDataType;
        blockProperty?: UniformProperty[];
    };
    class CommandUniformMap {
        _stateName: string;
        constructor(stateName: string);
        hasPtrID(propertyID: number): boolean;
        getMap(): Record<number, UniformData>;
        /**
         * 增加一个Uniform
         * @param propertyID
         * @param propertyKey
         */
        addShaderBlockUniform(propertyID: number, blockname: string, blockProperty: UniformProperty[]): void;
    }
    /**
     * dds 未存储 color space 需要手动指定
     */
    class DDSTextureInfo {
        width: number;
        height: number;
        mipmapCount: number;
        isCube: boolean;
        bpp: number;
        blockBytes: number;
        format: TextureFormat;
        compressed: boolean;
        dataOffset: number;
        source: ArrayBuffer;
        constructor(width: number, height: number, mipmapCount: number, isCube: boolean, bpp: number, blockBytes: number, dataOffset: number, format: TextureFormat, compressed: boolean, sourceData: ArrayBuffer);
        static getDDSTextureInfo(source: ArrayBuffer): DDSTextureInfo;
    }
    class DepthState {
    }
    /**
     * https://floyd.lbl.gov/radiance/framer.html
     */
    class HDRTextureInfo {
        source: ArrayBuffer;
        byteOffset: number;
        decreaseX: boolean;
        decreaseY: boolean;
        width: number;
        height: number;
        format: TextureFormat;
        static HDRTEXTURE: string;
        static _parseHDRTexture(data: ArrayBuffer, propertyParams?: any, constructParams?: any[]): Texture2D;
        /**
         *
         * @param source
         */
        static getHDRInfo(source: ArrayBuffer): HDRTextureInfo;
        private static getLineString;
        constructor(source: ArrayBuffer, byteOffset: number, decreaseX: boolean, decreaseY: boolean, width: number, height: number, format: TextureFormat);
        get_32_bit_rle_rgbe(): ArrayBufferView;
        /**
         * https://www.radiance-online.org/archived/radsite/radiance/refer/Notes/picture_format.html
         */
        readScanLine(): ArrayBufferView;
        readcolors(scanlineArray: Uint8Array, getc: () => number, wrong: () => void): void;
        olddreadcolors(scanlineArray: Uint8Array, getc: () => number, r: number, g: number, b: number, e: number): void;
        color_color(col: Vector4, clr: Vector4): void;
    }
    class IndexBuffer extends Buffer {
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
        _setIndexData(data: number): void;
        _setIndexData(data: Uint32Array | Uint16Array | Uint8Array, bufferOffset: number): void;
    }
    /**
     * https://www.khronos.org/registry/KTX/specs/1.0/ktxspec_v1.html
     * https://www.khronos.org/registry/KTX/specs/2.0/ktxspec_v2.html
     */
    class KTXTextureInfo {
        source: ArrayBuffer;
        compress: boolean;
        sRGB: boolean;
        dimension: TextureDimension;
        width: number;
        height: number;
        format: TextureFormat;
        mipmapCount: number;
        bytesOfKeyValueData: number;
        headerOffset: number;
        static getLayaFormat(glFormat: number, glInternalFormat: number, glType: number, glTypeSize: number): {
            format: TextureFormat;
            sRGB: boolean;
        };
        static getKTXTextureInfo(source: ArrayBuffer): KTXTextureInfo;
        static createKTX1Info(source: ArrayBuffer): KTXTextureInfo;
        constructor(source: ArrayBuffer, compress: boolean, sRGB: boolean, dimension: TextureDimension, width: number, height: number, format: TextureFormat, mipmapCount: number, bytesOfKeyValueData: number, headerOffset: number);
    }
    enum BlendEquationSeparate {
        ADD = 0,
        SUBTRACT = 1,
        REVERSE_SUBTRACT = 2,
        MIN = 3,
        MAX = 4
    }
    enum BlendFactor {
        /** (0, 0, 0, 0)*/
        Zero = 0,
        /** (1, 1, 1, 1)*/
        One = 1,
        /** (Rs, Gs, Bs, As) */
        SourceColor = 2,
        /** (1 - Rs, 1 - Gs, 1 - Bs, 1 - As)*/
        OneMinusSourceColor = 3,
        /** (Rd, Gd, Bd, Ad)*/
        DestinationColor = 4,
        /** (1 - Rd, 1 - Gd, 1 - Bd, 1 - Ad)*/
        OneMinusDestinationColor = 5,
        /** (As, As, As, As)*/
        SourceAlpha = 6,
        /** (1 - As, 1 - As, 1 - As, 1 - As)*/
        OneMinusSourceAlpha = 7,
        /** (Ad, Ad, Ad, Ad)*/
        DestinationAlpha = 8,
        /** (1 - Ad, 1 - Ad, 1 - Ad, 1 - Ad)*/
        OneMinusDestinationAlpha = 9,
        /** (min(As, 1 - Ad), min(As, 1 - Ad), min(As, 1 - Ad), 10)*/
        SourceAlphaSaturate = 10,
        /** (Rc, Gc, Bc, Ac)*/
        BlendColor = 11,
        /** (1 - Rc, 1 - Gc, 1 - Bc, 1 - Ac)*/
        OneMinusBlendColor = 12
    }
    enum BlendType {
        /**混合枚举_禁用。*/
        BLEND_DISABLE = 0,
        /**混合枚举_启用_RGB和Alpha统一混合。*/
        BLEND_ENABLE_ALL = 1,
        /**混合枚举_启用_RGB和Alpha单独混合。*/
        BLEND_ENABLE_SEPERATE = 2
    }
    enum BufferTargetType {
        ARRAY_BUFFER = 0,
        ELEMENT_ARRAY_BUFFER = 1,
        UNIFORM_BUFFER = 2,
        COPY_READ_BUFFER = 3,
        COPY_WRITE_BUFFER = 4,
        TRANSFORM_FEEDBACK_BUFFER = 5,
        PIXEL_PACK_BUFFER = 6,
        PIXEL_UNPACK_BUFFER = 7
    }
    /**
     * Buffer usage.
     */
    enum BufferUsage {
        /** The buffer content are intended to be specified once, and used many times */
        Static = 0,
        /** The buffer contents are intended to be respecified repeatedly, and used many times */
        Dynamic = 1,
        /** The buffer contents are intended to be specified once, and used at most a few times */
        Stream = 2
    }
    enum CompareFunction {
        /** never pass. */
        Never = 0,
        /** pass if the incoming value is less than the depth/stencil buffer value. */
        Less = 1,
        /** pass if the incoming value equals the depth/stencil buffer value. */
        Equal = 2,
        /** pass if the incoming value is less than or equal to the depth/stencil buffer value. */
        LessEqual = 3,
        /** pass if the incoming value is greater than the depth/stencil buffer value. */
        Greater = 4,
        /** pass if the incoming value is not equal to the depth/stencil buffer value. */
        NotEqual = 5,
        /** pass if the incoming value is greater than or equal to the depth/stencil buffer value. */
        GreaterEqual = 6,
        /** always pass. */
        Always = 7,
        /** off */
        Off = 8
    }
    enum CullMode {
        /** Disable culling. */
        Off = 0,
        /** cut the front-face of the polygons. */
        Front = 1,
        /** cut the back-face of the polygons. */
        Back = 2
    }
    enum DrawType {
        DrawArray = 0,
        DrawArrayInstance = 1,
        DrawElement = 2,
        DrawElementInstance = 3
    }
    /**
     * 纹理的过滤模式。
     */
    enum FilterMode {
        /**点过滤。*/
        Point = 0,
        /**双线性过滤。*/
        Bilinear = 1,
        /**三线性过滤。*/
        Trilinear = 2
    }
    enum HDREncodeFormat {
        NONE = 0,
        RGBM = 1,
        RGBD = 2
    }
    enum IndexFormat {
        /** 8 位无符号整型索引格式。*/
        UInt8 = 0,
        /** 16 位无符号整型索引格式。*/
        UInt16 = 1,
        /** 32 位无符号整型索引格式。*/
        UInt32 = 2
    }
    enum RenderCapable {
        Element_Index_Uint32 = 0,
        TextureFormat_R32G32B32A32 = 1,
        TextureFormat_R16G16B16A16 = 2,
        Texture_anisotropic = 3,
        RenderTextureFormat_R16G16B16A16 = 4,
        RenderTextureFormat_R32G32B32A32 = 5,
        RenderTextureFormat_Depth = 6,
        RenderTextureFormat_ShadowMap = 7,
        Vertex_VAO = 8,
        DrawElement_Instance = 9,
        Shader_TextureLod = 10,
        COMPRESS_TEXTURE_S3TC = 11,
        COMPRESS_TEXTURE_S3TC_SRGB = 12,
        COMPRESS_TEXTURE_PVRTC = 13,
        COMPRESS_TEXTURE_ETC1 = 14,
        COMPRESS_TEXTURE_ETC = 15,
        COMPRESS_TEXTURE_ASTC = 16,
        Texture_SRGB = 17,
        MSAA = 18,
        UnifromBufferObject = 19,
        Texture3D = 20,
        Texture_FloatLinearFiltering = 21,
        Texture_HalfFloatLinearFiltering = 22
    }
    enum RenderClearFlag {
        Nothing = 0,
        Color = 1,
        Depth = 2,
        Stencil = 4
    }
    enum RenderDrawMode {
        TRIANGLES = 0,
        POINTS = 1,
        LINES = 2
    }
    enum RenderIndexMode {
        UNSIGNED_BYTE = 0,
        UNSIGNED_SHORT = 1,
        UNSIGNED_INT = 2
    }
    enum RenderParams {
        Max_Active_Texture_Count = 0,
        Max_Uniform_Count = 1,
        Max_AnisoLevel_Count = 2,
        MAX_Texture_Size = 3,
        MAX_Texture_Image_Uint = 4,
        SHADER_CAPAILITY_LEVEL = 5,
        FLOAT = 6,
        UNSIGNED_BYTE = 7,
        BYTE = 8,
        UNSIGNED_SHORT = 9
    }
    /**
     * Mesh topology.
     */
    enum MeshTopology {
        /** Draws a single dot */
        Points = 0,
        /** Draws a line between a pair of vertices */
        Lines = 1,
        /** Draws a straight line to the next vertex, and connects the last vertex back to the first */
        LineLoop = 2,
        /** Draws a straight line to the next vertex. */
        LineStrip = 3,
        /** Draws a triangle for a group of three vertices */
        Triangles = 4,
        /** Draws a triangle strip */
        TriangleStrip = 5,
        /** Draws a triangle fan */
        TriangleFan = 6
    }
    enum RenderStateType {
        DepthTest = 0,
        DepthMask = 1,
        DepthFunc = 2,
        StencilTest = 3,
        StencilMask = 4,
        StencilFunc = 5,
        StencilOp = 6,
        BlendType = 7,
        BlendEquation = 8,
        BlendEquationSeparate = 9,
        BlendFunc = 10,
        BlendFuncSeperate = 11,
        CullFace = 12,
        FrontFace = 13
    }
    /**
     * 渲染统计数据
     */
    enum RenderStatisticsInfo {
        DrawCall = 0,
        InstanceDrawCall = 1,
        Triangle = 2,
        UniformUpload = 3,
        GPUMemory = 4,
        TextureMemeory = 5,
        RenderTextureMemory = 6,
        BufferMemory = 7
    }
    enum RenderTargetFormat {
        None = -1,
        /**使用RGB的纹理，不可设置SRGB参数 */
        R8G8B8 = 0,
        R8G8B8A8 = 1,
        R16G16B16A16 = 17,
        R32G32B32 = 30,
        R32G32B32A32 = 15,
        R16G16B16 = 31,
        DEPTH_16 = 35,
        STENCIL_8 = 36,
        DEPTHSTENCIL_24_8 = 37,
        DEPTH_32 = 38,
        DEPTHSTENCIL_24_Plus = 39
    }
    enum StencilOperation {
        /** Keeps the current value. */
        Keep = 0,
        /** Sets the stencil buffer value to 0. */
        Zero = 1,
        /** Sets the stencil buffer value to the reference value. */
        Replace = 2,
        /** Increments the current stencil buffer value. Clamps to the maximum representable unsigned value. */
        IncrementSaturate = 3,
        /** Decrements the current stencil buffer value. Clamps to 0. */
        DecrementSaturate = 4,
        /** Inverts the current stencil buffer value bitwise. */
        Invert = 5,
        /** Increments the current stencil buffer value. Wraps stencil buffer value to zero when incrementing the maximum representable unsigned value. */
        IncrementWrap = 6,
        /** Decrements the current stencil buffer value. Wraps stencil buffer value to the maximum representable unsigned value when decrementing a stencil buffer value of 0. */
        DecrementWrap = 7
    }
    enum TextureCompareMode {
        None = 0,
        LEQUAL = 1,
        GEQUAL = 2,
        LESS = 3,
        GREATER = 4,
        EQUAL = 5,
        NOTEQUAL = 6,
        ALWAYS = 7,
        NEVER = 8
    }
    /**
     * 纹理解码格式。
     */
    enum TextureDecodeFormat {
        /** 常规解码方式,直接采样纹理颜色。*/
        Normal = 0,
        /** 按照RGBM方式解码并计算最终RGB颜色。 */
        RGBM = 1
    }
    enum TextureDimension {
        Tex2D = 0,
        Cube = 1,
        Tex3D = 2,
        Texture2DArray = 3,
        CubeArray = 4,
        Unkonw = 5,
        None = 6
    }
    /**
     * 纹理格式
     */
    enum TextureFormat {
        /**纹理格式_R8G8B8。*/
        R8G8B8 = 0,
        /**纹理格式_R8G8B8A8。*/
        R8G8B8A8 = 1,
        /**RGB格式纹理,R通道5位，G通道6位，B通道5位。*/
        R5G6B5 = 16,
        /**纹理格式_ALPHA8。*/
        Alpha8 = 2,
        /**纹理格式_DXT1。*/
        DXT1 = 3,
        /**纹理格式_DXT3 */
        DXT3 = 29,
        /**纹理格式_DXT5。*/
        DXT5 = 4,
        /**纹理格式_ETC2RGB。*/
        ETC1RGB = 5,
        ETC2RGB = 6,
        ETC2RGBA = 7,
        /**纹理格式_ETC2RGB_PUNCHTHROUGHALPHA。*/
        /**纹理格式_PVRTCRGB_2BPPV。*/
        ETC2SRGB_Alpha8 = 8,
        /** 纹理格式_ETC2SRGB*/
        ETC2SRGB = 28,
        /** 纹理格式_PVRTCRGB_2BPPV*/
        PVRTCRGB_2BPPV = 9,
        /**纹理格式_PVRTCRGBA_2BPPV。*/
        PVRTCRGBA_2BPPV = 10,
        /**纹理格式_PVRTCRGB_4BPPV。*/
        PVRTCRGB_4BPPV = 11,
        /**纹理格式_PVRTCRGBA_4BPPV。*/
        PVRTCRGBA_4BPPV = 12,
        /**RGBA格式纹理,每个通道32位浮点数。*/
        R32G32B32A32 = 15,
        /**R32G32B32 */
        R32G32B32 = 30,
        /**RGBA格式纹理，每个通道16位浮点数。 */
        R16G16B16A16 = 17,
        /**R16 G16 B6 */
        R16G16B16 = 31,
        /**ASTC 4x4*/
        ASTC4x4 = 18,
        /**ASTC sRGB 4x4 */
        ASTC4x4SRGB = 23,
        /**ASTC 6x6*/
        ASTC6x6 = 19,
        /**ASTC  6x6*/
        ASTC6x6SRGB = 24,
        /**ASTC 8x8 */
        ASTC8x8 = 20,
        /**ASTC srgb 8x8 */
        ASTC8x8SRGB = 25,
        /**ASTC 10x10 */
        ASTC10x10 = 21,
        /**ASTC srgb 10x10 */
        ASTC10x10SRGB = 26,
        /**ASTC 12x12 */
        ASTC12x12 = 22,
        /**ASTC srgb 12x12 */
        ASTC12x12SRGB = 27,
        /**ktx图片 */
        KTXTEXTURE = -1,
        /**pvr图片 */
        PVRTEXTURE = -2
    }
    /**
     * 纹理寻址模式。
     */
    enum WrapMode {
        /** 循环平铺。*/
        Repeat = 0,
        /** 超过UV边界后采用最后一个像素。*/
        Clamp = 1,
        /** 镜像采样 */
        Mirrored = 2
    }
    interface InternalRenderTarget {
        _isCube: boolean;
        _samples: number;
        _generateMipmap: boolean;
        _textures: InternalTexture[];
        _depthTexture: InternalTexture;
        colorFormat: RenderTargetFormat;
        depthStencilFormat: RenderTargetFormat;
        isSRGB: boolean;
        gpuMemory: number;
        dispose(): void;
    }
    /**
     * 内部纹理对象
     */
    interface InternalTexture {
        /**
         * gpu texture object
         */
        resource: any;
        target: number;
        width: number;
        height: number;
        depth: number;
        isPotSize: boolean;
        mipmap: boolean;
        mipmapCount: number;
        filterMode: FilterMode;
        wrapU: WrapMode;
        wrapV: WrapMode;
        wrapW: WrapMode;
        anisoLevel: number;
        baseMipmapLevel: number;
        maxMipmapLevel: number;
        compareMode: TextureCompareMode;
        /**bytelength */
        gpuMemory: number;
        /**
         * 是否使用 sRGB格式 加载图片数据
         */
        useSRGBLoad: boolean;
        /**
         * gamma 矫正值
         */
        gammaCorrection: number;
        dispose(): void;
    }
    interface IRender2DContext {
        activeTexture(textureID: number): void;
        bindTexture(target: number, texture: any): void;
        bindUseProgram(webglProgram: any): boolean;
    }
    interface IRenderBuffer {
        bindBuffer(): boolean;
        unbindBuffer(): void;
        setDataLength(srcData: number): void;
        setData(srcData: ArrayBuffer | ArrayBufferView, offset: number): void;
        setDataEx(srcData: ArrayBuffer | ArrayBufferView, offset: number, length: number): void;
        bindBufferBase(glPointer: number): void;
        bindBufferRange(glPointer: number, offset: number, byteCount: number): void;
        destroy(): void;
    }
    interface IRenderDrawContext {
    }
    interface IRenderEngine {
        _context: any;
        initRenderEngine(canvas: any): void;
        applyRenderStateCMD(cmd: RenderStateCommand): void;
        viewport(x: number, y: number, width: number, height: number): void;
        scissor(x: number, y: number, width: number, height: number): void;
        colorMask(r: boolean, g: boolean, b: boolean, a: boolean): void;
        copySubFrameBuffertoTex(texture: BaseTexture, level: number, xoffset: number, yoffset: number, x: number, y: number, width: number, height: number): void;
        bindTexture(texture: BaseTexture): void;
        clearRenderTexture(clearFlag: RenderClearFlag | number, clearcolor: Color, clearDepth: number): void;
        scissorTest(value: boolean): void;
        propertyNameToID(name: string): number;
        propertyIDToName(id: number): string;
        getParams(params: RenderParams): number;
        getCapable(capatableType: RenderCapable): boolean;
        getTextureContext(): ITextureContext;
        getDrawContext(): IRenderDrawContext;
        get2DRenderContext(): IRender2DContext;
        getCreateRenderOBJContext(): IRenderEngineFactory;
        createRenderStateComand(): RenderStateCommand;
        createShaderInstance(vs: string, ps: string, attributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        }): IRenderShaderInstance;
        createBuffer(targetType: BufferTargetType, bufferUsageType: BufferUsage): IRenderBuffer;
        createVertexState(): IRenderVertexState;
        getUBOPointer(name: string): number;
        unbindVertexState(): void;
    }
    interface IRenderEngineFactory {
        createShaderInstance(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderCompileDefineBase): any;
        createShaderData(ownerResource: Resource): ShaderData;
        createRenderStateComand(): RenderStateCommand;
        createRenderState(): RenderState;
        createUniformBufferObject(glPointer: number, name: string, bufferUsage: BufferUsage, byteLength: number, isSingle: boolean): UniformBufferObject;
        createGlobalUniformMap(blockName: string): CommandUniformMap;
        createEngine(config: Config, canvas: any): Promise<void>;
    }
    interface IRenderShaderInstance {
        getUniformMap(): ShaderVariable[];
        destroy(): void;
    }
    interface IRenderTarget {
        _renderTarget: InternalRenderTarget;
        _isCameraTarget: boolean;
        isCube: boolean;
        samples: number;
        generateMipmap: boolean;
        depthStencilTexture: BaseTexture | null;
    }
    /**
     * 接口用来描述绑定渲染顶点布局
     */
    interface IRenderVertexState {
        _vertexDeclaration: VertexDeclaration[];
        _bindedIndexBuffer: IndexBuffer;
        _vertexBuffers: VertexBuffer[];
        applyVertexBuffer(vertexBuffer: VertexBuffer[]): void;
        applyIndexBuffer(indexBuffer: IndexBuffer | null): void;
    }
    interface ITextureContext {
        needBitmap: boolean;
        /**
         * 为 Texture 创建 InternalTexture
         * @param width
         * @param height
         * @param format
         * @param generateMipmap
         * @param sRGB
         * @returns
         */
        createTextureInternal(dimension: TextureDimension, width: number, height: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTextureImageData(texture: InternalTexture, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureSubImageData(texture: InternalTexture, source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, x: number, y: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexturePixelsData(texture: InternalTexture, source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        initVideoTextureData(texture: InternalTexture): void;
        setTextureSubPixelsData(texture: InternalTexture, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTextureDDSData(texture: InternalTexture, ddsInfo: DDSTextureInfo): void;
        setTextureKTXData(texture: InternalTexture, ktxInfo: KTXTextureInfo): void;
        setTextureHDRData(texture: InternalTexture, hdrInfo: HDRTextureInfo): void;
        setCubeImageData(texture: InternalTexture, sources: (HTMLImageElement | HTMLCanvasElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubePixelsData(texture: InternalTexture, source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeSubPixelData(texture: InternalTexture, source: ArrayBufferView[], mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, width: number, height: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setCubeDDSData(texture: InternalTexture, ddsInfo: DDSTextureInfo): void;
        setCubeKTXData(texture: InternalTexture, ktxInfo: KTXTextureInfo): void;
        setTextureCompareMode(texture: InternalTexture, compareMode: TextureCompareMode): TextureCompareMode;
        createRenderTextureInternal(dimension: TextureDimension, width: number, height: number, format: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean): InternalTexture;
        createRenderTargetInternal(width: number, height: number, format: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): InternalRenderTarget;
        createRenderTargetCubeInternal(size: number, colorFormat: RenderTargetFormat, depthStencilFormat: RenderTargetFormat, generateMipmap: boolean, sRGB: boolean, multiSamples: number): InternalRenderTarget;
        setupRendertargetTextureAttachment(renderTarget: InternalRenderTarget, texture: InternalTexture): void;
        bindRenderTarget(renderTarget: InternalRenderTarget, faceIndex?: number): void;
        bindoutScreenTarget(): void;
        unbindRenderTarget(renderTarget: InternalRenderTarget): void;
        readRenderTargetPixelData(renderTarget: InternalRenderTarget, xOffset: number, yOffset: number, width: number, height: number, out: ArrayBufferView): ArrayBufferView;
        updateVideoTexture(texture: InternalTexture, video: HTMLVideoElement, premultiplyAlpha: boolean, invertY: boolean): void;
        getRenderTextureData(internalTex: InternalRenderTarget, x: number, y: number, width: number, height: number): ArrayBufferView;
    }
    interface ITexture3DContext extends ITextureContext {
        createTexture3DInternal(dimension: TextureDimension, width: number, height: number, depth: number, format: TextureFormat, generateMipmap: boolean, sRGB: boolean, premultipliedAlpha: boolean): InternalTexture;
        setTexture3DImageData(texture: InternalTexture, source: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DPixelsData(texture: InternalTexture, source: ArrayBufferView, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
        setTexture3DSubPixelsData(texture: InternalTexture, source: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, premultiplyAlpha: boolean, invertY: boolean): void;
    }
    /**
     * 基本渲染单元
     */
    interface IBaseRenderNode {
    }
    interface ICameraCullInfo {
        /**位置 */
        position: Vector3;
        /**是否遮挡剔除 */
        useOcclusionCulling: Boolean;
        /**锥体包围盒 */
        boundFrustum: BoundFrustum;
        /**遮挡标记 */
        cullingMask: number;
        /**静态标记 */
        staticMask: number;
    }
    /**
     * 裁剪接口
     */
    interface ICullPass {
        cullList: SingletonList<BaseRender>;
        cullByCameraCullInfo(cameraCullInfo: ICameraCullInfo, renderManager: ISceneRenderManager): void;
        cullByShadowCullInfo(cullInfo: IShadowCullInfo, renderManager: ISceneRenderManager): void;
        cullingSpotShadow(cameraCullInfo: ICameraCullInfo, renderManager: ISceneRenderManager): void;
    }
    type PipelineMode = "Forward" | "ShadowCaster" | "DepthNormal" | string;
    interface IRenderContext3D {
        destTarget: IRenderTarget;
        viewPort: Viewport;
        scissor: Vector4;
        invertY: boolean;
        pipelineMode: PipelineMode;
        configShaderData: ShaderData;
        cameraShaderData: ShaderData;
        sceneID: number;
        sceneShaderData: ShaderData;
        cameraUpdateMark: number;
        globalShaderData: ShaderData;
        /**设置IRenderContext */
        applyContext(cameraUpdateMark: number): void;
        /**draw one element by context */
        drawRenderElement(renderelemt: IRenderElement): void;
        end(): void;
    }
    interface IRenderElement {
        _geometry: IRenderGeometryElement;
        _shaderInstances: SingletonList<ShaderInstance>;
        _materialShaderData: ShaderData;
        _renderShaderData: ShaderData;
        _transform: Transform3D;
        _isRender: boolean;
        _owner: IBaseRenderNode;
        _invertFront: boolean;
        _render(context: IRenderContext3D): void;
        _addShaderInstance(shader: ShaderInstance): void;
        _clearShaderInstance(): void;
        _destroy(): void;
    }
    interface IRenderGeometryElement {
    }
    /**
     * 渲染通道
     */
    interface IRenderPass {
        /**渲染状态 */
        context: RenderContext3D;
        _cullPass: ICullPass;
        setRenderlist(list: SingletonList<IBaseRenderNode>): void;
        applyRenderQueue(queue: IRenderQueue): void;
        update(): void;
        render(): void;
    }
    /**
     * RenderQueue,渲染队列
     */
    interface IRenderQueue {
        /** @interanl */
        _isTransparent: boolean;
        /**
         * @param context 渲染上下文
         * @return 返回渲染数量
         */
        renderQueue(context: RenderContext3D): number;
        addRenderElement(renderElement: RenderElement): void;
        clear(): void;
        destroy(): void;
    }
    /**
     * 可替换的SceneManager
     */
    interface ISceneRenderManager {
        list: SingletonList<BaseRender>;
        /**
         * add one BaseRender
         * @param object
         */
        addRenderObject(object: BaseRender): void;
        /**
         * remove RenderObject
         * @param object
         */
        removeRenderObject(object: BaseRender): void;
        /**
         * 移除某个动态的渲染节点
         * @param object
         */
        removeMotionObject(object: BaseRender): void;
        /**
         * 增加运动物体
         * @param object
         */
        addMotionObject(object: BaseRender): void;
        /**
         * 更新运动物体
         * @param object
         */
        updateMotionObjects(): void;
        /**
         * release Manager Node
         */
        destroy(): void;
    }
    interface IShadowCullInfo {
        position: Vector3;
        cullPlanes: Plane[];
        cullSphere: BoundSphere;
        cullPlaneCount: number;
        direction: Vector3;
    }
    interface ISortPass {
        /**
         * 排序
         * @param elements
         * @param left
         * @param right
         */
        sort(elements: SingletonList<RenderElement>, isTransparent: boolean, left: number, right: number): void;
    }
    /**
     * <code>DefineDatas</code> 类用于创建宏定义数据集合。
     */
    class DefineDatas implements IClone {
        /**
         * 创建一个 <code>DefineDatas</code> 实例。
         */
        constructor();
        /**
         * 添加宏定义值。
         * @param define 宏定义值。
         */
        add(define: ShaderDefine): void;
        /**
         * 移除宏定义。
         * @param define 宏定义。
         */
        remove(define: ShaderDefine): void;
        /**
         * 添加宏定义集合。
         * @param define 宏定义集合。
         */
        addDefineDatas(define: DefineDatas): void;
        /**
         * 移除宏定义集合。
         * @param define 宏定义集合。
         */
        removeDefineDatas(define: DefineDatas): void;
        /**
         * 是否有宏定义。
         * @param define 宏定义。
         */
        has(define: ShaderDefine): boolean;
        /**
         * 清空宏定义。
         */
        clear(): void;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
        destroy(): void;
    }
    /**
     * <code>RenderState</code> 类用于控制渲染状态。
     */
    class RenderState {
        /**剔除枚举_不剔除。*/
        static CULL_NONE: number;
        /**剔除枚举_剔除正面。*/
        static CULL_FRONT: number;
        /**剔除枚举_剔除背面。*/
        static CULL_BACK: number;
        /**混合枚举_禁用。*/
        static BLEND_DISABLE: number;
        /**混合枚举_启用_RGB和Alpha统一混合。*/
        static BLEND_ENABLE_ALL: number;
        /**混合枚举_启用_RGB和Alpha单独混合。*/
        static BLEND_ENABLE_SEPERATE: number;
        /**混合参数枚举_零,例：RGB(0,0,0),Alpha:(1)。*/
        static BLENDPARAM_ZERO: number;
        /**混合参数枚举_一,例：RGB(1,1,1),Alpha:(1)。*/
        static BLENDPARAM_ONE: number;
        /**混合参数枚举_源颜色,例：RGB(Rs, Gs, Bs)，Alpha(As)。*/
        static BLENDPARAM_SRC_COLOR: number;
        /**混合参数枚举_一减源颜色,例：RGB(1-Rs, 1-Gs, 1-Bs)，Alpha(1-As)。*/
        static BLENDPARAM_ONE_MINUS_SRC_COLOR: number;
        /**混合参数枚举_目标颜色,例：RGB(Rd, Gd, Bd),Alpha(Ad)。*/
        static BLENDPARAM_DST_COLOR: number;
        /**混合参数枚举_一减目标颜色,例：RGB(1-Rd, 1-Gd, 1-Bd)，Alpha(1-Ad)。*/
        static BLENDPARAM_ONE_MINUS_DST_COLOR: number;
        /**混合参数枚举_源透明,例:RGB(As, As, As),Alpha(1-As)。*/
        static BLENDPARAM_SRC_ALPHA: number;
        /**混合参数枚举_一减源阿尔法,例:RGB(1-As, 1-As, 1-As),Alpha(1-As)。*/
        static BLENDPARAM_ONE_MINUS_SRC_ALPHA: number;
        /**混合参数枚举_目标阿尔法，例：RGB(Ad, Ad, Ad),Alpha(Ad)。*/
        static BLENDPARAM_DST_ALPHA: number;
        /**混合参数枚举_一减目标阿尔法,例：RGB(1-Ad, 1-Ad, 1-Ad),Alpha(Ad)。*/
        static BLENDPARAM_ONE_MINUS_DST_ALPHA: number;
        /**混合参数枚举_阿尔法饱和，例：RGB(min(As, 1 - Ad), min(As, 1 - Ad), min(As, 1 - Ad)),Alpha(1)。*/
        static BLENDPARAM_SRC_ALPHA_SATURATE: number;
        /**混合参数枚举_混合设置颜色 */
        static BLENDPARAM_BLENDCOLOR: number;
        /**很合参数枚举_混合颜色取反 */
        static BLENDPARAM_BLEND_ONEMINUS_COLOR: number;
        /**混合方程枚举_加法,例：source + destination*/
        static BLENDEQUATION_ADD: number;
        /**混合方程枚举_减法，例：source - destination*/
        static BLENDEQUATION_SUBTRACT: number;
        /**混合方程枚举_反序减法，例：destination - source*/
        static BLENDEQUATION_REVERSE_SUBTRACT: number;
        /**混合方程枚举_取最小 TODO */
        static BLENDEQUATION_MIN: number;
        /**混合方程枚举_取最大 TODO*/
        static BLENDEQUATION_MAX: number;
        /**深度测试函数枚举_关闭深度测试。*/
        static DEPTHTEST_OFF: number;
        /**深度测试函数枚举_从不通过。*/
        static DEPTHTEST_NEVER: number;
        /**深度测试函数枚举_小于时通过。*/
        static DEPTHTEST_LESS: number;
        /**深度测试函数枚举_等于时通过。*/
        static DEPTHTEST_EQUAL: number;
        /**深度测试函数枚举_小于等于时通过。*/
        static DEPTHTEST_LEQUAL: number;
        /**深度测试函数枚举_大于时通过。*/
        static DEPTHTEST_GREATER: number;
        /**深度测试函数枚举_不等于时通过。*/
        static DEPTHTEST_NOTEQUAL: number;
        /**深度测试函数枚举_大于等于时通过。*/
        static DEPTHTEST_GEQUAL: number;
        /**深度测试函数枚举_总是通过。*/
        static DEPTHTEST_ALWAYS: number;
        static STENCILTEST_OFF: number;
        /**深度测试函数枚举_从不通过。*/
        static STENCILTEST_NEVER: number;
        /**深度测试函数枚举_小于时通过。*/
        static STENCILTEST_LESS: number;
        /**深度测试函数枚举_等于时通过。*/
        static STENCILTEST_EQUAL: number;
        /**深度测试函数枚举_小于等于时通过。*/
        static STENCILTEST_LEQUAL: number;
        /**深度测试函数枚举_大于时通过。*/
        static STENCILTEST_GREATER: number;
        /**深度测试函数枚举_不等于时通过。*/
        static STENCILTEST_NOTEQUAL: number;
        /**深度测试函数枚举_大于等于时通过。*/
        static STENCILTEST_GEQUAL: number;
        /**深度测试函数枚举_总是通过。*/
        static STENCILTEST_ALWAYS: number;
        /**保持当前值*/
        static STENCILOP_KEEP: number;
        /**将模板缓冲区值设置为0*/
        static STENCILOP_ZERO: number;
        /**将模具缓冲区值设置为指定的参考值*/
        static STENCILOP_REPLACE: number;
        /**增加当前模具缓冲区值+1 */
        static STENCILOP_INCR: number;
        /**增加当前模具缓冲区值,超过最大值的时候循环*/
        static STENCILOP_INCR_WRAP: number;
        /**递减当前模板缓冲区的值*/
        static STENCILOP_DECR: number;
        /**递减当前模板缓冲去的值，小于0时会循环*/
        static STENCILOP_DECR_WRAP: number;
        /**按位反转当前的模板缓冲区的值*/
        static STENCILOP_INVERT: number;
        /**渲染剔除状态。*/
        cull: number;
        /**透明混合。*/
        blend: number;
        /**源混合参数,在blend为BLEND_ENABLE_ALL时生效。*/
        srcBlend: number;
        /**目标混合参数,在blend为BLEND_ENABLE_ALL时生效。*/
        dstBlend: number;
        /**RGB源混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
        srcBlendRGB: number;
        /**RGB目标混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
        dstBlendRGB: number;
        /**Alpha源混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
        srcBlendAlpha: number;
        /**Alpha目标混合参数,在blend为BLEND_ENABLE_SEPERATE时生效。*/
        dstBlendAlpha: number;
        /**混合方程。*/
        blendEquation: number;
        /**RGB混合方程。*/
        blendEquationRGB: number;
        /**Alpha混合方程。*/
        blendEquationAlpha: number;
        /**深度测试函数。*/
        depthTest: number;
        /**是否深度测试。*/
        depthWrite: boolean;
        /**是否模板写入 */
        stencilWrite: boolean;
        /**是否开启模板测试 */
        stencilTest: number;
        /**模板值 一般会在0-255*/
        stencilRef: number;
        /**模板设置值 */
        stencilOp: Vector3;
        /**
         * 创建一个 <code>RenderState</code> 实例。
         */
        constructor();
        /**
         * 克隆
         * @param dest
         */
        cloneTo(dest: RenderState): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): RenderState;
    }
    interface IShaderObjStructor {
        name: string;
        enableInstancing: boolean;
        supportReflectionProbe: boolean;
        surportVolumetricGI: boolean;
        attributeMap: any;
        uniformMap: any;
        defaultValue: any;
        shaderPass: Array<any>;
    }
    interface IShaderpassStructor {
        VS?: string;
        FS?: string;
        VSPath?: string;
        FSPath?: string;
        pipeline?: string;
        statefirst?: boolean;
        renderState?: Record<string, string | boolean | number | string[]>;
    }
    enum ShaderFeatureType {
        DEFAULT = 0,
        D3 = 1,
        D2 = 2,
        PostProcess = 3,
        Sky = 4,
        Effect = 5
    }
    /**
     * <code>Shader3D</code> 类用于创建Shader3D。
     */
    class Shader3D {
        static _configDefineValues: DefineDatas;
        /**渲染状态_剔除。*/
        static CULL: number;
        /**渲染状态_混合。*/
        static BLEND: number;
        /**渲染状态_混合源。*/
        static BLEND_SRC: number;
        /**渲染状态_混合目标。*/
        static BLEND_DST: number;
        /**渲染状态_混合源RGB。*/
        static BLEND_SRC_RGB: number;
        /**渲染状态_混合目标RGB。*/
        static BLEND_DST_RGB: number;
        /**渲染状态_混合源ALPHA。*/
        static BLEND_SRC_ALPHA: number;
        /**渲染状态_混合目标ALPHA。*/
        static BLEND_DST_ALPHA: number;
        /**渲染状态_混合方程。*/
        static BLEND_EQUATION: number;
        /**渲染状态_混合方程。*/
        static BLEND_EQUATION_RGB: number;
        /**渲染状态_ALPHA混合方程。*/
        static BLEND_EQUATION_ALPHA: number;
        /**渲染状态_深度测试。*/
        static DEPTH_TEST: number;
        /**渲染状态_深度写入。*/
        static DEPTH_WRITE: number;
        /**渲染状态_模板测试。*/
        static STENCIL_TEST: number;
        /**渲染状态_模板写入 */
        static STENCIL_WRITE: number;
        /**渲染状态_模板写入值 */
        static STENCIL_Ref: number;
        /**渲染状态_模板写入设置 */
        static STENCIL_Op: number;
        /**shader变量提交周期，自定义。*/
        static PERIOD_CUSTOM: number;
        /**shader变量提交周期，逐材质。*/
        static PERIOD_MATERIAL: number;
        /**shader变量提交周期，逐精灵和相机，注：因为精灵包含MVP矩阵，为复合属性，所以摄像机发生变化时也应提交。*/
        static PERIOD_SPRITE: number;
        /**shader变量提交周期，逐相机。*/
        static PERIOD_CAMERA: number;
        /**shader变量提交周期，逐场景。*/
        static PERIOD_SCENE: number;
        /**是否开启调试模式。 */
        static debugMode: boolean;
        /**调试着色器变种集合。 */
        static debugShaderVariantCollection: ShaderVariantCollection;
        static init(): void;
        /**
         * 注册宏定义。
         * @param name
         */
        static getDefineByName(name: string): ShaderDefine;
        /**
         * 通过Shader属性名称获得唯一ID。
         * @param name Shader属性名称。
         * @return 唯一ID。
         */
        static propertyNameToID(name: string): number;
        static propertyIDToName(id: number): string;
        /**
         * 添加函数库引用。
         * @param fileName 文件名字。
         * @param txt 文件内容
         */
        static addInclude(fileName: string, txt: string): void;
        /**
         * 通过宏定义名字编译shader。
         * @param	shaderName Shader名称。
         * @param   subShaderIndex 子着色器索引。
         * @param   passIndex  通道索引。
         * @param	defineNames 宏定义名字集合。
         */
        static compileShaderByDefineNames(shaderName: string, subShaderIndex: number, passIndex: number, defineNames: string[], nodeCommonMap: string[]): void;
        /**
         * 添加预编译shader文件，主要是处理宏定义
         */
        static add(name: string, enableInstancing?: boolean, supportReflectionProbe?: boolean): Shader3D;
        /**
         * 获取ShaderCompile3D。
         * @param	name
         * @return ShaderCompile3D。
         */
        static find(name: string): Shader3D;
        static parse(data: IShaderObjStructor, basePath: string): Shader3D;
        shaderType: ShaderFeatureType;
        /**
         * 名字。
         */
        get name(): string;
        /**
         * 创建一个 <code>Shader3D</code> 实例。
         */
        constructor(name: string, enableInstancing: boolean, supportReflectionProbe: boolean);
        /**
         * 添加子着色器。
         * @param 子着色器。
         */
        addSubShader(subShader: SubShader): void;
        /**
         * 在特定索引获取子着色器。
         * @param	index 索引。
         * @return 子着色器。
         */
        getSubShaderAt(index: number): SubShader;
    }
    enum ShaderDataType {
        Int = 0,
        Bool = 1,
        Float = 2,
        Vector2 = 3,
        Vector3 = 4,
        Vector4 = 5,
        Color = 6,
        Matrix4x4 = 7,
        Texture2D = 8,
        TextureCube = 9,
        Buffer = 10,
        Matrix3x3 = 11,
        Texture2DArray = 12,
        Texture3D = 13
    }
    type ShaderDataItem = number | boolean | Vector2 | Vector3 | Vector4 | Color | Matrix4x4 | BaseTexture | Float32Array | Matrix3x3;
    function ShaderDataDefaultValue(type: ShaderDataType): false | Readonly<Vector2> | 0 | Readonly<Matrix3x3> | Readonly<Vector3> | Readonly<Matrix4x4> | Readonly<Vector4> | Color | Texture2DArray;
    /**
     * 着色器数据类。
     */
    class ShaderData implements IClone {
        get uniformBuffersMap(): Map<number, UniformBufferObject>;
        applyUBOData(): void;
        /**
         * 增加Shader宏定义。
         * @param value 宏定义。
         */
        addDefine(define: ShaderDefine): void;
        /**
         * 移除Shader宏定义。
         * @param value 宏定义。
         */
        removeDefine(define: ShaderDefine): void;
        /**
         * 是否包含Shader宏定义。
         * @param value 宏定义。
         */
        hasDefine(define: ShaderDefine): boolean;
        /**
         * 清空宏定义。
         */
        clearDefine(): void;
        /**
         * 获取布尔。
         * @param	index shader索引。
         * @return  布尔。
         */
        getBool(index: number): boolean;
        /**
         * 设置布尔。
         * @param	index shader索引。
         * @param	value 布尔。
         */
        setBool(index: number, value: boolean): void;
        /**
         * 获取整形。
         * @param	index shader索引。
         * @return  整形。
         */
        getInt(index: number): number;
        /**
         * 设置整型。
         * @param	index shader索引。
         * @param	value 整形。
         */
        setInt(index: number, value: number): void;
        /**
         * 获取浮点。
         * @param	index shader索引。
         * @return	浮点。
         */
        getNumber(index: number): number;
        /**
         * 设置浮点。
         * @param	index shader索引。
         * @param	value 浮点。
         */
        setNumber(index: number, value: number): void;
        /**
         * 获取Vector2向量。
         * @param	index shader索引。
         * @return Vector2向量。
         */
        getVector2(index: number): Vector2;
        /**
         * 设置Vector2向量。
         * @param	index shader索引。
         * @param	value Vector2向量。
         */
        setVector2(index: number, value: Vector2): void;
        /**
         * 获取Vector3向量。
         * @param	index shader索引。
         * @return Vector3向量。
         */
        getVector3(index: number): Vector3;
        /**
         * 设置Vector3向量。
         * @param	index shader索引。
         * @param	value Vector3向量。
         */
        setVector3(index: number, value: Vector3): void;
        /**
         * 获取颜色。
         * @param 	index shader索引。
         * @return  向量。
         */
        getVector(index: number): Vector4;
        /**
         * 设置向量。
         * @param	index shader索引。
         * @param	value 向量。
         */
        setVector(index: number, value: Vector4): void;
        /**
         * 获取颜色
         * @param index 索引
         * @returns 颜色
         */
        getColor(index: number): Color;
        /**
         * 设置颜色
         * @param index 索引
         * @param value 颜色值
         */
        setColor(index: number, value: Color): void;
        /**
         * 获取矩阵。
         * @param	index shader索引。
         * @return  矩阵。
         */
        getMatrix4x4(index: number): Matrix4x4;
        /**
         * 设置矩阵。
         * @param	index shader索引。
         * @param	value  矩阵。
         */
        setMatrix4x4(index: number, value: Matrix4x4): void;
        /**
         * 获取矩阵
         * @param index
         * @returns
         */
        getMatrix3x3(index: number): Matrix3x3;
        /**
         * 设置矩阵。
         * @param index
         * @param value
         */
        setMatrix3x3(index: number, value: Matrix3x3): void;
        /**
         * 获取Buffer。
         * @param	index shader索引。
         * @return
         */
        getBuffer(index: number): Float32Array;
        /**
         * 设置Buffer。
         * @param	index shader索引。
         * @param	value  buffer数据。
         */
        setBuffer(index: number, value: Float32Array): void;
        /**
         * 设置纹理。
         * @param	index shader索引。
         * @param	value 纹理。
         */
        setTexture(index: number, value: BaseTexture): void;
        /**
         * 获取纹理。
         * @param	index shader索引。
         * @return  纹理。
         */
        getTexture(index: number): BaseTexture;
        getSourceIndex(value: any): number;
        /**
         * set shader data
         * @deprecated
         * @param index uniformID
         * @param value data
         */
        setValueData(index: number, value: any): void;
        /**
         *
         * @param index
         * @param value
         */
        setUniformBuffer(index: number, value: UniformBufferObject): void;
        getUniformBuffer(index: number): UniformBufferObject;
        setShaderData(uniformIndex: number, type: ShaderDataType, value: ShaderDataItem | Quaternion): void;
        getShaderData(uniformIndex: number, type: ShaderDataType): number | boolean | Vector2 | Float32Array | Vector3 | Matrix3x3 | Matrix4x4 | Vector4 | Color | BaseTexture;
        /**
         * get shader data
         * @deprecated
         * @param index uniform ID
         * @returns
         */
        getValueData(index: number): any;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: ShaderData): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
        reset(): void;
        destroy(): void;
    }
    /**
     * <code>ShaderDefine</code> 类用于定义宏数据。
     */
    class ShaderDefine {
        /**
         * 创建一个宏定义的实例
         * @param index 宏索引
         * @param value 宏值
         */
        constructor(index: number, value: number);
    }
    /**
     * <code>ShaderInstance</code> 类用于实现ShaderInstance。
     */
    class ShaderInstance {
        private _renderShaderInstance;
        /**
         * 创建一个 <code>ShaderInstance</code> 实例。
         */
        constructor(shaderProcessInfo: ShaderProcessInfo, shaderPass: ShaderCompileDefineBase);
        /**
         * get complete
         */
        get complete(): boolean;
        protected _webGLShaderLanguageProcess3D(defineString: string[], attributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        }, uniformMap: UniformMapType, VS: ShaderNode, FS: ShaderNode): void;
        protected _webGLShaderLanguageProcess2D(defineString: string[], attributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        }, uniformMap: UniformMapType, VS: ShaderNode, FS: ShaderNode): void;
        private hasSpritePtrID;
        /**
         * @inheritDoc
         * @override
         */
        protected _disposeResource(): void;
        /**
         * apply shader programe
         * @returns
         */
        bind(): boolean;
        /**
         * upload uniform data
         * @param shaderUniform
         * @param shaderDatas
         * @param uploadUnTexture
         */
        uploadUniforms(shaderUniform: CommandEncoder, shaderDatas: ShaderData, uploadUnTexture: boolean): void;
        /**
         * set blend depth stencil RenderState
         * @param shaderDatas
         */
        uploadRenderStateBlendDepth(shaderDatas: ShaderData): void;
        /**
         * set blend depth stencil RenderState frome Shader
         * @param shaderDatas
         */
        uploadRenderStateBlendDepthByShader(shaderDatas: ShaderData): void;
        /**
         * set blend depth stencil RenderState frome Material
         * @param shaderDatas
         */
        uploadRenderStateBlendDepthByMaterial(shaderDatas: ShaderData): void;
    }
    /**
     * <code>ShaderPass</code> 类用于实现ShaderPass。
     */
    class ShaderPass extends ShaderCompileDefineBase {
        /** 优先 ShaderPass 渲染状态 */
        statefirst: boolean;
        /**
         * 渲染状态。
         */
        get renderState(): RenderState;
        constructor(owner: SubShader, compiledObj: IShaderCompiledObj);
    }
    /**
     *  <code>shaderVariable</code> 类用于保存shader变量上传相关信息。
     */
    class ShaderVariable {
        static pointID: number;
        /**
         * 创建一个 <code>shaderVariable</code> 实例。
         */
        constructor();
    }
    /**
     * 着色器变种。
     */
    class ShaderVariant {
        /**
         * 着色器。
         */
        get shader(): Shader3D;
        /**
         * 子着色器索引。
         */
        get subShaderIndex(): number;
        /**
         * 通道索引。
         */
        get passIndex(): number;
        /**
         * 宏定义集合。
         */
        get defineNames(): Readonly<string[]>;
        /**
         * 创建着色器变种。
         * @param shader 着色器
         * @param subShaderIndex 子着色器索引
         * @param passIndex 通道索引
         * @param defines 宏定义集合
         */
        constructor(shader: Shader3D, subShaderIndex: number, passIndex: number, defines: string[]);
        /**
         * 给着色器变种赋值。
         * @param shader 着色器
         * @param subShaderIndex 子着色器索引
         * @param passIndex 通道索引
         * @param defineNames 宏定义集合
         */
        setValue(shader: Shader3D, subShaderIndex: number, passIndex: number, defineNames: string[]): void;
        /**
         * 是否相等。
         * @param other 其它着色器变种
         * @return 是否相等。
         */
        equal(other: ShaderVariant): boolean;
        /**
         * 克隆。
         * @return 着色器变种。
         */
        clone(): ShaderVariant;
    }
    /**
     * 着色器变种集合。
     */
    class ShaderVariantCollection {
        /**
         * 是否已经全部编译。
         */
        get allCompiled(): boolean;
        /**
         * 包含的变种数量。
         */
        get variantCount(): number;
        /**
         * 添加着色器变种。
         * @param variant 着色器变种。
         * @param 是否添加成功。
         */
        add(variant: ShaderVariant): boolean;
        /**
         * 移除着色器变种。
         * @param variant 着色器变种。
         * @return 是否移除成功。
         */
        remove(variant: ShaderVariant): boolean;
        /**
         * 是否包含着色器变种。
         * @param variant 着色器变种。
         */
        contatins(variant: ShaderVariant): boolean;
        /**
         * 通过索引获取着色器变种。
         * @param index 索引。
         * @returns 着色器变种。
         */
        getByIndex(index: number): ShaderVariant;
        /**
         * 清空。
         */
        clear(): void;
        /**
         * 执行编译。
         */
        compile(): void;
    }
    type UniformMapType = {
        [blockName: string]: {
            [uniformName: string]: ShaderDataType;
        } | ShaderDataType;
    };
    type AttributeMapType = {
        [name: string]: [
            number,
            ShaderDataType
        ];
    };
    /**
     * <code>SubShader</code> 类用于创建SubShader。
     */
    class SubShader {
        static IncludeUniformMap: any;
        /**
         * 注册glsl所用到的Uniform
         * 会在生成Uniformmap的时候根据包含的Include文件，添加所需要的uniform因素
         * @param includeName
         * @param uniformInfo
         * @param defaultUniformData
         */
        static regIncludeBindUnifrom(includeName: string, uniformMap: {
            [name: string]: ShaderDataType;
        }, defaultValue: {
            [key: string]: any;
        }): void;
        static readonly DefaultAttributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        /**
         * 创建一个 <code>SubShader</code> 实例。
         * @param	attributeMap  顶点属性表。
         * @param	uniformMap  uniform属性表。
         */
        constructor(attributeMap?: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        }, uniformMap?: UniformMapType, uniformDefaultValue?: {
            [name: string]: ShaderDataItem;
        });
        /**
         * 添加标记。
         * @param key 标记键。
         * @param value 标记值。
         */
        setFlag(key: string, value: string): void;
        /**
         * 获取标记值。
         * @return key 标记键。
         */
        getFlag(key: string): string;
        /**
         * 添加着色器Pass
         * @param vs
         * @param ps
         * @param stateMap
         * @param pipelineMode 渲染管线模式。
         */
        addShaderPass(vs: string, ps: string, pipelineMode?: string): ShaderPass;
        _addShaderPass(compiledObj: IShaderCompiledObj, pipelineMode?: string): ShaderPass;
        private _addIncludeUniform;
    }
    /**
     * ...
     * @author ...
     */
    class VertexMesh {
        /**顶点位置数据 */
        static MESH_POSITION0: number;
        /**顶点顶点色数据 */
        static MESH_COLOR0: number;
        /**顶点UV0数据 */
        static MESH_TEXTURECOORDINATE0: number;
        /**顶点法线数据 */
        static MESH_NORMAL0: number;
        /**顶点切线数据 */
        static MESH_TANGENT0: number;
        /**顶点骨骼索引数据 */
        static MESH_BLENDINDICES0: number;
        /**顶点骨骼权重数据 */
        static MESH_BLENDWEIGHT0: number;
        /**顶点UV1数据 */
        static MESH_TEXTURECOORDINATE1: number;
        /**顶点世界矩阵数据Row0 */
        static MESH_WORLDMATRIX_ROW0: number;
        /**顶点世界矩阵数据Row1 */
        static MESH_WORLDMATRIX_ROW1: number;
        /**顶点世界矩阵数据Row2 */
        static MESH_WORLDMATRIX_ROW2: number;
        /**顶点世界矩阵数据Row3 */
        static MESH_WORLDMATRIX_ROW3: number;
        /**简单数据动画数据 */
        static MESH_SIMPLEANIMATOR: number;
        /**光照贴图的缩放和偏移 */
        static MESH_LIGHTMAPSCALEOFFSET: number;
        /**instanceworld顶点描述 */
        static instanceWorldMatrixDeclaration: VertexDeclaration;
        /**instanceSimple动画数据顶点描述 */
        static instanceSimpleAnimatorDeclaration: VertexDeclaration;
        /**instanceLightMap光照贴图的缩放和偏移顶点描述 */
        static instanceLightMapScaleOffsetDeclaration: VertexDeclaration;
        /**自定义attribute instance 预留位*/
        /**顶点自定义数据0 */
        static MESH_CUSTOME0: number;
        /**顶点自定义数据1 */
        static MESH_CUSTOME1: number;
        /**顶点自定义数据2 */
        static MESH_CUSTOME2: number;
        /**顶点自定义数据3 */
        static MESH_CUSTOME3: number;
        /**
         * 获取顶点声明。
         * @param vertexFlag 顶点声明标记字符,格式为:"POSITION,NORMAL,COLOR,UV,UV1,BLENDWEIGHT,BLENDINDICES,TANGENT"。
         * @return 顶点声明。
         */
        static getVertexDeclaration(vertexFlag: string, compatible?: boolean): VertexDeclaration;
    }
    /**
     * 渲染状态设置命令流
     */
    class RenderStateCommand {
        cmdArray: Map<RenderStateType, any>;
        constructor();
        addCMD(renderstate: RenderStateType, value: number | boolean | Array<number>): void;
        applyCMD(): void;
        clear(): void;
    }
    /**
     * @private
     */
    class RenderStateContext {
        /**
         * 模板写入开关
         * @param gl
         * @param value
         */
        static setStencilMask(value: boolean): void;
    }
    class StencilState {
    }
    class SubUniformBufferData extends UnifromBufferData {
        /**@interanl */
        _isInPool: boolean;
        /**@interanl */
        _needUpdate: boolean;
        /**
         * create UniformBufferData Instance
         * @param uniformParamsStat Params describe
         */
        constructor(uniformParamsStat: Map<number, UniformBufferParamsType>, bufferOffset: number);
    }
    /**
     * 管理
     */
    class UniformBufferBase {
    }
    /**
     *描述UniformBuffer参数类型
     */
    enum UniformBufferParamsType {
        Number = 0,
        Vector2 = 1,
        Vector3 = 2,
        Vector4 = 3,
        Matrix4x4 = 4,
        Vector4Array = 5,
        MatrixArray = 6
    }
    /**
     * 实例化UniformBuffer数据
     * 注：要与glsl中Uniform block结构相同
     */
    class UnifromBufferData {
        /**
         * Buffer Data
         */
        _buffer: Float32Array;
        /**
         * create UniformBufferData Instance
         * @param uniformParamsStat Params describe
         */
        constructor(uniformParamsStat: Map<number, UniformBufferParamsType>);
        /**
         * @interanl
         * layout UniformBuffer pitch std140
         */
        protected _addUniformParams(uniformID: number, value: UniformBufferParamsType, offset: number): number;
        /**
         * @interanl
         * set upload range
         */
        private _setUpdateFlag;
        /**
         * get Buffer byte length
         * @returns
         */
        getbyteLength(): number;
        /**
         * set Vector4Array by paramsName
         * @param name uniform params name
         * @param value vector4Array data
         */
        setVector4Array(name: string, value: Vector4[]): void;
        /**
         * set Vector4Array by paramsIndex
         * @param uniformID uniform params index
         * @param value vector4Array data
         * @returns
         */
        setVector4ArraybyIndex(uniformID: number, value: Vector4[]): void;
        /**
         * set MatrixArray by paramsName
         * @param name uniform params name
         * @param value MatrixArray data
         */
        setMatrixArray(name: string, value: Matrix4x4[]): void;
        /**
         * set MatrixArray by paramsIndex
         * @param uniformID uniform params index
         * @param value MatrixArray data
         * @returns
         */
        setMatrixArraybyIndex(uniformID: number, value: Matrix4x4[]): void;
        /**
         * set Number by paramsName
         * @param name uniform params name
         * @param value Number data
         */
        setNumber(name: string, value: number): void;
        /**
         * set Number by paramsIndex
         * @param uniformID uniform params index
         * @param value Number data
         * @returns
         */
        setNumberbyIndex(uniformID: number, value: number): void;
        /**
         * set Vector2 by paramsName
         * @param name uniform params name
         * @param value Vector2 data
         */
        setVector2(name: string, value: Vector2): void;
        /**
         * set Vector2 by paramsIndex
         * @param uniformID uniform params index
         * @param value Vector2 data
         * @returns
         */
        setVector2byIndex(uniformID: number, value: Vector2): void;
        /**
         * set Vector3 by paramsName
         * @param name uniform params name
         * @param value Vector3 data
         */
        setVector3(name: string, value: Vector3): void;
        /**
         * set Vector3 by uniformID
         * @param uniformID uniform params index
         * @param value Vector3 data
         * @returns
         */
        setVector3byIndex(uniformID: number, value: Vector3): void;
        /**
         * set Vector4 by paramsName
         * @param name uniform params name
         * @param value Vector4 data
         */
        setVector4(name: string, value: Vector4): void;
        /**
         * set Vector4 by paramsIndex
         * @param uniformID uniform params index
         * @param value Vector4 data
         * @returns
         */
        setVector4byIndex(uniformID: number, value: Vector4): void;
        /**
         * set Color by paramsName
         * @param name uniform params name
         * @param value Color data
         */
        setColor(name: string, value: Color): void;
        setColorbyIndex(uniformID: number, value: Color): void;
        /**
         * set Matrix by paramsName
         * @param name uniform params name
         * @param value Matrix data
         */
        setMatrix(name: string, value: Matrix4x4): void;
        /**
         * set Matrix by paramsIndex
         * @param uniformID uniform params index
         * @param value Matrix data
         * @returns
         */
        setMatrixbyIndex(uniformID: number, value: Matrix4x4): void;
        clone(): UnifromBufferData;
        cloneTo(destObject: UnifromBufferData): void;
    }
    /**
     * 类封装WebGL2UniformBufferObect
     */
    class UniformBufferObject extends Buffer {
        static UBONAME_SCENE: string;
        static UBONAME_CAMERA: string;
        static UBONAME_SPRITE3D: string;
        static UBONAME_SHADOW: string;
        private static commonMap;
        /**
         * create Uniform Buffer Base
         * @param name Uniform block name(must pitch Shader)
         * @param bufferUsage config usage
         * @param bytelength byte length
         * @returns
         */
        static create(name: string, bufferUsage: number, bytelength: number, isSingle?: boolean): UniformBufferObject;
        /**
         * get Uniform Buffer by name
         * @param name Uniform block name(must pitch Shader)
         * @returns
         */
        static getBuffer(name: string, index: number): UniformBufferObject;
        /**@interanl */
        _glPointer: number;
        /**buffer name */
        _name: string;
        /**all byte length */
        byteLength: number;
        /**
         * @interanl
         */
        constructor(glPointer: number, name: string, bufferUsage: BufferUsage, byteLength: number, isSingle: boolean);
        /**
         * 重置buffer长度
         * @param bytelength
         */
        _reset(bytelength: number): void;
        /**
         * @inheritDoc
         * @override
         */
        bind(): boolean;
        /**
         * set UniformBuffer data by UniformBufferData
         * @param buffer Float32Array data
         * @param bufferOffset byteOffset
         * @param byteCount  byteCount
         * @returns
         */
        setData(buffer: Float32Array, bufferOffset?: number, byteCount?: number): void;
        /**
         * set UniformBuffer data by UniformBufferData
         * @param bufferData
         */
        setDataByUniformBufferData(bufferData: UnifromBufferData): void;
        /**
         * set Data by subUniformBufferData
         * @param bufferData sub UniformBufferData
         * @param offset
         */
        setDataByByUniformBufferDataOffset(bufferData: SubUniformBufferData, offset: number): void;
        /**
         * @private
         */
        destroy(): void;
    }
    interface VAElement {
        format: string;
        stride: number;
        shaderLocation: number;
    }
    class VertexAttributeLayout {
        static IPoint: number;
        static _pool: {
            [key: number]: VertexAttributeLayout;
        };
        static getVertexLayoutByPool(vertexs: VertexBuffer[]): VertexAttributeLayout;
        /**
         * vertex attribute byte size Array
         */
        attributeByteSize: Array<number>;
        /**
         * vertex Layout des
         */
        VAElements: Array<VAElement[]>;
        instanceMode: Array<boolean>;
        /**
         * pool index
         */
        id: number;
        /**
         * instance one VertexAttributeLayout
         * @param vertexs
         */
        constructor(vertexs: VertexBuffer[]);
    }
    class VertexBuffer extends Buffer {
        private _instanceBuffer;
        /**
         * 获取顶点声明。
         */
        get vertexDeclaration(): VertexDeclaration | null;
        set vertexDeclaration(value: VertexDeclaration | null);
        get instanceBuffer(): boolean;
        set instanceBuffer(value: boolean);
        constructor(targetType: BufferTargetType, bufferUsageType: BufferUsage);
    }
    /**
     * <code>VertexDeclaration</code> 类用于生成顶点声明。
     */
    class VertexDeclaration {
        /**
         * 获取唯一标识ID(通常用于优化或识别)。
         * @return 唯一标识ID
         */
        get id(): number;
        /**
         * 顶点跨度，以字节为单位。
         */
        get vertexStride(): number;
        /**
         * 顶点元素的数量。
         */
        get vertexElementCount(): number;
        /**
         * 创建一个 <code>VertexDeclaration</code> 实例。
         * @param	vertexStride 顶点跨度。
         * @param	vertexElements 顶点元素集合。
         */
        constructor(vertexStride: number, vertexElements: Array<VertexElement>);
        /**
         * 通过索引获取顶点元素。
         * @param index 索引。
         */
        getVertexElementByIndex(index: number): VertexElement;
        /**
         * get vertexElement by usage
         */
        getVertexElementByUsage(usage: number): VertexElement;
    }
    /**
     * <code>Render</code> 是渲染管理类。它是一个单例，可以使用 Laya.render 访问。
     */
    class Render {
        /** 表示是否是 3D 模式。*/
        static is3DMode: boolean;
        /**自定义帧循环 */
        static _customRequestAnimationFrame: any;
        /**帧循环函数 */
        static _loopFunction: any;
        /** 当前的帧数 */
        private static lastFrm;
        /** 第一次运行标记 */
        private _first;
        /** 刚启动的时间。由于微信的rAF不标准，传入的stamp参数不对，因此自己计算一个从启动开始的相对时间 */
        private _startTm;
        static _Render: Render;
        static customRequestAnimationFrame(value: any, loopFun: any): void;
        private static _customEngine;
        static set customRenderEngine(engine: IRenderEngine);
        static get customRenderEngine(): IRenderEngine;
        /**
         * 初始化引擎。
         * @param	width 游戏窗口宽度。
         * @param	height	游戏窗口高度。
         */
        constructor(width: number, height: number, mainCanv: HTMLCanvas);
        /**@private */
        private _timeId;
        /**@private */
        private _onVisibilitychange;
        /**
         * 获取帧对齐的时间。
         * 用这个做动画的时间参数会更平滑。
         * 从render构造开始算起。
         * @returns
         */
        static vsyncTime(): number;
        initRender(canvas: HTMLCanvas, w: number, h: number): boolean;
        /**@private */
        private _enterFrame;
        /** 目前使用的渲染器。*/
        static get context(): Context;
        /** 渲染使用的原生画布引用。 */
        static get canvas(): any;
    }
    /**
     *
     * @author laya
     */
    class RenderInfo {
        /**当前帧的开始时间 */
        static loopStTm: number;
        /**主舞台 <code>Stage</code> 渲染次数计数。 */
        static loopCount: number;
    }
    /**
     * @private
     *
     */
    interface _RenderFunction {
        (sp: Sprite, ctx: Context, x: number, y: number): void;
    }
    /**
     * @private
     * 精灵渲染器
     */
    class RenderSprite {
        /** @private */
        static renders: RenderSprite[];
        /** @private */
        protected static NORENDER: RenderSprite;
        private static _initRenderFun;
        private static _getTypeRender;
        constructor(type: number, next: RenderSprite | null);
        protected onCreate(type: number): void;
        _maskNative(sprite: Sprite, ctx: Context, x: number, y: number): void;
        static tmpTarget(ctx: Context, rt: RenderTexture2D, w: number, h: number): void;
        static recycleTarget(rt: RenderTexture2D): void;
        static setBlendMode(blendMode: string): void;
    }
    /**
    * <code>VertexElement</code> 类用于创建顶点结构分配。
    */
    class VertexElement {
        /**
         * 顶点偏移
         */
        get offset(): number;
        /**
         * 顶点信息名称
         */
        get elementFormat(): string;
        /**
         * 顶点宏标记
         */
        get elementUsage(): number;
        /**
         * 创建顶点结构分配实例
         * @param offset 顶点偏移
         * @param elementFormat 顶点数据格式名称
         * @param elementUsage 顶点宏标记
         */
        constructor(offset: number, elementFormat: string, elementUsage: number);
    }
    /**
     * 类用来定义顶点元素格式
     */
    class VertexElementFormat {
        /**单精度浮点数 */
        static Single: string;
        /**vec2 数据*/
        static Vector2: string;
        /**vec3 数据*/
        static Vector3: string;
        /**vec4 数据 */
        static Vector4: string;
        /**颜色 */
        static Color: string;
        /**字节数组4 */
        static Byte4: string;
        /**字节数组3 */
        static Byte3: string;
        /**字节数组2 */
        static Byte2: string;
        /**字节数组1 */
        static ByteOne: string;
        /**半精度浮点数数组2 */
        static Short2: string;
        /**半精度浮点数数组4 */
        static Short4: string;
        /**归一化半精度浮点数组2 */
        static NormalizedShort2: string;
        /**归一化半精度浮点数组4 */
        static NormalizedShort4: string;
        /**
         * 获取顶点元素格式信息。
         * @param element 元素名称
         * @returns 返回顶点元素信息
         */
        static getElementInfos(element: string): any[];
    }
    /**
     * 此类用来描述资源
     */
    class AssetDb {
        /**
         * 默认资源实例
         */
        static inst: AssetDb;
        /**
         * uuid 数据
         */
        uuidMap: Record<string, string>;
        /**
         * shaderName 数据
         */
        shaderNameMap: Record<string, string>;
        /**
         * 元资源 数据
         */
        metaMap: Record<string, any>;
        /**
         * uuid获得url
         * @param uuid uuid
         * @returns
         */
        UUID_to_URL(uuid: string): string;
        /**
         * 异步uuid获得Url
         * @param uuid
         * @returns
         */
        UUID_to_URL_async(uuid: string): Promise<string>;
        /**
         * Url获得uuid值
         * @param url
         * @returns
         */
        URL_to_UUID_async(url: string): Promise<string>;
        /**
         * 获取真实的Url
         * @param url
         * @param onResolve
         * @returns
         */
        resolveURL(url: string, onResolve?: (url: string) => void): Promise<string>;
        /**
         * 查找shadername的地址
         * @param shaderName
         * @returns
         */
        shaderName_to_URL(shaderName: string): string;
        shaderName_to_URL_async(shaderName: string): Promise<string>;
        /**
         * 获得元数据
         * @param url
         * @param uuid
         * @returns
         */
        getMeta(url: string, uuid: string): Promise<any>;
        /**
         * 获得子资源路径
         * @param url
         * @param uuid
         * @param subAssetName
         * @param subAssetExt
         * @returns
         */
        getSubAssetURL(url: string, uuid: string, subAssetName: string, subAssetExt: string): string;
    }
    /**
     * 大图合集资源
     */
    class AtlasResource extends Resource {
        readonly dir: string;
        readonly textures: Array<Texture>;
        readonly frames: Array<Texture>;
        /**
         * 实例化体格大图合集资源
         * @param dir
         * @param textures
         * @param frames
         */
        constructor(dir: string, textures: Array<Texture>, frames: Array<Texture>);
    }
    /**
     * <code>BaseTexture</code> 纹理的父类，抽象类，不允许实例。
     */
    class BaseTexture extends Resource {
        /**@private */
        protected _width: number;
        /**@private */
        protected _height: number;
        /**
         * 获取宽度。
         */
        get width(): number;
        set width(width: number);
        /***
         * 获取高度。
         */
        get height(): number;
        set height(height: number);
        protected _dimension: TextureDimension;
        /**
         * 纹理几何属性
         */
        get dimension(): TextureDimension;
        protected _format: TextureFormat;
        /**
         * 纹理格式
         */
        get format(): TextureFormat;
        /**
         * 是否生成mipmap
         */
        get mipmap(): boolean;
        get mipmapCount(): number;
        /**
         * 各向异性值
         */
        get anisoLevel(): number;
        set anisoLevel(value: number);
        /**
         * 采样过滤模式
         */
        get filterMode(): FilterMode;
        set filterMode(value: FilterMode);
        /**
         * U方向采样模式
         */
        get wrapModeU(): WrapMode;
        set wrapModeU(value: WrapMode);
        /**
         * V方向采样模式
         */
        get wrapModeV(): WrapMode;
        set wrapModeV(value: WrapMode);
        /**
         * W方向采样模式
         */
        get wrapModeW(): WrapMode;
        set wrapModeW(value: WrapMode);
        /**
         * 贴图压缩格式
         */
        get compareMode(): TextureCompareMode;
        set compareMode(value: TextureCompareMode);
        /**
         * gamma矫正值
         * 如果是1.0  texture2D直接采样就是linear
         */
        get gammaCorrection(): number;
        /**
         * mipmap起始等级
         */
        set baseMipmapLevel(value: number);
        get baseMipmapLevel(): number;
        /**
         * 最大Mipmap等级
         */
        set maxMipmapLevel(value: number);
        get maxMipmapLevel(): number;
        get gammaSpace(): boolean;
        /**
         * 实例化一个纹理
         * @param width 长
         * @param height 宽
         * @param format 格式
         */
        constructor(width: number, height: number, format: number);
        /**
         * 是否是gpu压缩纹理格式
         * @returns
         */
        gpuCompressFormat(): boolean;
        /**
         * 默认贴图
         */
        get defaultTexture(): BaseTexture;
        protected _disposeResource(): void;
    }
    /**
     * @private
     * Context扩展类
     */
    class Context {
        static _SUBMITVBSIZE: number;
        private static _MAXVERTNUM;
        static MAXCLIPRECT: Rectangle;
        static _COUNT: number;
        private static SEGNUM;
        private static _contextcount;
        private _drawTexToDrawTri_Vert;
        private _drawTexToDrawTri_Index;
        private _tempUV;
        private _drawTriUseAbsMatrix;
        static __init__(): void;
        /**@private */
        drawImage(...args: any[]): void;
        /**@private */
        getImageData(...args: any[]): any;
        /**@private */
        measureText(text: string): any;
        /**@private */
        setTransform(...args: any[]): void;
        /**@private */
        $transform(a: number, b: number, c: number, d: number, tx: number, ty: number): void;
        set material(value: Material);
        get material(): Material;
        /**@private */
        get lineJoin(): string;
        /**@private */
        set lineJoin(value: string);
        /**@private */
        get lineCap(): string;
        /**@private */
        set lineCap(value: string);
        /**@private */
        get miterLimit(): string;
        /**@private */
        set miterLimit(value: string);
        /**@private */
        clearRect(x: number, y: number, width: number, height: number): void;
        /**@private */
        /**@private */
        drawTexture2(x: number, y: number, pivotX: number, pivotY: number, m: Matrix, args2: any[]): void;
        transformByMatrix(matrix: Matrix, tx: number, ty: number): void;
        saveTransform(matrix: Matrix): void;
        restoreTransform(matrix: Matrix): void;
        drawRect(x: number, y: number, width: number, height: number, fillColor: any, lineColor: any, lineWidth: number): void;
        alpha(value: number): void;
        drawCurves(x: number, y: number, points: any[], lineColor: any, lineWidth: number): void;
        private _fillAndStroke;
        /**Math.PI*2的结果缓存 */
        static PI2: number;
        /**Math.PI*0.5的结果缓存 */
        static HPI: number;
        static const2DRenderCMD: RenderStateCommand;
        static set2DRenderConfig(): void;
        private _other;
        private _renderNextSubmitIndex;
        private _path;
        private _width;
        private _height;
        private _renderCount;
        meshlist: any[];
        private _transedPoints;
        private _temp4Points;
        private _clipID_Gen;
        private _lastMat_a;
        private _lastMat_b;
        private _lastMat_c;
        private _lastMat_d;
        /**
         * 所cacheAs精灵
         * 对于cacheas bitmap的情况，如果图片还没准备好，需要有机会重画，所以要保存sprite。例如在图片
         * 加载完成后，调用repaint
         */
        sprite: Sprite | null;
        private _fillColor;
        private _flushCnt;
        private defTexture;
        drawTexAlign: boolean;
        isMain: boolean;
        clearColor: Color;
        constructor();
        clearBG(r: number, g: number, b: number, a: number): void;
        /**
         * 释放占用内存
         * @param	keepRT  是否保留rendertarget
         */
        private _releaseMem;
        /**
         * 释放所有资源
         * @param	keepRT  是否保留rendertarget
         */
        destroy(keepRT?: boolean): void;
        clear(): void;
        /**
         * 设置ctx的size，这个不允许直接设置，必须是canvas调过来的。所以这个函数里也不用考虑canvas相关的东西
         * @param	w
         * @param	h
         */
        size(w: number, h: number): void;
        /**
         * 当前canvas请求保存渲染结果。
         * 实现：
         * 如果value==true，就要给_target赋值
         * @param value {Boolean}
         */
        set asBitmap(value: boolean);
        /**
         * 获得当前矩阵的缩放值
         * 避免每次都计算getScaleX
         * @return
         */
        getMatScaleX(): number;
        getMatScaleY(): number;
        getFillColor(): number;
        set fillStyle(value: any);
        get fillStyle(): any;
        set globalAlpha(value: number);
        get globalAlpha(): number;
        set textAlign(value: string);
        get textAlign(): string;
        set textBaseline(value: string);
        get textBaseline(): string;
        set globalCompositeOperation(value: string);
        get globalCompositeOperation(): string;
        set strokeStyle(value: any);
        get strokeStyle(): any;
        translate(x: number, y: number): void;
        set lineWidth(value: number);
        get lineWidth(): number;
        save(): void;
        restore(): void;
        set font(str: string);
        fillText(txt: string | WordText, x: number, y: number, fontStr: string, color: string, align: string, lineWidth?: number, borderColor?: string): void;
        drawText(text: string | WordText, x: number, y: number, font: string, color: string, textAlign: string): void;
        strokeWord(text: string | WordText, x: number, y: number, font: string, color: string, lineWidth: number, textAlign: string): void;
        fillBorderText(txt: string | WordText, x: number, y: number, font: string, color: string, borderColor: string, lineWidth: number, textAlign: string): void;
        filltext11(data: string | WordText, x: number, y: number, fontStr: string, color: string, strokeColor: string, lineWidth: number, textAlign: string): void;
        private _fillRect;
        fillRect(x: number, y: number, width: number, height: number, fillStyle: any): void;
        fillTexture(texture: Texture, x: number, y: number, width: number, height: number, type: string, offset: Point, color: number): void;
        /**
         * 反正只支持一种filter，就不要叫setFilter了，直接叫setColorFilter
         * @param	value
         */
        setColorFilter(filter: ColorFilter): void;
        drawTexture(tex: Texture, x: number, y: number, width: number, height: number, color?: number): void;
        drawTextures(tex: Texture, pos: ArrayLike<number>, tx: number, ty: number, colors: number[]): void;
        submitDebugger(): void;
        private isSameClipInfo;
        drawCallOptimize(enable: boolean): boolean;
        /**
         * 转换4个顶点。为了效率这个不做任何检查。需要调用者的配合。
         * @param	a		输入。8个元素表示4个点
         * @param	out		输出
         */
        transform4Points(a: any[], m: Matrix, out: any[]): void;
        /**
         * pt所描述的多边形完全在clip外边，整个被裁掉了
         * @param	pt
         * @return
         */
        clipedOff(pt: any[]): boolean;
        /**
         * 应用当前矩阵。把转换后的位置放到输出数组中。
         * @param	x
         * @param	y
         * @param	w
         * @param	h
         * @param   italicDeg 倾斜角度，单位是度。0度无，目前是下面不动。以后要做成可调的
         */
        transformQuad(x: number, y: number, w: number, h: number, italicDeg: number, m: Matrix, out: any[]): void;
        pushRT(): void;
        popRT(): void;
        useRT(rt: RenderTexture2D): void;
        /**
         * 异步执行rt的restore函数
         * @param	rt
         */
        RTRestore(rt: RenderTexture2D): void;
        /**
         * 强制拒绝submit合并
         * 例如切换rt的时候
         */
        breakNextMerge(): void;
        private _repaintSprite;
        /**
         *
         * @param	tex
         * @param	x
         * @param	y
         * @param	width
         * @param	height
         * @param	transform	图片本身希望的矩阵
         * @param	tx			节点的位置
         * @param	ty
         * @param	alpha
         */
        drawTextureWithTransform(tex: Texture, x: number, y: number, width: number, height: number, transform: Matrix | null, tx: number, ty: number, alpha: number, blendMode: string | null, uv?: number[], color?: number): void;
        /**
         * * 把ctx中的submits提交。结果渲染到target上
         * @param	ctx
         * @param	target
         */
        private _flushToTarget;
        drawCanvas(canvas: HTMLCanvas, x: number, y: number, width: number, height: number): void;
        drawTarget(rt: RenderTexture2D, x: number, y: number, width: number, height: number, m: Matrix, shaderValue: Value2D, uv?: ArrayLike<number> | null, blend?: number, color?: number): boolean;
        drawTriangles(tex: Texture, x: number, y: number, vertices: Float32Array, uvs: Float32Array, indices: Uint16Array, matrix: Matrix, alpha: number, blendMode: string, colorNum?: number): void;
        transform(a: number, b: number, c: number, d: number, tx: number, ty: number): void;
        setTransformByMatrix(value: Matrix): void;
        rotate(angle: number): void;
        scale(scaleX: number, scaleY: number): void;
        clipRect(x: number, y: number, width: number, height: number, escape?: boolean): void;
        addRenderObject(o: ISubmit): void;
        /**
         *
         * @param	start
         * @param	end
         */
        submitElement(start: number, end: number): number;
        flush(): number;
        /*******************************************start矢量绘制***************************************************/
        beginPath(convex?: boolean): void;
        closePath(): void;
        /**
         * 添加一个path。
         * @param	points [x,y,x,y....]	这个会被保存下来，所以调用者需要注意复制。
         * @param	close	是否闭合
         * @param   convex 是否是凸多边形。convex的优先级是这个最大。fill的时候的次之。其实fill的时候不应该指定convex，因为可以多个path
         * @param	dx  需要添加的平移。这个需要在应用矩阵之前应用。
         * @param	dy
         */
        addPath(points: any[], close: boolean, convex: boolean, dx: number, dy: number): void;
        fill(): void;
        private addVGSubmit;
        stroke(): void;
        moveTo(x: number, y: number): void;
        /**
         *
         * @param	x
         * @param	y
         * @param	b 是否应用矩阵
         */
        lineTo(x: number, y: number): void;
        arcTo(x1: number, y1: number, x2: number, y2: number, r: number): void;
        arc(cx: number, cy: number, rx: number, ry: number, startAngle: number, endAngle: number, counterclockwise?: boolean, b?: boolean, minNum?: number): void;
        quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;
        /**
         * 把颜色跟当前设置的alpha混合
         * @return
         */
        mixRGBandAlpha(color: number): number;
        strokeRect(x: number, y: number, width: number, height: number, parameterLineWidth: number): void;
        clip(): void;
        /*******************************************end矢量绘制***************************************************/
        drawParticle(x: number, y: number, pt: any): void;
        private _getPath;
        /**获取canvas*/
        get canvas(): HTMLCanvas;
        private static tmpuv1;
        /**
         * 专用函数。通过循环创建来水平填充
         * @param	tex
         * @param	bmpid
         * @param	uv		希望循环的部分的uv
         * @param	oriw
         * @param	orih
         * @param	x
         * @param	y
         * @param	w
         */
        private _fillTexture_h;
        /**
         * 专用函数。通过循环创建来垂直填充
         * @param	tex
         * @param	imgid
         * @param	uv
         * @param	oriw
         * @param	orih
         * @param	x
         * @param	y
         * @param	h
         */
        private _fillTexture_v;
        private static tmpUV;
        private static tmpUVRect;
        drawTextureWithSizeGrid(tex: Texture, tx: number, ty: number, width: number, height: number, sizeGrid: any[], gx: number, gy: number, color: number): void;
        addRenderObject3D(scene3D: ISubmit): void;
    }
    class Prefab extends Resource {
        readonly version: number;
        protected _deps: Array<Resource>;
        /**@private */
        json: any;
        constructor(version?: number);
        /**
         * 创建实例
         */
        create(options?: Record<string, any>, errors?: Array<any>): Node;
        get deps(): ReadonlyArray<Resource>;
        addDep(res: Resource): void;
        addDeps(resArr: Array<Resource>): void;
        protected _disposeResource(): void;
        get obsolute(): boolean;
        set obsolute(value: boolean);
        private onDepObsolute;
    }
    type HierarchyResource = Prefab;
    var HierarchyResource: typeof Prefab;
    /**
     * <code>HTMLCanvas</code> 是 Html Canvas 的代理类，封装了 Canvas 的属性和方法。
     */
    class HTMLCanvas extends Resource {
        private _ctx;
        /**@private */
        protected _width: number;
        /**@private */
        protected _height: number;
        /**
         * @inheritDoc
         */
        get source(): HTMLCanvasElement;
        /**
         * 获取宽度。
         */
        get width(): number;
        set width(width: number);
        /***
         * 获取高度。
         */
        get height(): number;
        set height(height: number);
        /**
         * 根据指定的类型，创建一个 <code>HTMLCanvas</code> 实例。
         */
        constructor(createCanvas?: boolean);
        /**
         * 清空画布内容。
         */
        clear(): void;
        /**
         * 销毁。
         * @override
         */
        destroy(): void;
        /**
         * 释放。
         */
        release(): void;
        /**
         * Canvas 渲染上下文。
         */
        get context(): Context;
        /**
         * 获取 Canvas 渲染上下文。
         * @param	contextID 上下文ID.
         * @param	other
         * @return  Canvas 渲染上下文 Context 对象。
         */
        getContext(contextID: string, other?: any): Context;
        /**
         * 获取内存大小。
         * @return 内存大小。
         */
        getMemSize(): number;
        /**
         * 设置宽高。
         * @param	w 宽度。
         * @param	h 高度。
         */
        size(w: number, h: number): void;
        /**
         * 获取texture实例
         */
        getTexture(): Texture | null | RenderTexture2D;
        /**
         * 把图片转换为base64信息
         * @param	type "image/png"
         * @param	encoderOptions	质量参数，取值范围为0-1
         */
        toBase64(type: string, encoderOptions: number): string | null;
        /**
         * native多线程转图片
         * @param type
         * @param encoderOptions
         * @param callBack
         */
        toBase64Async(type: string, encoderOptions: number, callBack: Function): void;
    }
    enum MaterialRenderMode {
        /**渲染状态_不透明。*/
        RENDERMODE_OPAQUE = 0,
        /**渲染状态_阿尔法测试。*/
        RENDERMODE_CUTOUT = 1,
        /**渲染状态__透明。*/
        RENDERMODE_TRANSPARENT = 2,
        /**渲染状态__加色法混合。*/
        RENDERMODE_ADDTIVE = 3,
        /**渲染状态_透明混合。*/
        RENDERMODE_ALPHABLENDED = 4,
        /**渲染状态_自定义 */
        RENDERMODE_CUSTOME = 5
    }
    /**
     * <code>Material</code> 类用于创建材质。
     */
    class Material extends Resource implements IClone {
        /** 渲染队列_不透明。*/
        static RENDERQUEUE_OPAQUE: number;
        /** 渲染队列_阿尔法裁剪。*/
        static RENDERQUEUE_ALPHATEST: number;
        /** 渲染队列_透明。*/
        static RENDERQUEUE_TRANSPARENT: number;
        /**着色器变量,透明测试值。*/
        static ALPHATESTVALUE: number;
        /**材质级着色器宏定义,透明测试。*/
        static SHADERDEFINE_ALPHATEST: ShaderDefine;
        static SHADERDEFINE_MAINTEXTURE: ShaderDefine;
        static SHADERDEFINE_ADDTIVEFOG: ShaderDefine;
        /**
         * 加载材质。
         * @param url 材质地址。
         * @param complete 完成回掉。
         */
        static load(url: string, complete: Handler): void;
        /** @private */
        _shaderValues: ShaderData | null;
        /** 所属渲染队列. */
        renderQueue: number;
        /**
         * 着色器数据。
         */
        get shaderData(): ShaderData;
        /**
         * 透明测试模式裁剪值。
         */
        get alphaTestValue(): number;
        set alphaTestValue(value: number);
        /**
         * 是否透明裁剪。
         */
        get alphaTest(): boolean;
        set alphaTest(value: boolean);
        /**
         * 增加Shader宏定义。
         * @param value 宏定义。
         */
        addDefine(define: ShaderDefine): void;
        /**
         * 移除Shader宏定义。
         * @param value 宏定义。
         */
        removeDefine(define: ShaderDefine): void;
        /**
         * 开启 或 关闭 shader 宏定义
         * @param define
         * @param value true: addDefine, false: removeDefine
         */
        setDefine(define: ShaderDefine, value: boolean): void;
        /**
         * 是否包含Shader宏定义。
         * @param value 宏定义。
         */
        hasDefine(define: ShaderDefine): boolean;
        /**
         * 是否写入深度。
         */
        get depthWrite(): boolean;
        set depthWrite(value: boolean);
        /**
         * 剔除方式。
         */
        get cull(): number;
        set cull(value: number);
        /**
         * 混合方式。
         */
        get blend(): number;
        set blend(value: number);
        /**
         * 混合源。
         */
        get blendSrc(): number;
        set blendSrc(value: number);
        /**
         * 混合目标。
         */
        get blendDst(): number;
        set blendDst(value: number);
        /**
         * 混合目标 alpha
         */
        get blendSrcAlpha(): number;
        set blendSrcAlpha(value: number);
        /**
         * 混合原 RGB
         */
        get blendSrcRGB(): number;
        /**
         * 混合原 RGB
         */
        set blendSrcRGB(value: number);
        get blendDstRGB(): number;
        set blendDstRGB(value: number);
        /**
         * 混合目标 alpha
         */
        get blendDstAlpha(): number;
        set blendDstAlpha(value: number);
        /**
         * 混合方程
         */
        get blendEquation(): number;
        set blendEquation(value: number);
        /**
         * 混合方式 RGB
         */
        get blendEquationRGB(): number;
        set blendEquationRGB(value: number);
        /**
         * 混合方式 Alpha
         */
        get blendEquationAlpha(): number;
        set blendEquationAlpha(value: number);
        /**
         * 深度测试方式。
         */
        get depthTest(): number;
        set depthTest(value: number);
        /**
         * 模板测试方式
         */
        get stencilTest(): number;
        set stencilTest(value: number);
        /**
         * 是否写入模板。
         */
        get stencilWrite(): boolean;
        set stencilWrite(value: boolean);
        /**
         * 写入模板值
         */
        set stencilRef(value: number);
        get stencilRef(): number;
        /** */
        /**
         * 写入模板测试设置
         * vector(fail, zfail, zpass)
         */
        set stencilOp(value: Vector3);
        get stencilOp(): Vector3;
        /**
         * 获得材质属性
         */
        get MaterialProperty(): any;
        /**
         * 获得材质宏
         */
        get MaterialDefine(): Array<string>;
        /**
         * 渲染模式。
         */
        set materialRenderMode(value: MaterialRenderMode);
        /**
         * 获得材质渲染状态
         */
        get materialRenderMode(): MaterialRenderMode;
        /**
         * 创建一个 <code>Material</code> 实例。
         */
        constructor();
        /**
         * @inheritDoc
         * @override
         */
        protected _disposeResource(): void;
        get shader(): Shader3D;
        /**
         * get all material uniform property
         * @returns
         */
        effectiveProperty(): Map<string, ShaderDataType>;
        /**
         * 设置使用Shader名字。
         * @param name 名称。
         */
        setShaderName(name: string): void;
        /**
         * 获得bool属性值
         * @param uniformIndex 属性索引
         * @returns
         */
        getBoolByIndex(uniformIndex: number): boolean;
        /**
         * 设置bool值
         * @param uniformIndex 属性索引
         * @param value 值
         */
        setBoolByIndex(uniformIndex: number, value: boolean): void;
        /**
         * 活得bool值
         * @param name 属性名称
         * @returns
         */
        getBool(name: string): boolean;
        /**
         * 设置bool值
         * @param name 属性名称
         * @param value 值
         */
        setBool(name: string, value: boolean): void;
        /**
         * 获得Float值
         * @param uniformIndex 属性索引
         * @returns
         */
        getFloatByIndex(uniformIndex: number): number;
        /**
         * 设置Float值
         * @param uniformIndex 属性索引
         * @param value 值
         */
        setFloatByIndex(uniformIndex: number, value: number): void;
        /**
         * 获得Float值
         * @param name 属性名称
         * @returns
         */
        getFloat(name: string): number;
        /**
         * 设置Float值
         * @param name 属性名称
         * @param value 值
         */
        setFloat(name: string, value: number): void;
        /**
         * 获得Int值
         * @param uniformIndex 属性索引
         * @returns
         */
        getIntByIndex(uniformIndex: number): number;
        /**
         * 设置Int值
         * @param uniformIndex 属性索引
         * @param value 值
         */
        setIntByIndex(uniformIndex: number, value: number): void;
        /**
         * 获得Int值
         * @param name 属性名称
         * @returns
         */
        getInt(name: string): number;
        /**
         * 设置Int值
         * @param name 属性名称
         * @param value 值
         */
        setInt(name: string, value: number): void;
        /**
         * 获得Vector2
         * @param uniformIndex 属性索引
         * @returns
         */
        getVector2ByIndex(uniformIndex: number): Vector2;
        /**
         * 设置Vector2
         * @param uniformIndex 属性索引
         * @param value 值
         */
        setVector2ByIndex(uniformIndex: number, value: Vector2): void;
        /**
         * 获得Vector2
         * @param name 属性名称
         * @returns
         */
        getVector2(name: string): Vector2;
        /**
         * 设置Vector2
         * @param name 属性名称
         * @param value 值
         */
        setVector2(name: string, value: Vector2): void;
        /**
         * 获得Vector3
         * @param uniformIndex 属性索引
         * @returns
         */
        getVector3ByIndex(uniformIndex: number): Vector3;
        /**
         * 设置Vector3
         * @param uniformIndex 属性索引
         * @param value 值
         */
        setVector3ByIndex(uniformIndex: number, value: Vector3): void;
        /**
         * 获得Vector3
         * @param name 属性名称
         * @returns
         */
        getVector3(name: string): Vector3;
        /**
         * 设置Vector3
         * @param name 属性名称
         * @param value 值
         */
        setVector3(name: string, value: Vector3): void;
        /**
         * 获得Vector4
         * @param uniformIndex 属性索引
         * @param value 值
         */
        setVector4ByIndex(uniformIndex: number, value: Vector4): void;
        /**
         * 设置Vector4
         * @param uniformIndex 属性索引
         * @returns
         */
        getVector4ByIndex(uniformIndex: number): Vector4;
        /**
         * 设置Vector4
         * @param name 属性名称
         * @param value 值
         */
        setVector4(name: string, value: Vector4): void;
        /**
         * 获得Vector4
         * @param name 属性名称
         * @returns
         */
        getVector4(name: string): Vector4;
        /**
         * 获得Color
         * @param uniformIndex 属性索引
         * @returns
         */
        getColorByIndex(uniformIndex: number): Color;
        /**
         * 设置Color
         * @param uniformIndex 属性索引
         * @param value 值
         */
        setColorByIndex(uniformIndex: number, value: Color): void;
        /**
         * 获得Color
         * @param name 属性名称
         * @returns
         */
        getColor(name: string): Color;
        /**
         * 设置Color
         * @param name 属性名称
         * @param value 值
         */
        setColor(name: string, value: Color): void;
        /**
         * 获得Matrix4x4
         * @param uniformIndex 属性索引
         * @returns
         */
        getMatrix4x4ByIndex(uniformIndex: number): Matrix4x4;
        /**
         * 设置Matrix4x4
         * @param uniformIndex 属性索引
         * @param value 值
         */
        setMatrix4x4ByIndex(uniformIndex: number, value: Matrix4x4): void;
        /**
         * 获得Matrix4x4
         * @param name 属性名称
         * @returns
         */
        getMatrix4x4(name: string): Matrix4x4;
        /**
         * 设置Matrix4x4
         * @param name 属性名称
         * @param value 值
         */
        setMatrix4x4(name: string, value: Matrix4x4): void;
        /**
         * 获取 matrix3x3
         * @param index
         * @returns
         */
        getMatrix3x3ByIndex(index: number): Matrix3x3;
        /**
         * 设置 matrix3x3
         * @param index
         * @param value
         */
        setMatrix3x3ByIndex(index: number, value: Matrix3x3): void;
        /**
         * 获取 matrix3x3
         * @param name
         * @returns
         */
        getMatrix3x3(name: string): Matrix3x3;
        /**
         * 设置 matrix3x3
         * @param name
         * @param value
         */
        setMatrix3x3(name: string, value: Matrix3x3): void;
        /**
         * 设置纹理
         * @param uniformIndex 属性索引
         * @param texture
         */
        setTextureByIndex(uniformIndex: number, texture: BaseTexture): void;
        private reSetTexture;
        /**
         * 获得纹理
         * @param uniformIndex 属性索引
         * @returns
         */
        getTextureByIndex(uniformIndex: number): BaseTexture;
        /**
         * 设置纹理
         * @param name 属性名称
         * @param texture
         */
        setTexture(name: string, texture: BaseTexture): void;
        /**
         * 获得纹理
         * @param name 属性名称
         * @returns
         */
        getTexture(name: string): BaseTexture;
        /**
         * 获得Buffer
         * @param uniformIndex 属性索引
         * @returns
         */
        getBufferByIndex(uniformIndex: number): Float32Array;
        /**
         * 设置Buffer
         * @param uniformIndex 属性索引
         * @param value 值
         */
        setBufferByIndex(uniformIndex: number, value: Float32Array): void;
        /**
         * 获得Buffer
         * @param name 属性名称
         * @returns
         */
        getBuffer(name: string): Float32Array;
        /**
         * 设置Buffer
         * @param name 属性名称
         * @param value 值
         */
        setBuffer(name: string, value: Float32Array): void;
        /**
         * 设置ShaderData的属性值
         * @param uniformIndex 属性索引
         * @param type 值类型
         * @param value 值
         */
        setShaderDataByIndex(uniformIndex: number, type: ShaderDataType, value: ShaderDataItem): void;
        /**
         * 设置ShaderData的属性值
         * @param name 属性名称
         * @param type 值类型
         * @param value 值
         */
        setShaderData(name: string, type: ShaderDataType, value: ShaderDataItem): void;
        /**
         * 获得ShaderData的属性值
         * @param name 属性名称
         * @param type 值类型
         * @returns
         */
        getShaderData(name: string, type: ShaderDataType): ShaderDataItem;
        /**
         * 获得ShaderData的属性值
         * @param uniformIndex 属性索引
         * @param type 值类型
         * @returns
         */
        getShaderDataByIndex(uniformIndex: number, type: ShaderDataType): ShaderDataItem;
        /**
         * 克隆。
         * @param	destObject 克隆源。
         */
        cloneTo(destObject: any): void;
        /**
         * 克隆。
         * @return	 克隆副本。
         */
        clone(): any;
        /**
         * 设置属性值
         * @deprecated
         * @param name
         * @param value
         */
        setShaderPropertyValue(name: string, value: any): void;
        /**
         * 获取属性值
         * @deprecated
         * @param name
         */
        getShaderPropertyValue(name: string): any;
        get _defineDatas(): DefineDatas;
        /**
         * override it
         */
        oldparseEndEvent(): void;
    }
    /**
     * <code>RenderTexture</code> 类用于创建渲染目标。
     */
    class NativeRenderTexture2D extends BaseTexture implements IRenderTarget {
        /** @private */
        private static _currentActive;
        private static _clearColor;
        private _lastRT;
        private _lastWidth;
        private _lastHeight;
        private static rtStack;
        static defuv: any[];
        static flipyuv: any[];
        /**
         * 获取当前激活的Rendertexture
         */
        static get currentActive(): NativeRenderTexture2D;
        /** @private */
        private _depthStencilFormat;
        private _colorFormat;
        /**
         * 获取深度格式。
         *@return 深度格式。
         */
        get depthStencilFormat(): number;
        /**
         * @inheritDoc
         * @override
         */
        get defaultTexture(): BaseTexture;
        getIsReady(): boolean;
        /**
         * 获取宽度。
         */
        get sourceWidth(): number;
        /***
         * 获取高度。
         */
        get sourceHeight(): number;
        /**
         * 获取offsetX。
         */
        get offsetX(): number;
        /***
         * 获取offsetY
         */
        get offsetY(): number;
        depthStencilTexture: BaseTexture;
        _renderTarget: InternalRenderTarget;
        _isCameraTarget: boolean;
        private _nativeObj;
        /**
         * @param width  宽度。
         * @param height 高度。
         * @param format 纹理格式。
         * @param depthStencilFormat 深度格式。
         * 创建一个 <code>RenderTexture</code> 实例。
         */
        constructor(width: number, height: number, format?: number, depthStencilFormat?: number, create?: boolean);
        get isCube(): boolean;
        get samples(): number;
        get generateMipmap(): boolean;
        _start(): void;
        _end(): void;
        _create(): void;
        /**
         * 保存当前的RT信息。
         */
        static pushRT(): void;
        /**
         * 恢复上次保存的RT信息
         */
        static popRT(): void;
        /**
         * 开始绑定。
         */
        start(): void;
        /**
         * 结束绑定。
         */
        end(): void;
        /**
         * 恢复上一次的RenderTarge.由于使用自己保存的，所以如果被外面打断了的话，会出错。
         */
        restore(): void;
        clear(r?: number, g?: number, b?: number, a?: number): void;
        /**
         * 获得像素数据。
         * @param x X像素坐标。
         * @param y Y像素坐标。
         * @param width 宽度。
         * @param height 高度。
         * @return 像素数据。
         */
        getData(x: number, y: number, width: number, height: number): ArrayBufferView;
        recycle(): void;
    }
    /**
     * 层次结构分析器API
     */
    interface IHierarchyParserAPI {
        /**收集资源链接 */
        collectResourceLinks: (data: any, basePath: string) => (string | ILoadURL)[];
        /**解析 */
        parse: (data: any, options?: Record<string, any>, errors?: Array<any>) => Array<Node> | Node;
    }
    /**
     * 预制体导入
     */
    class PrefabImpl extends Prefab {
        /**数据 */
        data: any;
        /**层次结构API */
        api: IHierarchyParserAPI;
        /**
         * 实例化一个预制体
         * @param api 层次结构API
         * @param data 数据
         * @param version 版本
         */
        constructor(api: IHierarchyParserAPI, data: any, version: number);
        /**
         * 创建一个
         * @param options
         * @param errors
         * @returns
         */
        create(options?: Record<string, any>, errors?: any[]): Node;
    }
    class RenderTexture extends BaseTexture implements IRenderTarget {
        protected static _currentActive: RenderTexture;
        static get currentActive(): RenderTexture;
        protected static _configInstance: any;
        static configRenderContextInstance(value: any): void;
        private static _pool;
        private static _poolMemory;
        /**
         * 创建一个RenderTexture
         * @param width
         * @param height
         * @param colorFormat
         * @param depthFormat
         * @param mipmap
         * @param multiSamples
         * @param depthTexture
         * @param sRGB
         * @returns
         */
        static createFromPool(width: number, height: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat, mipmap?: boolean, multiSamples?: number, depthTexture?: boolean, sRGB?: boolean): RenderTexture;
        static recoverToPool(rt: RenderTexture): void;
        static clearPool(): void;
        /**
         * 绑定到主画布上的RenderTexture
         */
        static get bindCanvasRender(): RenderTexture;
        static set bindCanvasRender(value: RenderTexture);
        _inPool: boolean;
        _isCameraTarget: boolean;
        _renderTarget: InternalRenderTarget;
        private _generateDepthTexture;
        get generateDepthTexture(): boolean;
        set generateDepthTexture(value: boolean);
        private _depthStencilTexture;
        get depthStencilTexture(): BaseTexture;
        _generateMipmap: boolean;
        get colorFormat(): RenderTargetFormat;
        protected _depthStencilFormat: RenderTargetFormat;
        get depthStencilFormat(): RenderTargetFormat;
        protected _multiSamples: number;
        get multiSamples(): number;
        get isCube(): boolean;
        get samples(): number;
        get generateMipmap(): boolean;
        /**
         * @param width
         * @param height
         * @param colorFormat
         * @param depthFormat
         * @param generateMipmap
         * @param multiSamples
         * @param generateDepthTexture
         * @param sRGB
         */
        constructor(width: number, height: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat, generateMipmap?: boolean, multiSamples?: number, generateDepthTexture?: boolean, sRGB?: boolean);
        _createRenderTarget(): void;
        _start(): void;
        _end(): void;
        getData(xOffset: number, yOffset: number, width: number, height: number, out: Uint8Array | Float32Array): Uint8Array | Float32Array;
        protected _disposeResource(): void;
    }
    /**
     * <code>RenderTexture</code> 类用于创建渲染目标。
     */
    class RenderTexture2D extends BaseTexture implements IRenderTarget {
        /** @private */
        private static _currentActive;
        static _clearColor: Color;
        static _clearLinearColor: Color;
        private _lastRT;
        private _lastWidth;
        private _lastHeight;
        private static rtStack;
        /**
         * 默认uv
         */
        static defuv: any[];
        /**
         * 默认翻转uv
         */
        static flipyuv: any[];
        /**
         * 获取当前激活的Rendertexture
         */
        static get currentActive(): RenderTexture2D;
        /** @private */
        private _depthStencilFormat;
        /** @private */
        private _colorFormat;
        /**
         * 获取深度格式。
         *@return 深度格式。
         */
        get depthStencilFormat(): number;
        /**
         * @inheritDoc
         * @override
         */
        get defaultTexture(): BaseTexture;
        /**
         * RenderTexture2D是否准备好
         * @returns
         */
        getIsReady(): boolean;
        /**
         * 获取宽度。
         */
        get sourceWidth(): number;
        /***
         * 获取高度。
         */
        get sourceHeight(): number;
        /**
         * 获取offsetX。
         */
        get offsetX(): number;
        /***
         * 获取offsetY
         */
        get offsetY(): number;
        /**深度模板纹理 */
        depthStencilTexture: BaseTexture;
        _renderTarget: InternalRenderTarget;
        /**是否是CameraTarget */
        _isCameraTarget: boolean;
        /**
         * @param width  宽度。
         * @param height 高度。
         * @param format 纹理格式。
         * @param depthStencilFormat 深度格式。
         * 创建一个 <code>RenderTexture</code> 实例。
         */
        constructor(width: number, height: number, format?: RenderTargetFormat, depthStencilFormat?: RenderTargetFormat);
        /**是否是RTCube */
        get isCube(): boolean;
        /**采样 */
        get samples(): number;
        /**
         * 是否生成Mipmap
         */
        get generateMipmap(): boolean;
        /**
         * 保存当前的RT信息。
         */
        static pushRT(): void;
        /**
         * 恢复上次保存的RT信息
         */
        static popRT(): void;
        /**
         * 开始绑定。
         */
        start(): void;
        /**
         * 结束绑定。
         */
        end(): void;
        /**
         * 恢复上一次的RenderTarge.由于使用自己保存的，所以如果被外面打断了的话，会出错。
         */
        restore(): void;
        /**
         * 清理RT
         * @param r
         * @param g
         * @param b
         * @param a
         */
        clear(r?: number, g?: number, b?: number, a?: number): void;
        /**
         * 获得像素数据。
         * @param x X像素坐标。
         * @param y Y像素坐标。
         * @param width 宽度。
         * @param height 高度。
         * @return 像素数据。
         */
        getData(x: number, y: number, width: number, height: number): ArrayBufferView;
    }
    /**
     * <code>SpotLight</code> 类用于创建RenderTextureCube。
     */
    class RenderTextureCube extends RenderTexture {
        /**
         * +x, -x, +y, -y, +z, -z
         */
        faceIndex: number;
        /**
         * 实例化一个RendertextureCube
         * @param size 像素
         * @param colorFormat 颜色格式
         * @param depthFormat 深度格式
         * @param generateMipmap 是否生成mipmap
         * @param multiSamples
         */
        constructor(size: number, colorFormat: RenderTargetFormat, depthFormat: RenderTargetFormat, generateMipmap: boolean, multiSamples: number);
        _start(): void;
    }
    /**
     * <code>Resource</code> 资源存取类。
     */
    class Resource extends EventDispatcher {
        /** @private */
        static _idResourcesMap: any;
        /** @private 以字节为单位。*/
        private static _cpuMemory;
        /** @private 以字节为单位。*/
        private static _gpuMemory;
        /**是否开启debug模式 */
        static DEBUG: boolean;
        /**
         * 当前内存，以字节为单位。
         */
        static get cpuMemory(): number;
        /**
         * 当前显存，以字节为单位。
         */
        static get gpuMemory(): number;
        /**
         * 销毁当前没有被使用的资源,该函数会忽略lock=true的资源。
         */
        static destroyUnusedResources(): void;
        /** @private */
        private static _destroyUnusedResources;
        private _cpuMemory;
        private _gpuMemory;
        _id: number;
        protected _destroyed?: boolean;
        protected _referenceCount: number;
        protected _obsolute: boolean;
        /**是否加锁，如果true为不能使用自动释放机制。*/
        lock?: boolean;
        /**名称。 */
        name?: string;
        /**获取资源的URL地址。 */
        url: string;
        /**获取资源的UUID。 */
        uuid: string;
        /**是否在引用计数为0的时候立马删除他 */
        destroyedImmediately: boolean;
        /**
         * 获取唯一标识ID,通常用于识别。
         */
        get id(): number;
        /**
         * 内存大小。
         */
        get cpuMemory(): number;
        /**
         * 显存大小。
         */
        get gpuMemory(): number;
        /**
         * 是否已销毁。
         */
        get destroyed(): boolean;
        /** 如果设置一个已缓存的资源obsolute为true，则
         * 1）getRes仍然可以返回这个资源；
         * 2）下次加载时会忽略这个缓存而去重新加载。。
         */
        get obsolute(): boolean;
        set obsolute(value: boolean);
        /**
         * 获取资源的引用计数。
         */
        get referenceCount(): number;
        /**
         * 创建一个 <code>Resource</code> 实例。
         * @param managed 如果设置为true，则在destroyUnusedResources时会检测引用计数并自动释放如果计数为0。默认为true。
         */
        protected constructor(managed?: boolean);
        _setCPUMemory(value: number): void;
        _setGPUMemory(value: number): void;
        _setCreateURL(url: string, uuid?: string): void;
        /**
         * 返回资源是否从指定url创建
         */
        isCreateFromURL(url: string): boolean;
        _addReference(count?: number): void;
        _removeReference(count?: number): void;
        /**
         * 清除引用
         */
        _clearReference(): void;
        protected _recoverResource(): void;
        protected _disposeResource(): void;
        protected _activeResource(): void;
        /**
         * 销毁资源,销毁后资源不能恢复。
         */
        destroy(): void;
    }
    /**
     * 文字资源格式
     */
    enum TextResourceFormat {
        /**Buffer */
        Buffer = 0,
        /**TODO */
        Plain = 1,
        /**Json */
        JSON = 2,
        /**XML */
        XML = 3
    }
    /**
     * 文字资源
     */
    class TextResource extends Resource {
        /**数据 */
        readonly data: any;
        /**格式 */
        readonly format: TextResourceFormat;
        /**
         * 实例化文字资源
         * @param data
         * @param format
         */
        constructor(data: any, format: TextResourceFormat);
    }
    /**
     * <code>Texture</code> 是一个纹理处理类。
     */
    class Texture extends Resource {
        /**@private 默认 UV 信息。*/
        static readonly DEF_UV: Float32Array;
        /**@private */
        static readonly NO_UV: Float32Array;
        /**@private 反转 UV 信息。*/
        static readonly INV_UV: Float32Array;
        /**@private uv的范围*/
        uvrect: number[];
        /**@private */
        private _bitmap;
        /** @private */
        private _w;
        /** @private */
        private _h;
        /**沿 X 轴偏移量。*/
        offsetX: number;
        /**沿 Y 轴偏移量。*/
        offsetY: number;
        /**原始宽度（包括被裁剪的透明区域）。*/
        sourceWidth: number;
        /**原始高度（包括被裁剪的透明区域）。*/
        sourceHeight: number;
        /**图片地址*/
        url: string;
        /** UUID */
        uuid: string;
        /** @private */
        scaleRate: number;
        /**九宫格*/
        _sizeGrid?: Array<number>;
        /**状态数量*/
        _stateNum?: number;
        /**
         *  根据指定资源和坐标、宽高、偏移量等创建 <code>Texture</code> 对象。
         * @param	source 绘图资源 Texture2D 或者 Texture对象。
         * @param	x 起始绝对坐标 x 。
         * @param	y 起始绝对坐标 y 。
         * @param	width 宽绝对值。
         * @param	height 高绝对值。
         * @param	offsetX X 轴偏移量（可选）。	就是[x,y]相对于原始小图片的位置。一般都是正的，表示裁掉了空白边的大小，如果是负的一般表示加了保护边
         * @param	offsetY Y 轴偏移量（可选）。
         * @param	sourceWidth 原始宽度，包括被裁剪的透明区域（可选）。
         * @param	sourceHeight 原始高度，包括被裁剪的透明区域（可选）。
         * @return  <code>Texture</code> 对象。
         */
        static create(source: Texture | BaseTexture, x: number, y: number, width: number, height: number, offsetX?: number, offsetY?: number, sourceWidth?: number, sourceHeight?: number): Texture;
        /**
         * 截取Texture的一部分区域，生成新的Texture，如果两个区域没有相交，则返回null。
         * @param	texture	目标Texture。
         * @param	x		相对于目标Texture的x位置。
         * @param	y		相对于目标Texture的y位置。
         * @param	width	截取的宽度。
         * @param	height	截取的高度。
         * @return 返回一个新的Texture。
         */
        static createFromTexture(texture: Texture, x: number, y: number, width: number, height: number): Texture;
        /**
         * uv
         */
        get uv(): ArrayLike<number>;
        set uv(value: ArrayLike<number>);
        /** 实际宽度。*/
        get width(): number;
        set width(value: number);
        /** 实际高度。*/
        get height(): number;
        set height(value: number);
        /**
         * 获取位图。
         * @return 位图。
         */
        get bitmap(): BaseTexture;
        /**
         * 设置位图。
         * @param 位图。
         */
        set bitmap(value: BaseTexture);
        /**
         * 创建一个 <code>Texture</code> 实例。
         * @param bitmap 位图资源。
         * @param uv UV 数据信息。
         */
        constructor(source?: Texture | BaseTexture, uv?: ArrayLike<number>, sourceWidth?: number, sourceHeight?: number);
        /**
         * 设置此对象的位图资源、UV数据信息。
         * @param	bitmap 位图资源
         * @param	uv UV数据信息
         */
        setTo(bitmap?: BaseTexture, uv?: ArrayLike<number>, sourceWidth?: number, sourceHeight?: number): void;
        /**
         * 加载指定地址的图片。
         * @param	url 图片地址。
         * @param	complete 加载完成回调
         */
        load(url: string, complete?: Handler): Promise<void>;
        /**
         * 获得像素数据
         * @param x x
         * @param y y
         * @param width 宽
         * @param height 高
         * @returns
         */
        getTexturePixels(x: number, y: number, width: number, height: number): Uint8Array;
        /**
         * 获取Texture上的某个区域的像素点
         * @param	x
         * @param	y
         * @param	width
         * @param	height
         * @return  返回像素点集合
         */
        getPixels(x: number, y: number, width: number, height: number): Uint8Array;
        /**
         * 通过url强制恢复bitmap。
         */
        recoverBitmap(callback?: () => void): void;
        /**
         * 强制释放Bitmap,无论是否被引用。
         */
        disposeBitmap(): void;
        get valid(): boolean;
        /**
         * obsolute
         */
        get obsolute(): boolean;
        set obsolute(value: boolean);
        /**
         * @private
         */
        protected _disposeResource(): void;
        /**
         * 获得clip贴图
         * @param x x
         * @param y y
         * @param width 宽
         * @param height 高
         * @returns
         */
        getCachedClip(x: number, y: number, width: number, height: number): Texture;
    }
    interface TexturePropertyParams {
        wrapModeU?: number;
        wrapModeV?: number;
        filterMode?: FilterMode;
        anisoLevel?: number;
        premultiplyAlpha?: boolean;
        hdrEncodeFormat?: HDREncodeFormat;
    }
    type TextureConstructParams = ConstructorParameters<typeof Texture2D>;
    /**
     * <code>Texture2D</code> 类用于生成2D纹理。
     */
    class Texture2D extends BaseTexture {
        /**Texture2D资源。*/
        static TEXTURE2D: string;
        /**纯灰色纹理。*/
        static grayTexture: Texture2D;
        /**纯白色纹理。*/
        static whiteTexture: Texture2D;
        /**纯黑色纹理。*/
        static blackTexture: Texture2D;
        /**默认法线纹理 */
        static normalTexture: Texture2D;
        /**错误纹理 */
        static errorTexture: Texture2D;
        /**
         * 加载纹理
         * @param url 路径
         * @param complete 处理时间
         */
        static load(url: string, complete: Handler): void;
        /**
         * 实例化2D纹理
         * @param width
         * @param height
         * @param format
         * @param mipmap
         * @param canRead
         * @param sRGB
         * @returns
         */
        constructor(width: number, height: number, format: TextureFormat, mipmap: boolean, canRead: boolean, sRGB?: boolean, premultiplyAlpha?: boolean);
        /**
         * 设置Image数据
         * @param source Image原始数据
         * @param premultiplyAlpha 是否预乘 alpha
         * @param invertY 是否反转图像 Y 轴
         */
        setImageData(source: HTMLImageElement | HTMLCanvasElement | ImageBitmap, premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * 设置像素数据
         * @param source 像素数据
         * @param premultiplyAlpha 是否预乘 alpha
         * @param invertY 是否反转图像 Y 轴
         */
        setPixelsData(source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * 设置像素值
         * @param xOffset offset X
         * @param yOffset offset Y
         * @param width 宽
         * @param height 高
         * @param pixels 像素
         * @param mipmapLevel mipmap等级
         * @param generateMipmap 生成mipmap
         * @param premultiplyAlpha 预乘
         * @param invertY 翻转Y
         */
        setSubPixelsData(xOffset: number, yOffset: number, width: number, height: number, pixels: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * 设置dds数据
         * @param ddsInfo
         */
        setDDSData(ddsInfo: DDSTextureInfo): void;
        /**
         * 设置ktx数据
         * @param ktxInfo
         */
        setKTXData(ktxInfo: KTXTextureInfo): void;
        /**
         * 设置HDR数据
         * @param hdrInfo
         */
        setHDRData(hdrInfo: HDRTextureInfo): void;
        /**
         * 默认贴图
         */
        get defaultTexture(): BaseTexture;
        /**
         *
         * 获得像素
         * @returns
         */
        getPixels(): Uint8Array;
    }
    /**
     * 2D 纹理 数组
     */
    class Texture2DArray extends BaseTexture {
        private static _defaultTexture;
        static get defaultTexture(): Texture2DArray;
        depth: number;
        constructor(width: number, height: number, depth: number, format: TextureFormat, mipmap: boolean, canRead: boolean, sRGB?: boolean);
        /**
         * 设置Image数据
         * @param sources Image 数组
         * @param premultiplyAlpha 是否预乘 alpha
         * @param invertY 是否反转图像 Y 轴
         */
        setImageData(sources: HTMLImageElement[] | HTMLCanvasElement[] | ImageBitmap[], premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * 设置像素数据
         * @param source 像素数据
         * @param premultiplyAlpha 是否预乘 alpha
         * @param invertY 是否反转图像 Y 轴
         */
        setPixelsData(source: ArrayBufferView, premultiplyAlpha: boolean, invertY: boolean): void;
        /**
         * 更新像素数据
         * @param xOffset x 偏移
         * @param yOffset y 偏移
         * @param zOffset z 偏移
         * @param width 更新数据宽度
         * @param height 更新数据高度
         * @param depth 更新数据深度层级
         * @param pixels 像素数据
         * @param mipmapLevel mipmap 等级
         * @param generateMipmap 是否生成 mipmap
         * @param premultiplyAlpha 是否预乘 alpha
         * @param invertY 是否反转 Y 轴
         */
        setSubPixelsData(xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, pixels: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean, premultiplyAlpha: boolean, invertY: boolean): void;
    }
    /**
     * 3D 纹理
     */
    class Texture3D extends BaseTexture {
        private static _defaultTexture;
        static get defaultTexture(): Texture3D;
        depth: number;
        constructor(width: number, height: number, depth: number, format: TextureFormat, mipmap?: boolean, sRGB?: boolean);
        /**
        * 设置像素数据
        * @param source 像素数据
        */
        setPixelsData(source: ArrayBufferView): void;
        /**
         * 更新像素数据
         * @param xOffset x 偏移
         * @param yOffset y 偏移
         * @param zOffset z 偏移
         * @param width 更新数据宽度
         * @param height 更新数据高度
         * @param depth 更新数据深度层级
         * @param pixels 像素数据
         * @param mipmapLevel mipmap 等级
         * @param generateMipmap 是否生成 mipmap
         */
        setSubPixelsData(xOffset: number, yOffset: number, zOffset: number, width: number, height: number, depth: number, pixels: ArrayBufferView, mipmapLevel: number, generateMipmap: boolean): void;
    }
    enum TextureCubeFace {
        /**+x */
        PositiveX = 0,
        /**-x */
        NegativeX = 1,
        /**+y */
        PositiveY = 2,
        /**-y */
        NegativeY = 3,
        /**+z */
        PositiveZ = 4,
        /**-z */
        NegativeZ = 5
    }
    /**
     * <code>TextureCube</code> 类用于生成立方体纹理。
     */
    class TextureCube extends BaseTexture {
        /**@private*/
        private static _blackTexture;
        /**@private*/
        private static _grayTexture;
        /**@private*/
        private static _whiteTexture;
        private static _errorTexture;
        /**
         * 黑色纯色纹理。
         */
        static get blackTexture(): TextureCube;
        /**
         * 灰色纯色纹理。
         */
        static get grayTexture(): TextureCube;
        /**
         * 白色纯色纹理。
         */
        static get whiteTexture(): TextureCube;
        static get errorTexture(): TextureCube;
        constructor(size: number, format: TextureFormat, mipmap?: boolean, sRGB?: boolean, premultiplyAlpha?: boolean);
        setImageData(source: (HTMLImageElement | HTMLCanvasElement | ImageBitmap)[], premultiplyAlpha: boolean, invertY: boolean): void;
        setPixelsData(source: ArrayBufferView[], premultiplyAlpha: boolean, invertY: boolean): void;
        updateSubPixelsData(source: ArrayBufferView[], xOffset: number, yOffset: number, width: number, height: number, mipmapLevel: number, generateMipmap: boolean, premultiplyAlpha: boolean, invertY: boolean): void;
        setDDSData(ddsInfo: DDSTextureInfo): void;
        setKTXData(ktxInfo: KTXTextureInfo): void;
        get defaultTexture(): BaseTexture;
    }
    /**
     * WebGLRTMgr 管理WebGLRenderTarget的创建和回收
     * TODO 需求不大，管理成本高。先去掉。
     */
    class WebGLRTMgr {
        private static dict;
        /**
         * 获得一个renderTarget
         * 暂时先按照严格大小判断。
         *
         * @param	w
         * @param	h
         * @return
         */
        static getRT(w: number, h: number): RenderTexture2D;
        /**
         * 回收一个renderTarget
         * @param	rt
         */
        static releaseRT(rt: RenderTexture2D): void;
    }
    class ExternalSkin {
        protected _source: string;
        protected _templet: SpineTemplet;
        protected _items: ExternalSkinItem[];
        target: SpineSkeleton;
        get source(): string;
        set source(value: string);
        set items(value: ExternalSkinItem[]);
        get items(): ExternalSkinItem[];
        /**
        * 得到动画模板的引用
        * @return templet
        */
        get templet(): SpineTemplet;
        set templet(value: SpineTemplet);
        protected init(templet: SpineTemplet): void;
        flush(): void;
    }
    class ExternalSkinItem {
        protected _skin: string;
        protected _slot: string;
        protected _attachment: string;
        get skin(): string;
        set skin(value: string);
        set slot(value: string);
        get slot(): string;
        set attachment(value: string);
        get attachment(): string;
    }
    /**动画开始播放调度
     * @eventType Event.PLAYED
     * */
    /**动画停止播放调度
     * @eventType Event.STOPPED
     * */
    /**动画暂停播放调度
     * @eventType Event.PAUSED
     * */
    /**自定义事件。
     * @eventType Event.LABEL
     */
    /**
     * spine动画由<code>SpineTemplet</code>，<code>SpineSkeletonRender</code>，<code>SpineSkeleton</code>三部分组成。
     */
    class SpineSkeleton extends Sprite {
        static readonly STOPPED: number;
        static readonly PAUSED: number;
        static readonly PLAYING: number;
        protected _source: string;
        protected _templet: SpineTemplet;
        protected _timeKeeper: spine.TimeKeeper;
        protected _skeleton: spine.Skeleton;
        protected _state: spine.AnimationState;
        protected _stateData: spine.AnimationStateData;
        protected _currentPlayTime: number;
        protected _renerer: SpineSkeletonRenderer;
        /** 播放速率*/
        private _playbackRate;
        private trackIndex;
        private _skinName;
        private _animationName;
        private _loop;
        private _externalSkins;
        constructor();
        get externalSkins(): ExternalSkin[];
        set externalSkins(value: ExternalSkin[]);
        /**
         * 重置外部加载的皮肤的样式
         */
        resetExternalSkin(): void;
        get source(): string;
        set source(value: string);
        get skinName(): string;
        set skinName(value: string);
        get animationName(): string;
        set animationName(value: string);
        get loop(): boolean;
        set loop(value: boolean);
        /**
         * 得到动画模板的引用
         * @return templet
         */
        get templet(): SpineTemplet;
        /**
         *
         */
        set templet(value: SpineTemplet);
        /**
         * 设置当前播放位置
         * @param	value 当前时间
         */
        set currentTime(value: number);
        /**
         * 获取当前播放状态
         * @return	当前播放状态
         */
        get playState(): number;
        protected init(templet: SpineTemplet): void;
        /**
         * 播放动画
         *
         * @param	nameOrIndex	动画名字或者索引
         * @param	loop		是否循环播放
         * @param	force		false,如果要播的动画跟上一个相同就不生效,true,强制生效
         * @param	start		起始时间
         * @param	end			结束时间
         * @param	freshSkin	是否刷新皮肤数据
         * @param	playAudio	是否播放音频
         */
        play(nameOrIndex: any, loop: boolean, force?: boolean, start?: number, end?: number, freshSkin?: boolean, playAudio?: boolean): void;
        private _update;
        private _flushExtSkin;
        /**
         * 得到当前动画的数量
         * @return 当前动画的数量
         */
        getAnimNum(): number;
        /**
         * 得到指定动画的名字
         * @param	index	动画的索引
         */
        getAniNameByIndex(index: number): string;
        /**
         * 通过名字得到插槽的引用
         * @param slotName
         */
        getSlotByName(slotName: string): spine.Slot;
        /**
         * 设置动画播放速率
         * @param	value	1为标准速率
         */
        playbackRate(value: number): void;
        /**
         * 通过名字显示一套皮肤
         * @param	name	皮肤的名字
         */
        showSkinByName(name: string): void;
        /**
         * 通过索引显示一套皮肤
         * @param	skinIndex	皮肤索引
         */
        showSkinByIndex(skinIndex: number): void;
        /**
         * 停止动画
         */
        stop(): void;
        /**
         * 暂停动画的播放
         */
        paused(): void;
        /**
         * 恢复动画的播放
         */
        resume(): void;
        private reset;
        /**
         * 销毁当前动画
         * @override
         */
        destroy(destroyChild?: boolean): void;
        /**
         * 添加一个动画
         * @param nameOrIndex   动画名字或者索引
         * @param loop          是否循环播放
         * @param delay         延迟调用，可以为负数
         */
        addAnimation(nameOrIndex: any, loop?: boolean, delay?: number): void;
        /**
         * 设置当动画被改变时，存储混合(交叉淡出)的持续时间
         * @param fromNameOrIndex
         * @param toNameOrIndex
         * @param duration
         */
        setMix(fromNameOrIndex: any, toNameOrIndex: any, duration: number): void;
        /**
         * 获取骨骼信息(spine.Bone)
         * 注意: 获取到的是spine运行时的骨骼信息(spine.Bone)，不适用引擎的方法
         * @param boneName
         */
        getBoneByName(boneName: string): spine.Bone;
        /**
         * 获取Skeleton(spine.Skeleton)
         */
        getSkeleton(): spine.Skeleton;
        /**
         * 替换插槽皮肤
         * @param slotName
         * @param attachmentName
         */
        setSlotAttachment(slotName: string, attachmentName: string): void;
    }
    class SpineSkeletonRenderer {
        premultipliedAlpha: boolean;
        vertexEffect: spine.VertexEffect;
        templet: SpineTemplet;
        private tempColor;
        private tempColor2;
        private vertices;
        private vertexSize;
        private twoColorTint;
        private renderable;
        private clipper;
        private temp;
        private temp2;
        private temp3;
        private temp4;
        constructor(templet: SpineTemplet, twoColorTint?: boolean);
        draw(skeleton: spine.Skeleton, graphics: Graphics, slotRangeStart?: number, slotRangeEnd?: number): void;
    }
    /**
     * Spine动画模板基类
     */
    class SpineTemplet extends Resource {
        static RuntimeVersion: string;
        skeletonData: spine.SkeletonData;
        private _textures;
        private _basePath;
        private _ns;
        constructor();
        get ns(): typeof spine;
        get basePath(): string;
        getTexture(name: string): SpineTexture;
        _parse(desc: string | ArrayBuffer, atlasText: string, createURL: string, progress?: IBatchProgress): Promise<void>;
        private getRuntimeVersion;
        private parseAtlas3;
        private parseAtlas4;
        /**
         * 通过索引得动画名称
         * @param	index
         * @return
         */
        getAniNameByIndex(index: number): string;
        /**
         * 通过皮肤名字得到皮肤索引
         * @param	skinName 皮肤名称
         * @return
         */
        getSkinIndexByName(skinName: string): number;
        /**
         * 释放纹理
         * @override
         */
        protected _disposeResource(): void;
    }
    class SpineTexture {
        realTexture: Texture;
        constructor(tex: Texture);
        getImage(): Object;
        setFilters(minFilter: spine.TextureFilter, magFilter: spine.TextureFilter): void;
        convertWrapMode(mode: spine.TextureWrap): WrapMode;
        setWraps(uWrap: spine.TextureWrap, vWrap: spine.TextureWrap): void;
    }
    /**
     * @private
     */
    class System {
        /**
         * 替换指定名称的定义。用来动态更改类的定义。
         * @param	name 属性名。
         * @param	classObj 属性值。
         */
        static changeDefinition(name: string, classObj: any): void;
    }
    /**
     * <code>AutoBitmap</code> 类是用于表示位图图像或绘制图形的显示对象。
     * <p>封装了位置，宽高及九宫格的处理，供UI组件使用。</p>
     */
    class AutoBitmap extends Graphics {
        /**@private 宽度*/
        private _width;
        /**@private 高度*/
        private _height;
        /**@private 源数据*/
        private _source;
        /**@private 网格数据*/
        private _sizeGrid;
        /**@private */
        protected _isChanged: boolean;
        protected _stateIndex: number;
        protected _stateNum: number;
        uv: number[];
        _color: string;
        /**@private */
        private _drawGridCmd;
        /**@inheritDoc
         * @override
        */
        destroy(): void;
        get sizeGrid(): number[];
        set sizeGrid(value: number[]);
        /**
         * 表示显示对象的宽度，以像素为单位。
         */
        get width(): number;
        set width(value: number);
        /**
         * 表示显示对象的高度，以像素为单位。
         */
        get height(): number;
        set height(value: number);
        /**
         * 对象的纹理资源。
         */
        get source(): Texture;
        set source(value: Texture);
        setState(index: number, numStates: number): void;
        get color(): string;
        set color(value: string);
        /** @private */
        protected _setChanged(): void;
        /**
         * @private
         * 修改纹理资源。
         */
        protected changeSource(): void;
        /**
         *  由于可能有其他的graphic命令，因此不能用原来的直接clear()的方法
         */
        private _setDrawGridCmd;
    }
    /**
     * <code>Box</code> 类是一个控件容器类。
     */
    class Box extends UIComponent {
        private _bgColor;
        /**
         * @inheritDoc
         * @override
         */
        set_dataSource(value: any): void;
        /**背景颜色*/
        get bgColor(): string;
        set bgColor(value: string);
    }
    /**
     * 当按钮的选中状态（ <code>selected</code> 属性）发生改变时调度。
     * @eventType laya.events.Event
     */
    /**
     * <code>Button</code> 组件用来表示常用的多态按钮。 <code>Button</code> 组件可显示文本标签、图标或同时显示两者。	 *
     * <p>可以是单态，两态和三态，默认三态(up,over,down)。</p>
     *
     * @example <caption>以下示例代码，创建了一个 <code>Button</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.Button;
     *		import laya.utils.Handler;
     *		public class Button_Example
     *		{
     *			public function Button_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load("resource/ui/button.png", Handler.create(this,onLoadComplete));//加载资源。
     *			}
     *			private function onLoadComplete():void
     *			{
     *				trace("资源加载完成！");
     *				var button:Button = new Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,并传入它的皮肤。
     *				button.x = 100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
     *				button.y = 100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
     *				button.clickHandler = new Handler(this, onClickButton,[button]);//设置 button 的点击事件处理器。
     *				Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
     *			}
     *			private function onClickButton(button:Button):void
     *			{
     *				trace("按钮button被点击了！");
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     * Laya.loader.load("resource/ui/button.png",laya.utils.Handler.create(this,loadComplete));//加载资源
     * function loadComplete()
     * {
     *     console.log("资源加载完成！");
     *     var button = new laya.ui.Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,传入它的皮肤skin和标签label。
     *     button.x =100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
     *     button.y =100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
     *     button.clickHandler = laya.utils.Handler.create(this,onClickButton,[button],false);//设置 button 的点击事件处理函数。
     *     Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
     * }
     * function onClickButton(button)
     * {
     *     console.log("按钮被点击了。",button);
     * }
     * @example
     * import Button=laya.ui.Button;
     * import Handler=laya.utils.Handler;
     * class Button_Example{
     *     constructor()
     *     {
     *         Laya.init(640, 800);
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load("resource/ui/button.png", laya.utils.Handler.create(this,this.onLoadComplete));//加载资源。
     *     }
     *     private onLoadComplete()
     *     {
     *         var button:Button = new Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,并传入它的皮肤。
     *         button.x = 100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
     *         button.y = 100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
     *         button.clickHandler = new Handler(this, this.onClickButton,[button]);//设置 button 的点击事件处理器。
     *         Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
     *     }
     *     private onClickButton(button:Button):void
     *     {
     *         console.log("按钮button被点击了！")
     *     }
     * }
     */
    class Button extends UIComponent implements ISelect {
        /**
         * 指定按钮按下时是否是切换按钮的显示状态。
         *
         * @example 以下示例代码，创建了一个 <code>Button</code> 实例，并设置为切换按钮。
         * @example
         * package
         *	{
         *		import laya.ui.Button;
         *		import laya.utils.Handler;
         *		public class Button_toggle
         *		{
         *			public function Button_toggle()
         *			{
         *				Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
         *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
         *				Laya.loader.load("resource/ui/button.png", Handler.create(this,onLoadComplete));
         *			}
         *			private function onLoadComplete():void
         *			{
         *				trace("资源加载完成！");
         *				var button:Button = new Button("resource/ui/button.png","label");//创建一个 Button 实例对象 button ,传入它的皮肤skin和标签label。
         *				button.x = 100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
         *				button.y = 100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
         *				button.toggle = true;//设置 button 对象为切换按钮。
         *				button.clickHandler = new Handler(this, onClickButton,[button]);//设置 button 的点击事件处理器。
         *				Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
         *	 		}
         *			private function onClickButton(button:Button):void
         *			{
         *				trace("button.selected = "+ button.selected);
         *			}
         *		}
         *	}
         * @example
         * Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
         * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
         * Laya.loader.load("resource/ui/button.png",laya.utils.Handler.create(this,loadComplete));//加载资源
         * function loadComplete()
         * {
         *     console.log("资源加载完成！");
         *     var button = new laya.ui.Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,传入它的皮肤skin和标签label。
         *     button.x =100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
         *     button.y =100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
         *     button.toggle = true;//设置 button 对象为切换按钮。
         *     button.clickHandler = laya.utils.Handler.create(this,onClickButton,[button],false);//设置 button 的点击事件处理器。
         *     Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
         * }
         * function onClickButton(button)
         * {
         *     console.log("button.selected = ",button.selected);
         * }
         * @example
         * Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
         * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
         * Laya.loader.load("button.png", null,null, null, null, null);//加载资源
         * function loadComplete() {
         *     console.log("资源加载完成！");
         *     var button:laya.ui.Button = new laya.ui.Button("button.png", "label");//创建一个 Button 类的实例对象 button ,传入它的皮肤skin和标签label。
         *     button.x = 100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
         *     button.y = 100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
         *     button.toggle = true;//设置 button 对象为切换按钮。
         *     button.clickHandler = laya.utils.Handler.create(this, onClickButton, [button], false);//设置 button 的点击事件处理器。
         *     Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
         * }
         * function onClickButton(button) {
         *     console.log("button.selected = ", button.selected);
         * }
         */
        toggle: boolean;
        /**
         * @private
         * 按钮上的文本。
         */
        protected _text: Text;
        /**
         * @private
         * 按钮文本标签的颜色值。
         */
        protected _labelColors: string[];
        /**
         * @private
         * 按钮文本标签描边的颜色值。
         */
        protected _strokeColors: string[];
        /**
         * @private
         * 按钮的状态值。
         */
        protected _state: number;
        /**
         * @private
         * 表示按钮的选中状态。
         */
        protected _selected: boolean;
        protected _skin: string;
        /**
         * @private
         * 指定此显示对象是否自动计算并改变大小等属性。
         */
        protected _autoSize: boolean;
        /**
         * @private
         * 按钮的状态数。
         */
        protected _stateNum: number;
        /**
         * @private
         * 按钮的点击事件函数。
         */
        protected _clickHandler: Handler;
        /**
         * @private
         */
        protected _stateChanged: boolean;
        _graphics: AutoBitmap;
        /**
         * 创建一个新的 <code>Button</code> 类实例。
         * @param skin 皮肤资源地址。
         * @param label 按钮的文本内容。
         */
        constructor(skin?: string, label?: string);
        /**
         * @inheritDoc
         * @override
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @inheritDoc
         * @override
         */
        protected createChildren(): void;
        /**@private */
        protected createText(): void;
        /**@inheritDoc
         * @override
        */
        protected initialize(): void;
        /**
         * 对象的 <code>Event.MOUSE_OVER、Event.MOUSE_OUT、Event.MOUSE_DOWN、Event.MOUSE_UP、Event.CLICK</code> 事件侦听处理函数。
         * @param e Event 对象。
         */
        protected onMouse(e: Event): void;
        /**
         * <p>对象的皮肤资源地址。</p>
         * 支持单态，两态和三态，用 <code>stateNum</code> 属性设置
         * <p>对象的皮肤地址，以字符串表示。</p>
         * @see #stateNum
         */
        get skin(): string;
        set skin(value: string);
        _setSkin(url: string): Promise<void>;
        protected _skinLoaded(tex: any): void;
        /**
         * <p>指定对象的状态值，以数字表示。</p>
         * <p>默认值为3。此值决定皮肤资源图片的切割方式。</p>
         * <p><b>取值：</b>
         * <li>1：单态。图片不做切割，按钮的皮肤状态只有一种。</li>
         * <li>2：两态。图片将以竖直方向被等比切割为2部分，从上向下，依次为
         * 弹起状态皮肤、
         * 按下和经过及选中状态皮肤。</li>
         * <li>3：三态。图片将以竖直方向被等比切割为3部分，从上向下，依次为
         * 弹起状态皮肤、
         * 经过状态皮肤、
         * 按下和选中状态皮肤</li>
         * </p>
         */
        get stateNum(): number;
        set stateNum(value: number);
        /**
         * @private
         * 对象的资源切片发生改变。
         */
        protected changeClips(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected measureWidth(): number;
        /**
         * @inheritDoc
         * @override
         */
        protected measureHeight(): number;
        /**
         * 按钮的文本内容。
         */
        get label(): string;
        set label(value: string);
        /**
         * 表示按钮的选中状态。
         * <p>如果值为true，表示该对象处于选中状态。否则该对象处于未选中状态。</p>
         * @implements
         */
        get selected(): boolean;
        set selected(value: boolean);
        /**
         * 对象的状态值。
         * @see #stateMap
         */
        protected get state(): number;
        protected set state(value: number);
        /**
         * @private
         * 改变对象的状态。
         */
        protected changeState(): void;
        /**
         * 表示按钮各个状态下的文本颜色。
         * <p><b>格式:</b> "upColor,overColor,downColor"。</p>
         */
        get labelColors(): string;
        set labelColors(value: string);
        /**
         * 表示按钮各个状态下的描边颜色。
         * <p><b>格式:</b> "upColor,overColor,downColor"。</p>
         */
        get strokeColors(): string;
        set strokeColors(value: string);
        /**
         * 表示按钮文本标签的边距。
         * <p><b>格式：</b>"上边距,右边距,下边距,左边距"。</p>
         */
        get labelPadding(): string;
        set labelPadding(value: string);
        /**
         * 表示按钮文本标签的字体大小。
         * @see laya.display.Text.fontSize()
         */
        get labelSize(): number;
        set labelSize(value: number);
        /**
         * <p>描边宽度（以像素为单位）。</p>
         * 默认值0，表示不描边。
         * @see laya.display.Text.stroke()
         */
        get labelStroke(): number;
        set labelStroke(value: number);
        /**
         * <p>描边颜色，以字符串表示。</p>
         * 默认值为 "#000000"（黑色）;
         * @see laya.display.Text.strokeColor()
         */
        get labelStrokeColor(): string;
        set labelStrokeColor(value: string);
        /**
         * 表示按钮文本标签是否为粗体字。
         * @see laya.display.Text.bold()
         */
        get labelBold(): boolean;
        set labelBold(value: boolean);
        /**
         * 表示按钮文本标签的字体名称，以字符串形式表示。
         */
        get labelFont(): string;
        set labelFont(value: string);
        /**
         * 标签对齐模式，
         */
        get labelAlign(): string;
        set labelAlign(value: string);
        /**
         * 标签垂直对齐模式，
         */
        get labelVAlign(): string;
        set labelVAlign(value: string);
        /**
         * 对象的点击事件处理器函数（无默认参数）。
         * @implements
         */
        get clickHandler(): Handler;
        set clickHandler(value: Handler);
        /**
         * 按钮文本标签 <code>Text</code> 控件。
         */
        get text(): Text;
        /**
         * 兼容老IDE
         * @private
        */
        set text(value: Text);
        /**
         * <p>当前实例的位图 <code>AutoImage</code> 实例的有效缩放网格数据。</p>
         * <p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
         * <ul><li>例如："4,4,4,4,1"</li></ul></p>
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @inheritDoc
         * @override
         */
        _setWidth(value: number): void;
        /**
         * @inheritDoc
         * @override
         */
        _setHeight(value: number): void;
        /**
         * @inheritDoc
         * @override
         */
        set_dataSource(value: any): void;
        /**图标x,y偏移，格式：100,100*/
        get iconOffset(): string;
        set iconOffset(value: string);
        /**@private */
        protected _setStateChanged(): void;
    }
    /**
     * 当按钮的选中状态（ <code>selected</code> 属性）发生改变时调度。
     * @eventType laya.events.Event
     */
    /**
     * <code>CheckBox</code> 组件显示一个小方框，该方框内可以有选中标记。
     * <code>CheckBox</code> 组件还可以显示可选的文本标签，默认该标签位于 CheckBox 右侧。
     * <p><code>CheckBox</code> 使用 <code>dataSource</code>赋值时的的默认属性是：<code>selected</code>。</p>
     *
     * @example <caption>以下示例代码，创建了一个 <code>CheckBox</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.CheckBox;
     *		import laya.utils.Handler;
     *		public class CheckBox_Example
     *		{
     *			public function CheckBox_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高。
     * 				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load("resource/ui/check.png", Handler.create(this,onLoadComplete));//加载资源。
     *			}
     *			private function onLoadComplete():void
     *			{
     *				trace("资源加载完成！");
     *				var checkBox:CheckBox = new CheckBox("resource/ui/check.png", "这个是一个CheckBox组件。");//创建一个 CheckBox 类的实例对象 checkBox ,传入它的皮肤skin和标签label。
     *				checkBox.x = 100;//设置 checkBox 对象的属性 x 的值，用于控制 checkBox 对象的显示位置。
     *				checkBox.y = 100;//设置 checkBox 对象的属性 y 的值，用于控制 checkBox 对象的显示位置。
     *				checkBox.clickHandler = new Handler(this, onClick, [checkBox]);//设置 checkBox 的点击事件处理器。
     *				Laya.stage.addChild(checkBox);//将此 checkBox 对象添加到显示列表。
     *			}
     *			private function onClick(checkBox:CheckBox):void
     *			{
     *				trace("输出选中状态: checkBox.selected = " + checkBox.selected);
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * Laya.loader.load("resource/ui/check.png",laya.utils.Handler.create(this,loadComplete));//加载资源
     * function loadComplete()
     * {
     *     console.log("资源加载完成！");
     *     var checkBox:laya.ui.CheckBox= new laya.ui.CheckBox("resource/ui/check.png", "这个是一个CheckBox组件。");//创建一个 CheckBox 类的类的实例对象 checkBox ,传入它的皮肤skin和标签label。
     *     checkBox.x =100;//设置 checkBox 对象的属性 x 的值，用于控制 checkBox 对象的显示位置。
     *     checkBox.y =100;//设置 checkBox 对象的属性 y 的值，用于控制 checkBox 对象的显示位置。
     *     checkBox.clickHandler = new laya.utils.Handler(this,this.onClick,[checkBox],false);//设置 checkBox 的点击事件处理器。
     *     Laya.stage.addChild(checkBox);//将此 checkBox 对象添加到显示列表。
     * }
     * function onClick(checkBox)
     * {
     *     console.log("checkBox.selected = ",checkBox.selected);
     * }
     * @example
     * import CheckBox= laya.ui.CheckBox;
     * import Handler=laya.utils.Handler;
     * class CheckBox_Example{
     *     constructor()
     *     {
     *         Laya.init(640, 800);
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load("resource/ui/check.png", Handler.create(this,this.onLoadComplete));//加载资源。
     *     }
     *     private onLoadComplete()
     *     {
     *         var checkBox:CheckBox = new CheckBox("resource/ui/check.png", "这个是一个CheckBox组件。");//创建一个 CheckBox 类的实例对象 checkBox ,传入它的皮肤skin和标签label。
     *         checkBox.x = 100;//设置 checkBox 对象的属性 x 的值，用于控制 checkBox 对象的显示位置。
     *         checkBox.y = 100;//设置 checkBox 对象的属性 y 的值，用于控制 checkBox 对象的显示位置。
     *         checkBox.clickHandler = new Handler(this, this.onClick,[checkBox]);//设置 checkBox 的点击事件处理器。
     *         Laya.stage.addChild(checkBox);//将此 checkBox 对象添加到显示列表。
     *     }
     *     private onClick(checkBox:CheckBox):void
     *     {
     *         console.log("输出选中状态: checkBox.selected = " + checkBox.selected);
     *     }
     * }
     */
    class CheckBox extends Button {
        /**
         * 创建一个新的 <code>CheckBox</code> 组件实例。
         * @param skin 皮肤资源地址。
         * @param label 文本标签的内容。
         */
        constructor(skin?: string, label?: string);
        /**
         * @inheritDoc
         * @override
         */
        protected preinitialize(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected initialize(): void;
        /**
         * @inheritDoc
         * @override
         */
        set_dataSource(value: any): void;
    }
    /**
     * 图片加载完成后调度。
     * @eventType Event.LOADED
     */
    /**
     * 当前帧发生变化后调度。
     * @eventType laya.events.Event
     */
    /**
     * <p> <code>Clip</code> 类是位图切片动画。</p>
     * <p> <code>Clip</code> 可将一张图片，按横向分割数量 <code>clipX</code> 、竖向分割数量 <code>clipY</code> ，
     * 或横向分割每个切片的宽度 <code>clipWidth</code> 、竖向分割每个切片的高度 <code>clipHeight</code> ，
     * 从左向右，从上到下，分割组合为一个切片动画。</p>
     * Image和Clip组件是唯一支持异步加载的两个组件，比如clip.skin = "abc/xxx.png"，其他UI组件均不支持异步加载。
     *
     * @example <caption>以下示例代码，创建了一个 <code>Clip</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.Clip;
     *		public class Clip_Example
     *		{
     *			private var clip:Clip;
     *			public function Clip_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				onInit();
     *			}
     *			private function onInit():void
     *			{
     *				clip = new Clip("resource/ui/clip_num.png", 10, 1);//创建一个 Clip 类的实例对象 clip ,传入它的皮肤skin和横向分割数量、竖向分割数量。
     *				clip.autoPlay = true;//设置 clip 动画自动播放。
     *				clip.interval = 100;//设置 clip 动画的播放时间间隔。
     *				clip.x = 100;//设置 clip 对象的属性 x 的值，用于控制 clip 对象的显示位置。
     *				clip.y = 100;//设置 clip 对象的属性 y 的值，用于控制 clip 对象的显示位置。
     *				clip.on(Event.CLICK, this, onClick);//给 clip 添加点击事件函数侦听。
     *				Laya.stage.addChild(clip);//将此 clip 对象添加到显示列表。
     *			}
     *			private function onClick():void
     *			{
     *				trace("clip 的点击事件侦听处理函数。clip.total="+ clip.total);
     *				if (clip.isPlaying == true)
     *				{
     *					clip.stop();//停止动画。
     *				}else {
     *					clip.play();//播放动画。
     *				}
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * var clip;
     * Laya.loader.load("resource/ui/clip_num.png",laya.utils.Handler.create(this,loadComplete));//加载资源
     * function loadComplete() {
     *     console.log("资源加载完成！");
     *     clip = new laya.ui.Clip("resource/ui/clip_num.png",10,1);//创建一个 Clip 类的实例对象 clip ,传入它的皮肤skin和横向分割数量、竖向分割数量。
     *     clip.autoPlay = true;//设置 clip 动画自动播放。
     *     clip.interval = 100;//设置 clip 动画的播放时间间隔。
     *     clip.x =100;//设置 clip 对象的属性 x 的值，用于控制 clip 对象的显示位置。
     *     clip.y =100;//设置 clip 对象的属性 y 的值，用于控制 clip 对象的显示位置。
     *     clip.on(Event.CLICK,this,onClick);//给 clip 添加点击事件函数侦听。
     *     Laya.stage.addChild(clip);//将此 clip 对象添加到显示列表。
     * }
     * function onClick()
     * {
     *     console.log("clip 的点击事件侦听处理函数。");
     *     if(clip.isPlaying == true)
     *     {
     *         clip.stop();
     *     }else {
     *         clip.play();
     *     }
     * }
     * @example
     * import Clip = laya.ui.Clip;
     * import Handler = laya.utils.Handler;
     * class Clip_Example {
     *     private clip: Clip;
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         this.onInit();
     *     }
     *     private onInit(): void {
     *         this.clip = new Clip("resource/ui/clip_num.png", 10, 1);//创建一个 Clip 类的实例对象 clip ,传入它的皮肤skin和横向分割数量、竖向分割数量。
     *         this.clip.autoPlay = true;//设置 clip 动画自动播放。
     *         this.clip.interval = 100;//设置 clip 动画的播放时间间隔。
     *         this.clip.x = 100;//设置 clip 对象的属性 x 的值，用于控制 clip 对象的显示位置。
     *         this.clip.y = 100;//设置 clip 对象的属性 y 的值，用于控制 clip 对象的显示位置。
     *         this.clip.on(laya.events.Event.CLICK, this, this.onClick);//给 clip 添加点击事件函数侦听。
     *         Laya.stage.addChild(this.clip);//将此 clip 对象添加到显示列表。
     *     }
     *     private onClick(): void {
     *         console.log("clip 的点击事件侦听处理函数。clip.total=" + this.clip.total);
     *         if (this.clip.isPlaying == true) {
     *             this.clip.stop();//停止动画。
     *         } else {
     *             this.clip.play();//播放动画。
     *         }
     *     }
     * }
     *
     */
    class Clip extends UIComponent {
        /**@private */
        protected _sources: Texture[];
        /**@private */
        protected _skin: string;
        /**@private */
        protected _clipX: number;
        /**@private */
        protected _clipY: number;
        /**@private */
        protected _clipWidth: number;
        /**@private */
        protected _clipHeight: number;
        /**@private */
        protected _autoPlay: boolean;
        /**@private */
        protected _interval: number;
        /**@private */
        protected _complete: Handler;
        /**@private */
        protected _isPlaying: boolean;
        /**@private */
        protected _index: number;
        /**@private */
        protected _clipChanged: boolean;
        /**@private */
        protected _group: string;
        /**@private */
        protected _toIndex: number;
        _graphics: AutoBitmap;
        /**
         * 创建一个新的 <code>Clip</code> 示例。
         * @param url 资源类库名或者地址
         * @param clipX x方向分割个数
         * @param clipY y方向分割个数
         */
        constructor(url?: string, clipX?: number, clipY?: number);
        /**
         * @inheritDoc
         * @override
         */
        protected createChildren(): void;
        /**@private	 @override*/
        protected _onDisplay(e?: boolean): void;
        /**
         * @copy laya.ui.Image#skin
         */
        get skin(): string;
        set skin(value: string);
        _setSkin(url: string): Promise<void>;
        protected _skinLoaded(): void;
        /**X轴（横向）切片数量。*/
        get clipX(): number;
        set clipX(value: number);
        /**Y轴(竖向)切片数量。*/
        get clipY(): number;
        set clipY(value: number);
        /**
         * 横向分割时每个切片的宽度，与 <code>clipX</code> 同时设置时优先级高于 <code>clipX</code> 。
         */
        get clipWidth(): number;
        set clipWidth(value: number);
        /**
         * 竖向分割时每个切片的高度，与 <code>clipY</code> 同时设置时优先级高于 <code>clipY</code> 。
         */
        get clipHeight(): number;
        set clipHeight(value: number);
        /**
         * @private
         * 改变切片的资源、切片的大小。
         */
        protected changeClip(): void;
        /**
         * @private
         * 加载切片图片资源完成函数。
         * @param url 资源地址。
         * @param img 纹理。
         */
        protected loadComplete(url: string, img: Texture): void;
        /**
         * 源数据。
         */
        get sources(): Texture[];
        set sources(value: Texture[]);
        /**
         * 资源分组。
         */
        get group(): string;
        set group(value: string);
        /**
         * @inheritDoc
         * @override
         */
        _setWidth(value: number): void;
        /**
         * @inheritDoc
         * @override
         */
        _setHeight(value: number): void;
        /**
         * @inheritDoc
         * @override
         */
        protected measureWidth(): number;
        /**
         * @inheritDoc
         * @override
         */
        protected measureHeight(): number;
        /**
         * <p>当前实例的位图 <code>AutoImage</code> 实例的有效缩放网格数据。</p>
         * <p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
         * <ul><li>例如："4,4,4,4,1"</li></ul></p>
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * 当前帧索引。
         */
        get index(): number;
        set index(value: number);
        /**
         * 切片动画的总帧数。
         */
        get total(): number;
        /**
         * 表示是否自动播放切片动画，若自动播放值为true,否则值为false;
         * <p>可控制切片动画的播放、停止。</p>
         */
        get autoPlay(): boolean;
        set autoPlay(value: boolean);
        /**
         * 表示切片动画播放间隔时间(以毫秒为单位)。
         */
        get interval(): number;
        set interval(value: number);
        /**
         * 表示切片动画的当前播放状态。
         * 如果切片动画正在播放中，则为true，否则为flash。
         */
        get isPlaying(): boolean;
        set isPlaying(value: boolean);
        /**
         * 播放切片动画。
         * @param	from	开始索引
         * @param	to		结束索引，-1为不限制
         */
        play(from?: number, to?: number): void;
        /**
         * @private
         */
        protected _loop(): void;
        /**
         * 停止切片动画。
         */
        stop(): void;
        /**
         * @inheritDoc
         * @override
         */
        set_dataSource(value: any): void;
        /**@private */
        protected _setClipChanged(): void;
    }
    /**
     * 选择项改变后调度。
     * @eventType laya.events.Event
     */
    /**
     * <code>ColorPicker</code> 组件将显示包含多个颜色样本的列表，用户可以从中选择颜色。
     *
     * @example <caption>以下示例代码，创建了一个 <code>ColorPicker</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.ColorPicker;
     *		import laya.utils.Handler;
     *		public class ColorPicker_Example
     *		{
     *			public function ColorPicker_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load("resource/ui/color.png", Handler.create(this,onLoadComplete));//加载资源。
     *			}
     *			private function onLoadComplete():void
     *			{
     *				trace("资源加载完成！");
     *				var colorPicket:ColorPicker = new ColorPicker();//创建一个 ColorPicker 类的实例对象 colorPicket 。
     *				colorPicket.skin = "resource/ui/color.png";//设置 colorPicket 的皮肤。
     *				colorPicket.x = 100;//设置 colorPicket 对象的属性 x 的值，用于控制 colorPicket 对象的显示位置。
     *				colorPicket.y = 100;//设置 colorPicket 对象的属性 y 的值，用于控制 colorPicket 对象的显示位置。
     *				colorPicket.changeHandler = new Handler(this, onChangeColor,[colorPicket]);//设置 colorPicket 的颜色改变回调函数。
     *				Laya.stage.addChild(colorPicket);//将此 colorPicket 对象添加到显示列表。
     *			}
     *			private function onChangeColor(colorPicket:ColorPicker):void
     *			{
     *				trace("当前选择的颜色： " + colorPicket.selectedColor);
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * Laya.loader.load("resource/ui/color.png",laya.utils.Handler.create(this,loadComplete));//加载资源
     * function loadComplete()
     * {
     *     console.log("资源加载完成！");
     *     var colorPicket = new laya.ui.ColorPicker();//创建一个 ColorPicker 类的实例对象 colorPicket 。
     *     colorPicket.skin = "resource/ui/color.png";//设置 colorPicket 的皮肤。
     *     colorPicket.x = 100;//设置 colorPicket 对象的属性 x 的值，用于控制 colorPicket 对象的显示位置。
     *     colorPicket.y = 100;//设置 colorPicket 对象的属性 y 的值，用于控制 colorPicket 对象的显示位置。
     *     colorPicket.changeHandler = laya.utils.Handler.create(this, onChangeColor,[colorPicket],false);//设置 colorPicket 的颜色改变回调函数。
     *     Laya.stage.addChild(colorPicket);//将此 colorPicket 对象添加到显示列表。
     * }
     * function onChangeColor(colorPicket)
     * {
     *     console.log("当前选择的颜色： " + colorPicket.selectedColor);
     * }
     * @example
     * import ColorPicker = laya.ui.ColorPicker;
     * import Handler = laya.utils.Handler;
     * class ColorPicker_Example {
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load("resource/ui/color.png", Handler.create(this, this.onLoadComplete));//加载资源。
     *     }
     *     private onLoadComplete(): void {
     *         console.log("资源加载完成！");
     *         var colorPicket: ColorPicker = new ColorPicker();//创建一个 ColorPicker 类的实例对象 colorPicket 。
     *         colorPicket.skin = "resource/ui/color.png";//设置 colorPicket 的皮肤。
     *         colorPicket.x = 100;//设置 colorPicket 对象的属性 x 的值，用于控制 colorPicket 对象的显示位置。
     *         colorPicket.y = 100;//设置 colorPicket 对象的属性 y 的值，用于控制 colorPicket 对象的显示位置。
     *         colorPicket.changeHandler = new Handler(this, this.onChangeColor, [colorPicket]);//设置 colorPicket 的颜色改变回调函数。
     *         Laya.stage.addChild(colorPicket);//将此 colorPicket 对象添加到显示列表。
     *     }
     *     private onChangeColor(colorPicket: ColorPicker): void {
     *         console.log("当前选择的颜色： " + colorPicket.selectedColor);
     *     }
     * }
     */
    class ColorPicker extends UIComponent {
        /**
         * 当颜色发生改变时执行的函数处理器。
         * 默认返回参数color：颜色值字符串。
         */
        changeHandler: Handler;
        /**
         * @private
         * 指定每个正方形的颜色小格子的宽高（以像素为单位）。
         */
        protected _gridSize: number;
        /**
         * @private
         * 表示颜色样本列表面板的背景颜色值。
         */
        protected _bgColor: string;
        /**
         * @private
         * 表示颜色样本列表面板的边框颜色值。
         */
        protected _borderColor: string;
        /**
         * @private
         * 表示颜色样本列表面板选择或输入的颜色值。
         */
        protected _inputColor: string;
        /**
         * @private
         * 表示颜色输入框的背景颜色值。
         */
        protected _inputBgColor: string;
        /**
         * @private
         * 表示颜色样本列表面板。
         */
        protected _colorPanel: Box;
        /**
         * @private
         * 表示颜色网格。
         */
        protected _colorTiles: Sprite;
        /**
         * @private
         * 表示颜色块显示对象。
         */
        protected _colorBlock: Sprite;
        /**
         * @private
         * 表示颜色输入框控件 <code>Input</code> 。
         */
        protected _colorInput: Input;
        /**
         * @private
         * 表示点击后显示颜色样本列表面板的按钮控件 <code>Button</code> 。
         */
        protected _colorButton: Button;
        /**
         * @private
         * 表示颜色值列表。
         */
        protected _colors: any[];
        /**
         * @private
         * 表示选择的颜色值。
         */
        protected _selectedColor: string;
        /** @private */
        protected _panelChanged: boolean;
        constructor(createChildren?: boolean);
        /**
         * @inheritDoc
         * @override
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @inheritDoc
         * @override
         */
        protected createChildren(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected initialize(): void;
        private onPanelMouseDown;
        /**
         * 改变颜色样本列表面板。
         */
        protected changePanel(): void;
        /**
         * 颜色样本列表面板的显示按钮的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
         */
        private onColorButtonClick;
        /**
         * 打开颜色样本列表面板。
         */
        open(): void;
        /**
         * 关闭颜色样本列表面板。
         */
        close(): void;
        /**
         * 舞台的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
         */
        private removeColorBox;
        /**
         * 小格子色块的 <code>Event.KEY_DOWN</code> 事件侦听处理函数。
         */
        private onColorFieldKeyDown;
        /**
         * 颜色值输入框 <code>Event.CHANGE</code> 事件侦听处理函数。
         */
        private onColorInputChange;
        /**
         * 小格子色块的 <code>Event.CLICK</code> 事件侦听处理函数。
         */
        private onColorTilesClick;
        /**
         * @private
         * 小格子色块的 <code>Event.MOUSE_MOVE</code> 事件侦听处理函数。
         */
        private onColorTilesMouseMove;
        /**
         * 通过鼠标位置取对应的颜色块的颜色值。
         */
        protected getColorByMouse(): string;
        /**
         * 绘制颜色块。
         * @param color 需要绘制的颜色块的颜色值。
         */
        private drawBlock;
        /**
         * 表示选择的颜色值。
         */
        get selectedColor(): string;
        set selectedColor(value: string);
        /**
         * @copy laya.ui.Button#skin
         */
        get skin(): string;
        set skin(value: string);
        /**
         * 改变颜色。
         */
        private changeColor;
        /**
         * 表示颜色样本列表面板的背景颜色值。
         */
        get bgColor(): string;
        set bgColor(value: string);
        /**
         * 表示颜色样本列表面板的边框颜色值。
         */
        get borderColor(): string;
        set borderColor(value: string);
        /**
         * 表示颜色样本列表面板选择或输入的颜色值。
         */
        get inputColor(): string;
        set inputColor(value: string);
        /**
         * 表示颜色输入框的背景颜色值。
         */
        get inputBgColor(): string;
        set inputBgColor(value: string);
        /**@private */
        protected _setPanelChanged(): void;
    }
    /**
     * 当用户更改 <code>ComboBox</code> 组件中的选定内容时调度。
     * @eventType laya.events.Event
     * selectedIndex属性变化时调度。
     */
    /**
     * <code>ComboBox</code> 组件包含一个下拉列表，用户可以从该列表中选择单个值。
     *
     * @example <caption>以下示例代码，创建了一个 <code>ComboBox</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.ComboBox;
     *		import laya.utils.Handler;
     *		public class ComboBox_Example
     *		{
     *			public function ComboBox_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load("resource/ui/button.png", Handler.create(this,onLoadComplete));//加载资源。
     *			}
     *			private function onLoadComplete():void
     *			{
     *				trace("资源加载完成！");
     *				var comboBox:ComboBox = new ComboBox("resource/ui/button.png", "item0,item1,item2,item3,item4,item5");//创建一个 ComboBox 类的实例对象 comboBox ,传入它的皮肤和标签集。
     *				comboBox.x = 100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
     *				comboBox.y = 100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
     *				comboBox.selectHandler = new Handler(this, onSelect);//设置 comboBox 选择项改变时执行的处理器。
     *				Laya.stage.addChild(comboBox);//将此 comboBox 对象添加到显示列表。
     *			}
     *			private function onSelect(index:int):void
     *			{
     *				trace("当前选中的项对象索引： ",index);
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高。
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     * Laya.loader.load("resource/ui/button.png",laya.utils.Handler.create(this,loadComplete));//加载资源
     * function loadComplete() {
     *     console.log("资源加载完成！");
     *     var comboBox = new laya.ui.ComboBox("resource/ui/button.png", "item0,item1,item2,item3,item4,item5");//创建一个 ComboBox 类的实例对象 comboBox ,传入它的皮肤和标签集。
     *     comboBox.x = 100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
     *     comboBox.y = 100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
     *     comboBox.selectHandler = new laya.utils.Handler(this, onSelect);//设置 comboBox 选择项改变时执行的处理器。
     *     Laya.stage.addChild(comboBox);//将此 comboBox 对象添加到显示列表。
     * }
     * function onSelect(index)
     * {
     *     console.log("当前选中的项对象索引： ",index);
     * }
     * @example
     * import ComboBox = laya.ui.ComboBox;
     * import Handler = laya.utils.Handler;
     * class ComboBox_Example {
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load("resource/ui/button.png", Handler.create(this, this.onLoadComplete));//加载资源。
     *     }
     *     private onLoadComplete(): void {
     *         console.log("资源加载完成！");
     *         var comboBox: ComboBox = new ComboBox("resource/ui/button.png", "item0,item1,item2,item3,item4,item5");//创建一个 ComboBox 类的实例对象 comboBox ,传入它的皮肤和标签集。
     *         comboBox.x = 100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
     *         comboBox.y = 100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
     *         comboBox.selectHandler = new Handler(this, this.onSelect);//设置 comboBox 选择项改变时执行的处理器。
     *         Laya.stage.addChild(comboBox);//将此 comboBox 对象添加到显示列表。
     *     }
     *     private onSelect(index: number): void {
     *         console.log("当前选中的项对象索引： ", index);
     *     }
     * }
     *
     */
    class ComboBox extends UIComponent {
        /**@private */
        protected _visibleNum: number;
        /**
         * @private
         */
        protected _button: Button;
        /**
         * @private
         */
        protected _list: List;
        /**
         * @private
         */
        protected _isOpen: boolean;
        /**
         * @private
         */
        protected _itemColors: string[];
        /**
         * @private
         */
        protected _itemPadding: number[];
        /**
         * @private
         */
        protected _itemSize: number;
        /**
         * @private
         */
        protected _labels: string[];
        /**
         * @private
         * 下拉提示文本
         */
        protected _defaultLabel: string;
        /**
         * @private
         */
        protected _selectedIndex: number;
        /**
         * @private
         */
        protected _selectHandler: Handler;
        /**
         * @private 下拉框列表单元的高度
         */
        protected _itemHeight: number;
        /**
         * @private
         */
        protected _listHeight: number;
        /**
         * @private
         */
        protected _listChanged: boolean;
        /**
         * @private
         */
        protected _itemChanged: boolean;
        /**
         * @private
         */
        protected _scrollBarSkin: string;
        protected _scrollType: ScrollType;
        /**
         * @private
         */
        protected _isCustomList: boolean;
        /**
         * 渲染项，用来显示下拉列表展示对象
         */
        itemRender: any;
        /**
         * 创建一个新的 <code>ComboBox</code> 组件实例。
         * @param skin 皮肤资源地址。
         * @param labels 下拉列表的标签集字符串。以逗号做分割，如"item0,item1,item2,item3,item4,item5"。
         */
        constructor(skin?: string, labels?: string);
        /**
         * @inheritDoc
         * @override
        */
        destroy(destroyChild?: boolean): void;
        /**
         * @inheritDoc
         * @override
        */
        protected createChildren(): void;
        private _createList;
        private _setListEvent;
        /**
         * @private
         */
        private onListDown;
        private onScrollBarDown;
        private onButtonMouseDown;
        get skin(): string;
        set skin(value: string);
        /**
         * @inheritDoc
         * @override
        */
        protected measureWidth(): number;
        /**
         * @inheritDoc
         * @override
        */
        protected measureHeight(): number;
        /**
         * @private
         */
        protected changeList(): void;
        /**
         * @private
         * 下拉列表的鼠标事件响应函数。
         */
        protected onlistItemMouse(e: Event, index: number): void;
        /**
         * @private
         */
        private switchTo;
        /**
         * 更改下拉列表的打开状态。
         */
        protected changeOpen(): void;
        /**
         * @inheritDoc
         * @override
         */
        _setWidth(value: number): void;
        /**
         * 下拉列表文本的边距Padding
         * @readme <p><b>格式：</b>上边距,右边距,下边距,左边距</p>
         */
        get itemPadding(): string;
        set itemPadding(value: string);
        /**
         * @inheritDoc
         * @override
         */
        _setHeight(value: number): void;
        /**
         * 标签集合字符串。
         */
        get labels(): string;
        set labels(value: string);
        /**
         * 更改下拉列表。
         */
        protected changeItem(): void;
        /**
         * 表示选择的下拉列表项的索引。
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        private changeSelected;
        /**
        * 默认的下拉提示文本。
        */
        get defaultLabel(): string;
        set defaultLabel(value: string);
        /**
         * 改变下拉列表的选择项时执行的处理器(默认返回参数index:int)。
         */
        get selectHandler(): Handler;
        set selectHandler(value: Handler);
        /**
         * 表示选择的下拉列表项的的标签。
         */
        get selectedLabel(): string;
        set selectedLabel(value: string);
        /**
         * 获取或设置没有滚动条的下拉列表中可显示的最大行数。
         */
        get visibleNum(): number;
        set visibleNum(value: number);
        /**
         * 下拉列表项的高度
         */
        get itemHeight(): number;
        set itemHeight(value: number);
        /**
         * 下拉列表项颜色。
         * <p><b>格式：</b>"悬停或被选中时背景颜色,悬停或被选中时标签颜色,标签颜色,边框颜色,背景颜色"</p>
         */
        get itemColors(): string;
        set itemColors(value: string);
        /**
         * 下拉列表项标签的字体大小。
         */
        get itemSize(): number;
        set itemSize(value: number);
        /**
         * 表示下拉列表的打开状态。
         */
        get isOpen(): boolean;
        set isOpen(value: boolean);
        private _onStageMouseWheel;
        /**
         * 关闭下拉列表。
         */
        protected removeList(e: Event): void;
        /**
         * 滚动类型
         */
        get scrollType(): ScrollType;
        set scrollType(value: ScrollType);
        /**
         * 滚动条皮肤。
         */
        get scrollBarSkin(): string;
        set scrollBarSkin(value: string);
        /**
         * <p>当前实例的位图 <code>AutoImage</code> 实例的有效缩放网格数据。</p>
         * <p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
         * <ul><li>例如："4,4,4,4,1"</li></ul></p>
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * 获取对 <code>ComboBox</code> 组件所包含的 <code>VScrollBar</code> 滚动条组件的引用。
         */
        get scrollBar(): VScrollBar;
        /**
         * 获取对 <code>ComboBox</code> 组件所包含的 <code>Button</code> 组件的引用。
         */
        get button(): Button;
        /**
         * 获取对 <code>ComboBox</code> 组件所包含的 <code>List</code> 列表组件的引用。
         */
        get list(): List;
        set list(value: List);
        /**
         * @inheritDoc
         * @override
        */
        set_dataSource(value: any): void;
        /**
         * 获取或设置对 <code>ComboBox</code> 组件所包含的 <code>Button</code> 组件的文本标签颜色。
         * <p><b>格式：</b>upColor,overColor,downColor</p>
         */
        get labelColors(): string;
        set labelColors(value: string);
        /**
         * 获取或设置对 <code>ComboBox</code> 组件所包含的 <code>Button</code> 组件的文本边距。
         * <p><b>格式：</b>上边距,右边距,下边距,左边距</p>
         */
        get labelPadding(): string;
        set labelPadding(value: string);
        /**
         * 获取或设置对 <code>ComboBox</code> 组件所包含的 <code>Button</code> 组件的标签字体大小。
         */
        get labelSize(): number;
        set labelSize(value: number);
        /**
         * 表示按钮文本标签是否为粗体字。
         * @see laya.display.Text#bold
         */
        get labelBold(): boolean;
        set labelBold(value: boolean);
        /**
         * 表示按钮文本标签的字体名称，以字符串形式表示。
         * @see laya.display.Text#font
         */
        get labelFont(): string;
        set labelFont(value: string);
        /**
         * 表示按钮的状态值。
         * @see laya.ui.Button#stateNum
         */
        get stateNum(): number;
        set stateNum(value: number);
    }
    /**
     * <code>Dialog</code> 组件是一个弹出对话框，实现对话框弹出，拖动，模式窗口功能。
     * 可以通过UIConfig设置弹出框背景透明度，模式窗口点击边缘是否关闭等
     * 通过设置zOrder属性，可以更改弹出的层次
     * 通过设置popupEffect和closeEffect可以设置弹出效果和关闭效果，如果不想有任何弹出关闭效果，可以设置前述属性为空
     *
     * @example <caption>以下示例代码，创建了一个 <code>Dialog</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.Dialog;
     *		import laya.utils.Handler;
     *		public class Dialog_Example
     *		{
     *			private var dialog:Dialog_Instance;
     *			public function Dialog_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load("resource/ui/btn_close.png", Handler.create(this, onLoadComplete));//加载资源。
     *			}
     *			private function onLoadComplete():void
     *			{
     *				dialog = new Dialog_Instance();//创建一个 Dialog_Instance 类的实例对象 dialog。
     *				dialog.dragArea = "0,0,150,50";//设置 dialog 的拖拽区域。
     *				dialog.show();//显示 dialog。
     *				dialog.closeHandler = new Handler(this, onClose);//设置 dialog 的关闭函数处理器。
     *			}
     *			private function onClose(name:String):void
     *			{
     *				if (name == Dialog.CLOSE)
     *				{
     *					trace("通过点击 name 为" + name +"的组件，关闭了dialog。");
     *				}
     *			}
     *		}
     *	}
     *	import laya.ui.Button;
     *	import laya.ui.Dialog;
     *	import laya.ui.Image;
     *	class Dialog_Instance extends Dialog
     *	{
     *		function Dialog_Instance():void
     *		{
     *			var bg:Image = new Image("resource/ui/bg.png");
     *			bg.sizeGrid = "40,10,5,10";
     *			bg.width = 150;
     *			bg.height = 250;
     *			addChild(bg);
     *			var image:Image = new Image("resource/ui/image.png");
     *			addChild(image);
     *			var button:Button = new Button("resource/ui/btn_close.png");
     *			button.name = Dialog.CLOSE;//设置button的name属性值。
     *			button.x = 0;
     *			button.y = 0;
     *			addChild(button);
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高、渲染模式
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * var dialog;
     * Laya.loader.load("resource/ui/btn_close.png", laya.utils.Handler.create(this, loadComplete));//加载资源
     * (function (_super) {//新建一个类Dialog_Instance继承自laya.ui.Dialog。
     *     function Dialog_Instance() {
     *         Dialog_Instance.__super.call(this);//初始化父类
     *         var bg = new laya.ui.Image("resource/ui/bg.png");//新建一个 Image 类的实例 bg 。
     *         bg.sizeGrid = "10,40,10,5";//设置 bg 的网格信息。
     *         bg.width = 150;//设置 bg 的宽度。
     *         bg.height = 250;//设置 bg 的高度。
     *         this.addChild(bg);//将 bg 添加到显示列表。
     *         var image = new laya.ui.Image("resource/ui/image.png");//新建一个 Image 类的实例 image 。
     *         this.addChild(image);//将 image 添加到显示列表。
     *         var button = new laya.ui.Button("resource/ui/btn_close.png");//新建一个 Button 类的实例 bg 。
     *         button.name = laya.ui.Dialog.CLOSE;//设置 button 的 name 属性值。
     *         button.x = 0;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
     *         button.y = 0;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
     *         this.addChild(button);//将 button 添加到显示列表。
     *     };
     *     Laya.class(Dialog_Instance,"mypackage.dialogExample.Dialog_Instance",_super);//注册类Dialog_Instance。
     * })(laya.ui.Dialog);
     * function loadComplete() {
     *     console.log("资源加载完成！");
     *     dialog = new mypackage.dialogExample.Dialog_Instance();//创建一个 Dialog_Instance 类的实例对象 dialog。
     *     dialog.dragArea = "0,0,150,50";//设置 dialog 的拖拽区域。
     *     dialog.show();//显示 dialog。
     *     dialog.closeHandler = new laya.utils.Handler(this, onClose);//设置 dialog 的关闭函数处理器。
     * }
     * function onClose(name) {
     *     if (name == laya.ui.Dialog.CLOSE) {
     *         console.log("通过点击 name 为" + name + "的组件，关闭了dialog。");
     *     }
     * }
     * @example
     * import Dialog = laya.ui.Dialog;
     * import Handler = laya.utils.Handler;
     * class Dialog_Example {
     *     private dialog: Dialog_Instance;
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load("resource/ui/btn_close.png", Handler.create(this, this.onLoadComplete));//加载资源。
     *     }
     *     private onLoadComplete(): void {
     *         this.dialog = new Dialog_Instance();//创建一个 Dialog_Instance 类的实例对象 dialog。
     *         this.dialog.dragArea = "0,0,150,50";//设置 dialog 的拖拽区域。
     *         this.dialog.show();//显示 dialog。
     *         this.dialog.closeHandler = new Handler(this, this.onClose);//设置 dialog 的关闭函数处理器。
     *     }
     *     private onClose(name: string): void {
     *         if (name == Dialog.CLOSE) {
     *             console.log("通过点击 name 为" + name + "的组件，关闭了dialog。");
     *         }
     *     }
     * }
     * import Button = laya.ui.Button;
     * class Dialog_Instance extends Dialog {
     *     Dialog_Instance(): void {
     *         var bg: laya.ui.Image = new laya.ui.Image("resource/ui/bg.png");
     *         bg.sizeGrid = "40,10,5,10";
     *         bg.width = 150;
     *         bg.height = 250;
     *         this.addChild(bg);
     *         var image: laya.ui.Image = new laya.ui.Image("resource/ui/image.png");
     *         this.addChild(image);
     *         var button: Button = new Button("resource/ui/btn_close.png");
     *         button.name = Dialog.CLOSE;//设置button的name属性值。
     *         button.x = 0;
     *         button.y = 0;
     *         this.addChild(button);
     *     }
     * }
     */
    class Dialog extends View {
        /**对话框内的某个按钮命名为close，点击此按钮则会关闭*/
        static CLOSE: string;
        /**对话框内的某个按钮命名为cancel，点击此按钮则会关闭*/
        static CANCEL: string;
        /**对话框内的某个按钮命名为sure，点击此按钮则会关闭*/
        static SURE: string;
        /**对话框内的某个按钮命名为no，点击此按钮则会关闭*/
        static NO: string;
        /**对话框内的某个按钮命名为yes，点击此按钮则会关闭*/
        static YES: string;
        /**对话框内的某个按钮命名为ok，点击此按钮则会关闭*/
        static OK: string;
        /**@private 表示对话框管理器。*/
        private static _manager;
        /**对话框管理容器，所有的对话框都在该容器内，并且受管理器管理，可以自定义自己的管理器，来更改窗口管理的流程。
         * 任意对话框打开和关闭，都会触发管理类的open和close事件*/
        static get manager(): DialogManager;
        static set manager(value: DialogManager);
        /**
         * 对话框被关闭时会触发的回调函数处理器。
         * <p>回调函数参数为用户点击的按钮名字name:String。</p>
         */
        closeHandler: Handler;
        /**
         * 弹出对话框效果，可以设置一个效果代替默认的弹出效果，如果不想有任何效果，可以赋值为null
         * 全局默认弹出效果可以通过manager.popupEffect修改
         */
        popupEffect: Handler;
        /**
         * 关闭对话框效果，可以设置一个效果代替默认的关闭效果，如果不想有任何效果，可以赋值为null
         * 全局默认关闭效果可以通过manager.closeEffect修改
         */
        closeEffect: Handler;
        /**组名称*/
        group: string;
        /**是否是模式窗口*/
        isModal: boolean;
        /**是否显示弹出效果*/
        isShowEffect: boolean;
        /**指定对话框是否居中弹。<p>如果值为true，则居中弹出，否则，则根据对象坐标显示，默认为true。</p>*/
        isPopupCenter: boolean;
        /**关闭类型，点击name为"close"，"cancel"，"sure"，"no"，"yes"，"no"的按钮时，会自动记录点击按钮的名称*/
        closeType: string;
        /**@private */
        private _dragArea;
        constructor();
        /**@private 提取拖拽区域*/
        protected _dealDragArea(): void;
        /**
         * 用来指定对话框的拖拽区域。默认值为"0,0,0,0"。
         * <p><b>格式：</b>构成一个矩形所需的 x,y,width,heith 值，用逗号连接为字符串。
         * 例如："0,0,100,200"。</p>
         * @see #includeExamplesSummary 请参考示例
         */
        get dragArea(): string;
        set dragArea(value: string);
        /**@private */
        private _onMouseDown;
        /**@private 处理默认点击事件*/
        protected _onClick(e: Event): void;
        /**
         * @inheritDoc
         * @override
        */
        open(closeOther?: boolean, param?: any): void;
        /**
         * 关闭对话框。
         * @param type 关闭的原因，会传递给onClosed函数
         * @override
         */
        close(type?: string): void;
        /**
         * @inheritDoc
         * @override
         */
        destroy(destroyChild?: boolean): void;
        /**
         * 显示对话框（以非模式窗口方式显示）。
         * @param closeOther 是否关闭其它的对话框。若值为true则关闭其它对话框。
         * @param showEffect 是否显示弹出效果
         */
        show(closeOther?: boolean, showEffect?: boolean): void;
        /**
         * 显示对话框（以模式窗口方式显示）。
         * @param closeOther 是否关闭其它的对话框。若值为true则关闭其它对话框。
         * @param showEffect 是否显示弹出效果
         */
        popup(closeOther?: boolean, showEffect?: boolean): void;
        /**@private */
        protected _open(modal: boolean, closeOther: boolean, showEffect: boolean): void;
        /**弹出框的显示状态；如果弹框处于显示中，则为true，否则为false;*/
        get isPopup(): boolean;
        /**
         * @inheritDoc
         * @override
         */
        set zOrder(value: number);
        /**
         * @inheritDoc
         * @override
         */
        get zOrder(): number;
        /**
         * 设置锁定界面，在界面未准备好前显示锁定界面，准备完毕后则移除锁定层，如果为空则什么都不显示
         * @param	view 锁定界面内容
         */
        static setLockView(view: UIComponent): void;
        /**
         * 锁定所有层，显示加载条信息，防止下面内容被点击
         */
        static lock(value: boolean): void;
        /**关闭所有对话框。*/
        static closeAll(): void;
        /**
         * 根据组获取对话框集合
         * @param	group 组名称
         * @return	对话框数组
         */
        static getDialogsByGroup(group: string): any[];
        /**
         * 根据组关闭所有弹出框
         * @param	group 需要关闭的组名称
         */
        static closeByGroup(group: string): any[];
    }
    /**打开任意窗口后调度。
     * @eventType Event.OPEN
     */
    /**关闭任意窗口后调度。
     * @eventType Event.CLOSE
     */
    /**
     * <code>DialogManager</code> 对话框管理容器，所有的对话框都在该容器内，并且受管理器管理。
     * 任意对话框打开和关闭，都会出发管理类的open和close事件
     * 可以通过UIConfig设置弹出框背景透明度，模式窗口点击边缘是否关闭，点击窗口是否切换层次等
     * 通过设置对话框的zOrder属性，可以更改弹出的层次
     */
    class DialogManager extends Sprite {
        /**遮罩层*/
        maskLayer: Sprite;
        /**锁屏层*/
        lockLayer: Sprite;
        /**@private 全局默认弹出对话框效果，可以设置一个效果代替默认的弹出效果，如果不想有任何效果，可以赋值为null*/
        popupEffect: (dialog: Dialog) => void;
        /**@private 全局默认关闭对话框效果，可以设置一个效果代替默认的关闭效果，如果不想有任何效果，可以赋值为null*/
        closeEffect: (dialog: Dialog) => void;
        /**全局默认关闭对话框效果，可以设置一个效果代替默认的关闭效果，如果不想有任何效果，可以赋值为null*/
        popupEffectHandler: Handler;
        /**全局默认弹出对话框效果，可以设置一个效果代替默认的弹出效果，如果不想有任何效果，可以赋值为null*/
        closeEffectHandler: Handler;
        /**
         * 创建一个新的 <code>DialogManager</code> 类实例。
         */
        constructor();
        private _closeOnSide;
        /**设置锁定界面，如果为空则什么都不显示*/
        setLockView(value: UIComponent): void;
        /**@private */
        private _onResize;
        private _centerDialog;
        /**
         * 显示对话框
         * @param dialog 需要显示的对象框 <code>Dialog</code> 实例。
         * @param closeOther 是否关闭其它对话框，若值为ture，则关闭其它的对话框。
         * @param showEffect 是否显示弹出效果
         */
        open(dialog: Dialog, closeOther?: boolean, showEffect?: boolean): void;
        /**@private */
        private _clearDialogEffect;
        /**
         * 执行打开对话框。
         * @param dialog 需要关闭的对象框 <code>Dialog</code> 实例。
         */
        doOpen(dialog: Dialog): void;
        /**
         * 锁定所有层，显示加载条信息，防止双击
         */
        lock(value: boolean): void;
        /**
         * 关闭对话框。
         * @param dialog 需要关闭的对象框 <code>Dialog</code> 实例。
         */
        close(dialog: Dialog): void;
        /**
         * 执行关闭对话框。
         * @param dialog 需要关闭的对象框 <code>Dialog</code> 实例。
         */
        doClose(dialog: Dialog): void;
        /**
         * 关闭所有的对话框。
         */
        closeAll(): void;
        /**@private */
        private _closeAll;
        /**
         * 根据组获取所有对话框
         * @param	group 组名称
         * @return	对话框数组
         */
        getDialogsByGroup(group: string): any[];
        /**
         * 根据组关闭所有弹出框
         * @param	group 需要关闭的组名称
         * @return	需要关闭的对话框数组
         */
        closeByGroup(group: string): any[];
    }
    /**
     * 字体切片，简化版的位图字体，只需设置一个切片图片和文字内容即可使用，效果同位图字体
     * 使用方式：设置位图字体皮肤skin，设置皮肤对应的字体内容sheet（如果多行，可以使用空格换行），示例：
     * fontClip.skin = "font1.png";//设置皮肤
     * fontClip.sheet = "abc123 456";//设置皮肤对应的内容，空格换行。此皮肤为2行5列（显示时skin会被等分为2行5列），第一行对应的文字为"abc123"，第二行为"456"
     * fontClip.value = "a1326";//显示"a1326"文字
     */
    class FontClip extends Clip {
        /**数值*/
        protected _valueArr: string;
        /**文字内容数组**/
        protected _indexMap: Record<string, number>;
        /**位图字体内容**/
        protected _sheet: string;
        /**@private */
        protected _direction: string;
        /**X方向间隙*/
        protected _spaceX: number;
        /**Y方向间隙*/
        protected _spaceY: number;
        /**@private 水平对齐方式*/
        private _align;
        /**@private 显示文字宽*/
        private _wordsW;
        /**@private 显示文字高*/
        private _wordsH;
        /**
         * @param skin 位图字体皮肤
         * @param sheet 位图字体内容，空格代表换行
         */
        constructor(skin?: string, sheet?: string);
        /**
         * 资源加载完毕
         */
        protected loadComplete(url: string, img: Texture): void;
        get index(): number;
        set index(value: number);
        /**
         * 设置位图字体内容，空格代表换行。比如"abc123 456"，代表第一行对应的文字为"abc123"，第二行为"456"
         */
        get sheet(): string;
        set sheet(value: string);
        /**
         * 设置位图字体的显示内容
         */
        get value(): string;
        set value(value: string);
        /**
         * 布局方向。
         * <p>默认值为"horizontal"。</p>
         * <p><b>取值：</b>
         * <li>"horizontal"：表示水平布局。</li>
         * <li>"vertical"：表示垂直布局。</li>
         * </p>
         */
        get direction(): string;
        set direction(value: string);
        /**X方向文字间隙*/
        get spaceX(): number;
        set spaceX(value: number);
        /**Y方向文字间隙*/
        get spaceY(): number;
        set spaceY(value: number);
        set align(v: string);
        /**水平对齐方式*/
        get align(): string;
        /**渲染数值*/
        protected changeValue(): void;
        /**
         * @inheritDoc
         * @override
         */
        _setWidth(value: number): void;
        /**
         * @inheritDoc
         * @override
         */
        _setHeight(value: number): void;
        /**
         * @override
         */
        protected measureWidth(): number;
        /**
         * @override
         */
        protected measureHeight(): number;
        /**
         *
         * @param destroyChild
         * @override
         */
        destroy(destroyChild?: boolean): void;
    }
    /**
     * <code>HBox</code> 是一个水平布局容器类。
     */
    class HBox extends LayoutBox {
        /**
         * 无对齐。
         */
        static NONE: string;
        /**
         * 居顶部对齐。
         */
        static TOP: string;
        /**
         * 居中对齐。
         */
        static MIDDLE: string;
        /**
         * 居底部对齐。
         */
        static BOTTOM: string;
        /**
         * @inheritDoc
         * @override
         */
        protected sortItem(items: any[]): void;
        /**
         * @inheritDoc
         * @override
         */
        _setHeight(value: number): void;
        /**
         * @inheritDoc
         * @override
         */
        protected changeItems(): void;
    }
    /**
     * 使用 <code>HScrollBar</code> （水平 <code>ScrollBar</code> ）控件，可以在因数据太多而不能在显示区域完全显示时控制显示的数据部分。
     * @example <caption>以下示例代码，创建了一个 <code>HScrollBar</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.HScrollBar;
     *		import laya.utils.Handler;
     *		public class HScrollBar_Example
     *		{
     *			private var hScrollBar:HScrollBar;
     *			public function HScrollBar_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load(["resource/ui/hscroll.png", "resource/ui/hscroll$bar.png", "resource/ui/hscroll$down.png", "resource/ui/hscroll$up.png"], Handler.create(this, onLoadComplete));//加载资源。
     *			}
     *			private function onLoadComplete():void
     *			{
     *				hScrollBar = new HScrollBar();//创建一个 HScrollBar 类的实例对象 hScrollBar 。
     *				hScrollBar.skin = "resource/ui/hscroll.png";//设置 hScrollBar 的皮肤。
     *				hScrollBar.x = 100;//设置 hScrollBar 对象的属性 x 的值，用于控制 hScrollBar 对象的显示位置。
     *				hScrollBar.y = 100;//设置 hScrollBar 对象的属性 y 的值，用于控制 hScrollBar 对象的显示位置。
     *				hScrollBar.changeHandler = new Handler(this, onChange);//设置 hScrollBar 的滚动变化处理器。
     *				Laya.stage.addChild(hScrollBar);//将此 hScrollBar 对象添加到显示列表。
     *			}
     *			private function onChange(value:Number):void
     *			{
     *				trace("滚动条的位置： value=" + value);
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * var hScrollBar;
     * var res  = ["resource/ui/hscroll.png", "resource/ui/hscroll$bar.png", "resource/ui/hscroll$down.png", "resource/ui/hscroll$up.png"];
     * Laya.loader.load(res,laya.utils.Handler.create(this, onLoadComplete));//加载资源。
     * function onLoadComplete() {
     *     console.log("资源加载完成！");
     *     hScrollBar = new laya.ui.HScrollBar();//创建一个 HScrollBar 类的实例对象 hScrollBar 。
     *     hScrollBar.skin = "resource/ui/hscroll.png";//设置 hScrollBar 的皮肤。
     *     hScrollBar.x = 100;//设置 hScrollBar 对象的属性 x 的值，用于控制 hScrollBar 对象的显示位置。
     *     hScrollBar.y = 100;//设置 hScrollBar 对象的属性 y 的值，用于控制 hScrollBar 对象的显示位置。
     *     hScrollBar.changeHandler = new laya.utils.Handler(this, onChange);//设置 hScrollBar 的滚动变化处理器。
     *     Laya.stage.addChild(hScrollBar);//将此 hScrollBar 对象添加到显示列表。
     * }
     * function onChange(value)
     * {
     *     console.log("滚动条的位置： value=" + value);
     * }
     * @example
     * import HScrollBar = laya.ui.HScrollBar;
     * import Handler = laya.utils.Handler;
     * class HScrollBar_Example {
     *     private hScrollBar: HScrollBar;
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load(["resource/ui/hscroll.png", "resource/ui/hscroll$bar.png", "resource/ui/hscroll$down.png", "resource/ui/hscroll$up.png"], Handler.create(this, this.onLoadComplete));//加载资源。
     *     }
     *     private onLoadComplete(): void {
     *         this.hScrollBar = new HScrollBar();//创建一个 HScrollBar 类的实例对象 hScrollBar 。
     *         this.hScrollBar.skin = "resource/ui/hscroll.png";//设置 hScrollBar 的皮肤。
     *         this.hScrollBar.x = 100;//设置 hScrollBar 对象的属性 x 的值，用于控制 hScrollBar 对象的显示位置。
     *         this.hScrollBar.y = 100;//设置 hScrollBar 对象的属性 y 的值，用于控制 hScrollBar 对象的显示位置。
     *         this.hScrollBar.changeHandler = new Handler(this, this.onChange);//设置 hScrollBar 的滚动变化处理器。
     *         Laya.stage.addChild(this.hScrollBar);//将此 hScrollBar 对象添加到显示列表。
     *     }
     *     private onChange(value: number): void {
     *         console.log("滚动条的位置： value=" + value);
     *     }
     * }
    */
    class HScrollBar extends ScrollBar {
        /**
         * @override
         * @inheritDoc
         */
        protected initialize(): void;
    }
    /**
     * 使用 <code>HSlider</code> 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。
     * <p> <code>HSlider</code> 控件采用水平方向。滑块轨道从左向右扩展，而标签位于轨道的顶部或底部。</p>
     *
     * @example <caption>以下示例代码，创建了一个 <code>HSlider</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.HSlider;
     *		import laya.utils.Handler;
     *		public class HSlider_Example
     *		{
     *			private var hSlider:HSlider;
     *			public function HSlider_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load(["resource/ui/hslider.png", "resource/ui/hslider$bar.png"], Handler.create(this, onLoadComplete));//加载资源。
     *			}
     *			private function onLoadComplete():void
     *			{
     *				hSlider = new HSlider();//创建一个 HSlider 类的实例对象 hSlider 。
     *				hSlider.skin = "resource/ui/hslider.png";//设置 hSlider 的皮肤。
     *				hSlider.min = 0;//设置 hSlider 最低位置值。
     *				hSlider.max = 10;//设置 hSlider 最高位置值。
     *				hSlider.value = 2;//设置 hSlider 当前位置值。
     *				hSlider.tick = 1;//设置 hSlider 刻度值。
     *				hSlider.x = 100;//设置 hSlider 对象的属性 x 的值，用于控制 hSlider 对象的显示位置。
     *				hSlider.y = 100;//设置 hSlider 对象的属性 y 的值，用于控制 hSlider 对象的显示位置。
     *				hSlider.changeHandler = new Handler(this, onChange);//设置 hSlider 位置变化处理器。
     *				Laya.stage.addChild(hSlider);//把 hSlider 添加到显示列表。
     *			}
     *			private function onChange(value:Number):void
     *			{
     *				trace("滑块的位置： value=" + value);
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800, "canvas");//设置游戏画布宽高、渲染模式
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * var hSlider;
     * var res = ["resource/ui/hslider.png", "resource/ui/hslider$bar.png"];
     * Laya.loader.load(res, laya.utils.Handler.create(this, onLoadComplete));
     * function onLoadComplete() {
     *     console.log("资源加载完成！");
     *     hSlider = new laya.ui.HSlider();//创建一个 HSlider 类的实例对象 hSlider 。
     *     hSlider.skin = "resource/ui/hslider.png";//设置 hSlider 的皮肤。
     *     hSlider.min = 0;//设置 hSlider 最低位置值。
     *     hSlider.max = 10;//设置 hSlider 最高位置值。
     *     hSlider.value = 2;//设置 hSlider 当前位置值。
     *     hSlider.tick = 1;//设置 hSlider 刻度值。
     *     hSlider.x = 100;//设置 hSlider 对象的属性 x 的值，用于控制 hSlider 对象的显示位置。
     *     hSlider.y = 100;//设置 hSlider 对象的属性 y 的值，用于控制 hSlider 对象的显示位置。
     *     hSlider.changeHandler = new laya.utils.Handler(this, onChange);//设置 hSlider 位置变化处理器。
     *     Laya.stage.addChild(hSlider);//把 hSlider 添加到显示列表。
     * }
     * function onChange(value)
     * {
     *     console.log("滑块的位置： value=" + value);
     * }
     * @example
     * import Handler = laya.utils.Handler;
     * import HSlider = laya.ui.HSlider;
     * class HSlider_Example {
     *     private hSlider: HSlider;
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load(["resource/ui/hslider.png", "resource/ui/hslider$bar.png"], Handler.create(this, this.onLoadComplete));//加载资源。
     *     }
     *     private onLoadComplete(): void {
     *         this.hSlider = new HSlider();//创建一个 HSlider 类的实例对象 hSlider 。
     *         this.hSlider.skin = "resource/ui/hslider.png";//设置 hSlider 的皮肤。
     *         this.hSlider.min = 0;//设置 hSlider 最低位置值。
     *         this.hSlider.max = 10;//设置 hSlider 最高位置值。
     *         this.hSlider.value = 2;//设置 hSlider 当前位置值。
     *         this.hSlider.tick = 1;//设置 hSlider 刻度值。
     *         this.hSlider.x = 100;//设置 hSlider 对象的属性 x 的值，用于控制 hSlider 对象的显示位置。
     *         this.hSlider.y = 100;//设置 hSlider 对象的属性 y 的值，用于控制 hSlider 对象的显示位置。
     *         this.hSlider.changeHandler = new Handler(this, this.onChange);//设置 hSlider 位置变化处理器。
     *         Laya.stage.addChild(this.hSlider);//把 hSlider 添加到显示列表。
     *     }
     *     private onChange(value: number): void {
     *         console.log("滑块的位置： value=" + value);
     *     }
     * }
     *
     * @see laya.ui.Slider
    */
    class HSlider extends Slider {
        /**
         * 创建一个 <code>HSlider</code> 类实例。
         * @param skin 皮肤。
         */
        constructor(skin?: string);
    }
    /**
     * 资源加载完成后调度。
     * @eventType Event.LOADED
     */
    /**
     * <code>Image</code> 类是用于表示位图图像或绘制图形的显示对象。
     * Image和Clip组件是唯一支持异步加载的两个组件，比如img.skin = "abc/xxx.png"，其他UI组件均不支持异步加载。
     *
     * @example <caption>以下示例代码，创建了一个新的 <code>Image</code> 实例，设置了它的皮肤、位置信息，并添加到舞台上。</caption>
     *	package
     *	 {
     *		import laya.ui.Image;
     *		public class Image_Example
     *		{
     *			public function Image_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				onInit();
     *			}
     *			private function onInit():void
     *	 		{
     *				var bg:Image = new Image("resource/ui/bg.png");//创建一个 Image 类的实例对象 bg ,并传入它的皮肤。
     *				bg.x = 100;//设置 bg 对象的属性 x 的值，用于控制 bg 对象的显示位置。
     *				bg.y = 100;//设置 bg 对象的属性 y 的值，用于控制 bg 对象的显示位置。
     *				bg.sizeGrid = "40,10,5,10";//设置 bg 对象的网格信息。
     *				bg.width = 150;//设置 bg 对象的宽度。
     *				bg.height = 250;//设置 bg 对象的高度。
     *				Laya.stage.addChild(bg);//将此 bg 对象添加到显示列表。
     *				var image:Image = new Image("resource/ui/image.png");//创建一个 Image 类的实例对象 image ,并传入它的皮肤。
     *				image.x = 100;//设置 image 对象的属性 x 的值，用于控制 image 对象的显示位置。
     *				image.y = 100;//设置 image 对象的属性 y 的值，用于控制 image 对象的显示位置。
     *				Laya.stage.addChild(image);//将此 image 对象添加到显示列表。
     *			}
     *		}
     *	 }
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * onInit();
     * function onInit() {
     *     var bg = new laya.ui.Image("resource/ui/bg.png");//创建一个 Image 类的实例对象 bg ,并传入它的皮肤。
     *     bg.x = 100;//设置 bg 对象的属性 x 的值，用于控制 bg 对象的显示位置。
     *     bg.y = 100;//设置 bg 对象的属性 y 的值，用于控制 bg 对象的显示位置。
     *     bg.sizeGrid = "40,10,5,10";//设置 bg 对象的网格信息。
     *     bg.width = 150;//设置 bg 对象的宽度。
     *     bg.height = 250;//设置 bg 对象的高度。
     *     Laya.stage.addChild(bg);//将此 bg 对象添加到显示列表。
     *     var image = new laya.ui.Image("resource/ui/image.png");//创建一个 Image 类的实例对象 image ,并传入它的皮肤。
     *     image.x = 100;//设置 image 对象的属性 x 的值，用于控制 image 对象的显示位置。
     *     image.y = 100;//设置 image 对象的属性 y 的值，用于控制 image 对象的显示位置。
     *     Laya.stage.addChild(image);//将此 image 对象添加到显示列表。
     * }
     * @example
     * class Image_Example {
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         this.onInit();
     *     }
     *     private onInit(): void {
     *         var bg: laya.ui.Image = new laya.ui.Image("resource/ui/bg.png");//创建一个 Image 类的实例对象 bg ,并传入它的皮肤。
     *         bg.x = 100;//设置 bg 对象的属性 x 的值，用于控制 bg 对象的显示位置。
     *         bg.y = 100;//设置 bg 对象的属性 y 的值，用于控制 bg 对象的显示位置。
     *         bg.sizeGrid = "40,10,5,10";//设置 bg 对象的网格信息。
     *         bg.width = 150;//设置 bg 对象的宽度。
     *         bg.height = 250;//设置 bg 对象的高度。
     *         Laya.stage.addChild(bg);//将此 bg 对象添加到显示列表。
     *         var image: laya.ui.Image = new laya.ui.Image("resource/ui/image.png");//创建一个 Image 类的实例对象 image ,并传入它的皮肤。
     *         image.x = 100;//设置 image 对象的属性 x 的值，用于控制 image 对象的显示位置。
     *         image.y = 100;//设置 image 对象的属性 y 的值，用于控制 image 对象的显示位置。
     *         Laya.stage.addChild(image);//将此 image 对象添加到显示列表。
     *     }
     * }
     * @see AutoBitmap
     */
    class Image extends UIComponent {
        /**@private */
        protected _skin: string;
        /**@private */
        protected _group: string;
        protected _useSourceSize: boolean;
        _graphics: AutoBitmap;
        /**
         * 创建一个 <code>Image</code> 实例。
         * @param skin 皮肤资源地址。
         */
        constructor(skin?: string | null);
        /**
         * 销毁对象并释放加载的皮肤资源。
         */
        dispose(): void;
        /**
         * @inheritDoc
         * @override
         */
        protected createChildren(): void;
        /**
         * <p>对象的皮肤地址，以字符串表示。</p>
         * <p>如果资源未加载，则先加载资源，加载完成后应用于此对象。</p>
         * <b>注意：</b>资源加载完成后，会自动缓存至资源库中。
         */
        get skin(): string;
        set skin(value: string);
        _setSkin(url: string): Promise<void>;
        get source(): Texture;
        set source(value: Texture);
        get color(): string;
        set color(value: string);
        /**
         * 资源分组。
         */
        get group(): string;
        set group(value: string);
        get useSourceSize(): boolean;
        set useSourceSize(value: boolean);
        /**
         * @inheritDoc
         * @override
         */
        protected measureWidth(): number;
        /**
         * @inheritDoc
         * @override
         */
        protected measureHeight(): number;
        /**
         * @inheritDoc
         * @override
         */
        _setWidth(value: number): void;
        /**
         * @inheritDoc
         * @override
         */
        _setHeight(value: number): void;
        /**
         * <p>当前实例的位图 <code>AutoImage</code> 实例的有效缩放网格数据。</p>
         * <p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
         * <ul><li>例如："4,4,4,4,1"。</li></ul></p>
         * @see laya.ui.AutoBitmap#sizeGrid
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @inheritDoc
         * @override
         */
        set_dataSource(value: any): void;
    }
    /**
     * <code>ISelect</code> 接口，实现对象的 <code>selected</code> 属性和 <code>clickHandler</code> 选择回调函数处理器。
     */
    interface ISelect extends UIComponent {
        /**
         * 一个布尔值，表示是否被选择。
         */
        selected: boolean;
        /**
         * 对象的点击事件回掉函数处理器。
         */
        clickHandler: Handler;
    }
    type LabelFitContent = "no" | "yes" | "height";
    /**
     * 文本内容发生改变后调度。
     * @eventType laya.events.Event
     */
    /**
     * <p> <code>Label</code> 类用于创建显示对象以显示文本。</p>
     *
     * @example <caption>以下示例代码，创建了一个 <code>Label</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.Label;
     *		public class Label_Example
     *		{
     *			public function Label_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				onInit();
     *			}
     *			private function onInit():void
     *			{
     *				var label:Label = new Label();//创建一个 Label 类的实例对象 label 。
     *				label.font = "Arial";//设置 label 的字体。
     *				label.bold = true;//设置 label 显示为粗体。
     *				label.leading = 4;//设置 label 的行间距。
     *				label.wordWrap = true;//设置 label 自动换行。
     *				label.padding = "10,10,10,10";//设置 label 的边距。
     *				label.color = "#ff00ff";//设置 label 的颜色。
     *				label.text = "Hello everyone,我是一个可爱的文本！";//设置 label 的文本内容。
     *				label.x = 100;//设置 label 对象的属性 x 的值，用于控制 label 对象的显示位置。
     *				label.y = 100;//设置 label 对象的属性 y 的值，用于控制 label 对象的显示位置。
     *				label.width = 300;//设置 label 的宽度。
     *				label.height = 200;//设置 label 的高度。
     *				Laya.stage.addChild(label);//将 label 添加到显示列表。
     *				var passwordLabel:Label = new Label("请原谅我，我不想被人看到我心里话。");//创建一个 Label 类的实例对象 passwordLabel 。
     *				passwordLabel.asPassword = true;//设置 passwordLabel 的显示反式为密码显示。
     *				passwordLabel.x = 100;//设置 passwordLabel 对象的属性 x 的值，用于控制 passwordLabel 对象的显示位置。
     *				passwordLabel.y = 350;//设置 passwordLabel 对象的属性 y 的值，用于控制 passwordLabel 对象的显示位置。
     *				passwordLabel.width = 300;//设置 passwordLabel 的宽度。
     *				passwordLabel.color = "#000000";//设置 passwordLabel 的文本颜色。
     *				passwordLabel.bgColor = "#ccffff";//设置 passwordLabel 的背景颜色。
     *				passwordLabel.fontSize = 20;//设置 passwordLabel 的文本字体大小。
     *				Laya.stage.addChild(passwordLabel);//将 passwordLabel 添加到显示列表。
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * onInit();
     * function onInit(){
     *     var label = new laya.ui.Label();//创建一个 Label 类的实例对象 label 。
     *     label.font = "Arial";//设置 label 的字体。
     *     label.bold = true;//设置 label 显示为粗体。
     *     label.leading = 4;//设置 label 的行间距。
     *     label.wordWrap = true;//设置 label 自动换行。
     *     label.padding = "10,10,10,10";//设置 label 的边距。
     *     label.color = "#ff00ff";//设置 label 的颜色。
     *     label.text = "Hello everyone,我是一个可爱的文本！";//设置 label 的文本内容。
     *     label.x = 100;//设置 label 对象的属性 x 的值，用于控制 label 对象的显示位置。
     *     label.y = 100;//设置 label 对象的属性 y 的值，用于控制 label 对象的显示位置。
     *     label.width = 300;//设置 label 的宽度。
     *     label.height = 200;//设置 label 的高度。
     *     Laya.stage.addChild(label);//将 label 添加到显示列表。
     *     var passwordLabel = new laya.ui.Label("请原谅我，我不想被人看到我心里话。");//创建一个 Label 类的实例对象 passwordLabel 。
     *     passwordLabel.asPassword = true;//设置 passwordLabel 的显示反式为密码显示。
     *     passwordLabel.x = 100;//设置 passwordLabel 对象的属性 x 的值，用于控制 passwordLabel 对象的显示位置。
     *     passwordLabel.y = 350;//设置 passwordLabel 对象的属性 y 的值，用于控制 passwordLabel 对象的显示位置。
     *     passwordLabel.width = 300;//设置 passwordLabel 的宽度。
     *     passwordLabel.color = "#000000";//设置 passwordLabel 的文本颜色。
     *     passwordLabel.bgColor = "#ccffff";//设置 passwordLabel 的背景颜色。
     *     passwordLabel.fontSize = 20;//设置 passwordLabel 的文本字体大小。
     *     Laya.stage.addChild(passwordLabel);//将 passwordLabel 添加到显示列表。
     * }
     * @example
     * import Label = laya.ui.Label;
     * class Label_Example {
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         this.onInit();
     *     }
     *     private onInit(): void {
     *         var label: Label = new Label();//创建一个 Label 类的实例对象 label 。
     *         label.font = "Arial";//设置 label 的字体。
     *         label.bold = true;//设置 label 显示为粗体。
     *         label.leading = 4;//设置 label 的行间距。
     *         label.wordWrap = true;//设置 label 自动换行。
     *         label.padding = "10,10,10,10";//设置 label 的边距。
     *         label.color = "#ff00ff";//设置 label 的颜色。
     *         label.text = "Hello everyone,我是一个可爱的文本！";//设置 label 的文本内容。
     *         label.x = 100;//设置 label 对象的属性 x 的值，用于控制 label 对象的显示位置。
     *         label.y = 100;//设置 label 对象的属性 y 的值，用于控制 label 对象的显示位置。
     *         label.width = 300;//设置 label 的宽度。
     *         label.height = 200;//设置 label 的高度。
     *         Laya.stage.addChild(label);//将 label 添加到显示列表。
     *         var passwordLabel: Label = new Label("请原谅我，我不想被人看到我心里话。");//创建一个 Label 类的实例对象 passwordLabel 。
     *         passwordLabel.asPassword = true;//设置 passwordLabel 的显示反式为密码显示。
     *         passwordLabel.x = 100;//设置 passwordLabel 对象的属性 x 的值，用于控制 passwordLabel 对象的显示位置。
     *         passwordLabel.y = 350;//设置 passwordLabel 对象的属性 y 的值，用于控制 passwordLabel 对象的显示位置。
     *         passwordLabel.width = 300;//设置 passwordLabel 的宽度。
     *         passwordLabel.color = "#000000";//设置 passwordLabel 的文本颜色。
     *         passwordLabel.bgColor = "#ccffff";//设置 passwordLabel 的背景颜色。
     *         passwordLabel.fontSize = 20;//设置 passwordLabel 的文本字体大小。
     *         Laya.stage.addChild(passwordLabel);//将 passwordLabel 添加到显示列表。
     *     }
     * }
     * @see laya.display.Text
     */
    class Label extends UIComponent {
        /**
         * @private
         * 文本 <code>Text</code> 实例。
         */
        protected _tf: Text;
        protected _fitContent: LabelFitContent;
        /**
         * 创建一个新的 <code>Label</code> 实例。
         * @param text 文本内容字符串。
         */
        constructor(text?: string);
        /**
         * @override
         * @inheritDoc
        */
        protected createChildren(): void;
        protected _onPostLayout(): void;
        /**
         * 当前文本内容字符串。
         * @see laya.display.Text.text
         */
        get text(): string;
        set text(value: string);
        /**
         * @copy laya.display.Text#wordWrap
         */
        get wordWrap(): boolean;
        /**
         * @copy laya.display.Text#wordWrap
         */
        set wordWrap(value: boolean);
        /**
         * @copy laya.display.Text#color
         */
        get color(): string;
        set color(value: string);
        /**
         * @copy laya.display.Text#font
         */
        get font(): string;
        set font(value: string);
        /**
         * @copy laya.display.Text#align
         */
        get align(): string;
        set align(value: string);
        /**
         * @copy laya.display.Text#valign
         */
        get valign(): string;
        set valign(value: string);
        /**
         * @copy laya.display.Text#alignItems
         */
        get alignItems(): string;
        set alignItems(value: string);
        /**
         * @copy laya.display.Text#bold
         */
        get bold(): boolean;
        set bold(value: boolean);
        /**
         * @copy laya.display.Text#italic
         */
        get italic(): boolean;
        set italic(value: boolean);
        /**
         * @copy laya.display.Text#leading
         */
        get leading(): number;
        set leading(value: number);
        /**
         * @copy laya.display.Text#fontSize
         */
        get fontSize(): number;
        set fontSize(value: number);
        /**
         * <p>边距信息</p>
         * <p>"上边距，右边距，下边距 , 左边距（边距以像素为单位）"</p>
         */
        get padding(): string;
        set padding(value: string);
        /**
         * @copy laya.display.Text#bgColor
         */
        get bgColor(): string;
        set bgColor(value: string);
        /**
         * @copy laya.display.Text#borderColor
         */
        get borderColor(): string;
        set borderColor(value: string);
        /**
         * @copy laya.display.Text#stroke
         */
        get stroke(): number;
        set stroke(value: number);
        /**
         * @copy laya.display.Text#strokeColor
         */
        get strokeColor(): string;
        set strokeColor(value: string);
        get html(): boolean;
        /** 设置是否富文本，支持html语法 */
        set html(value: boolean);
        get ubb(): boolean;
        /** 设置是否使用UBB语法解析文本 */
        set ubb(value: boolean);
        get maxWidth(): number;
        /** 设置当文本达到最大允许的宽度时，自定换行，设置为0则此限制不生效。*/
        set maxWidth(value: number);
        get fitContent(): LabelFitContent;
        /** 设置文本框大小是否自动适应文本内容的大小。可取值为both或者height */
        set fitContent(value: LabelFitContent);
        /**
         * 文本控件实体 <code>Text</code> 实例。
         */
        get textField(): Text;
        /**
         * @inheritDoc
         * @override
         */
        protected measureWidth(): number;
        /**
         * @inheritDoc
         * @override
         */
        protected measureHeight(): number;
        /**
         * @inheritDoc
         * @override
         */
        get_width(): number;
        set_width(value: number): void;
        /**
         * @inheritDoc
         * @override
         */
        _setWidth(value: number): void;
        /**
         * @inheritDoc
         * @override
         */
        get_height(): number;
        set_height(value: number): void;
        /**
         * @inheritDoc
         * @override
         */
        _setHeight(value: number): void;
        /**
         * @inheritDoc
         * @override
         */
        set_dataSource(value: any): void;
        /**
         * @copy laya.display.Text#overflow
         */
        get overflow(): string;
        /**
         * @copy laya.display.Text#overflow
         */
        set overflow(value: string);
        /**
         * @copy laya.display.Text#underline
         */
        get underline(): boolean;
        /**
         * @copy laya.display.Text#underline
         */
        set underline(value: boolean);
        /**
         * @copy laya.display.Text#underlineColor
         */
        get underlineColor(): string;
        /**
         * @copy laya.display.Text#underlineColor
         */
        set underlineColor(value: string);
        /**
         * @copy laya.display.Text#ignoreLang
         */
        get ignoreLang(): boolean;
        /**
         * @copy laya.display.Text#ignoreLang
         */
        set ignoreLang(value: boolean);
        get templateVars(): Record<string, any>;
        set templateVars(value: Record<string, any> | boolean);
        setVar(name: string, value: any): Label;
    }
    /**
     * <code>LayoutBox</code> 是一个布局容器类。
     */
    class LayoutBox extends Box {
        /**@private */
        protected _space: number;
        /**@private */
        protected _align: string;
        /**@private */
        protected _itemChanged: boolean;
        /**
         * @inheritDoc
         * @override
        */
        addChild<T extends Node>(child: T): T;
        private onResize;
        /**
         * @inheritDoc
         * @override
        */
        addChildAt(child: Node, index: number): Node;
        /**
         *  @inheritDoc
         * @override
        */
        removeChildAt(index: number): Node;
        /** 刷新。*/
        refresh(): void;
        /**
         * 改变子对象的布局。
         */
        protected changeItems(): void;
        /** 子对象的间隔。*/
        get space(): number;
        set space(value: number);
        /** 子对象对齐方式。*/
        get align(): string;
        set align(value: string);
        /**
         * 排序项目列表。可通过重写改变默认排序规则。
         * @param items  项目列表。
         */
        protected sortItem(items: any[]): void;
        protected _setItemChanged(): void;
    }
    /**
     * 当对象的 <code>selectedIndex</code> 属性发生变化时调度。
     * @eventType laya.events.Event
     */
    /**
     * 渲染列表的单元项对象时调度。
     * @eventType Event.RENDER
     */
    /**
     * <code>List</code> 控件可显示项目列表。默认为垂直方向列表。可通过UI编辑器自定义列表。
     *
     * @example <caption>以下示例代码，创建了一个 <code>List</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.List;
     *		import laya.utils.Handler;
     *		public class List_Example
     *		{
     *			public function List_Example()
     *			{
     *				Laya.init(640, 800, "false");//设置游戏画布宽高、渲染模式。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load(["resource/ui/vscroll.png", "resource/ui/vscroll$bar.png", "resource/ui/vscroll$down.png", "resource/ui/vscroll$up.png"], Handler.create(this, onLoadComplete));
     *			}
     *			private function onLoadComplete():void
     *			{
     *				var arr:Array = [];//创建一个数组，用于存贮列表的数据信息。
     *				for (var i:int = 0; i &lt; 20; i++)
     *				{
     *					arr.push({label: "item" + i});
     *				}
     *				var list:List = new List();//创建一个 List 类的实例对象 list 。
     *				list.itemRender = Item;//设置 list 的单元格渲染器。
     *				list.repeatX = 1;//设置 list 的水平方向单元格数量。
     *				list.repeatY = 10;//设置 list 的垂直方向单元格数量。
     *				list.vScrollBarSkin = "resource/ui/vscroll.png";//设置 list 的垂直方向滚动条皮肤。
     *				list.array = arr;//设置 list 的列表数据源。
     *				list.pos(100, 100);//设置 list 的位置。
     *				list.selectEnable = true;//设置 list 可选。
     *				list.selectHandler = new Handler(this, onSelect);//设置 list 改变选择项执行的处理器。
     *				Laya.stage.addChild(list);//将 list 添加到显示列表。
     *			}
     *			private function onSelect(index:int):void
     *			{
     *				trace("当前选择的项目索引： index= ", index);
     *			}
     *		}
     *	}
     *	import laya.ui.Box;
     *	import laya.ui.Label;
     *	class Item extends Box
     *	{
     *		public function Item()
     *		{
     *			graphics.drawRect(0, 0, 100, 20,null, "#ff0000");
     *			var label:Label = new Label();
     *			label.text = "100000";
     *			label.name = "label";//设置 label 的name属性值。
     *			label.size(100, 20);
     *			addChild(label);
     *		}
     *	}
     * @example
     * (function (_super){
     *     function Item(){
     *         Item.__super.call(this);//初始化父类
     *         this.graphics.drawRect(0, 0, 100, 20, "#ff0000");
     *         var label = new laya.ui.Label();//创建一个 Label 类的实例对象 label 。
     *         label.text = "100000";//设置 label 的文本内容。
     *         label.name = "label";//设置 label 的name属性值。
     *         label.size(100, 20);//设置 label 的宽度、高度。
     *         this.addChild(label);//将 label 添加到显示列表。
     *     };
     *     Laya.class(Item,"mypackage.listExample.Item",_super);//注册类 Item 。
     * })(laya.ui.Box);
        
     * Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     * var res = ["resource/ui/vscroll.png", "resource/ui/vscroll$bar.png", "resource/ui/vscroll$down.png", "resource/ui/vscroll$up.png"];
     * Laya.loader.load(res, new laya.utils.Handler(this, onLoadComplete));//加载资源。
        
     * function onLoadComplete() {
     *     var arr = [];//创建一个数组，用于存贮列表的数据信息。
     *     for (var i = 0; i &lt; 20; i++) {
     *         arr.push({label: "item" + i});
     *     }
        
     *     var list = new laya.ui.List();//创建一个 List 类的实例对象 list 。
     *     list.itemRender = mypackage.listExample.Item;//设置 list 的单元格渲染器。
     *     list.repeatX = 1;//设置 list 的水平方向单元格数量。
     *     list.repeatY = 10;//设置 list 的垂直方向单元格数量。
     *     list.vScrollBarSkin = "resource/ui/vscroll.png";//设置 list 的垂直方向滚动条皮肤。
     *     list.array = arr;//设置 list 的列表数据源。
     *     list.pos(100, 100);//设置 list 的位置。
     *     list.selectEnable = true;//设置 list 可选。
     *     list.selectHandler = new laya.utils.Handler(this, onSelect);//设置 list 改变选择项执行的处理器。
     *     Laya.stage.addChild(list);//将 list 添加到显示列表。
     * }
        
     * function onSelect(index)
     * {
     *     console.log("当前选择的项目索引： index= ", index);
     * }
     *
     * @example
     * import List = laya.ui.List;
     * import Handler = laya.utils.Handler;
     * public class List_Example {
     *     public List_Example() {
     *         Laya.init(640, 800);//设置游戏画布宽高。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load(["resource/ui/vscroll.png", "resource/ui/vscroll$bar.png", "resource/ui/vscroll$down.png", "resource/ui/vscroll$up.png"], Handler.create(this, this.onLoadComplete));
     *     }
     *     private onLoadComplete(): void {
     *         var arr= [];//创建一个数组，用于存贮列表的数据信息。
     *         for (var i: number = 0; i &lt; 20; i++)
     *         {
     *             arr.push({ label: "item" + i });
     *         }
     *         var list: List = new List();//创建一个 List 类的实例对象 list 。
     *         list.itemRender = Item;//设置 list 的单元格渲染器。
     *         list.repeatX = 1;//设置 list 的水平方向单元格数量。
     *         list.repeatY = 10;//设置 list 的垂直方向单元格数量。
     *         list.vScrollBarSkin = "resource/ui/vscroll.png";//设置 list 的垂直方向滚动条皮肤。
     *         list.array = arr;//设置 list 的列表数据源。
     *         list.pos(100, 100);//设置 list 的位置。
     *         list.selectEnable = true;//设置 list 可选。
     *         list.selectHandler = new Handler(this, this.onSelect);//设置 list 改变选择项执行的处理器。
     *         Laya.stage.addChild(list);//将 list 添加到显示列表。
     *     }
     *     private onSelect(index: number): void {
     *         console.log("当前选择的项目索引： index= ", index);
     *     }
     * }
     * import Box = laya.ui.Box;
     * import Label = laya.ui.Label;
     * class Item extends Box {
     *     constructor() {
     *         this.graphics.drawRect(0, 0, 100, 20, null, "#ff0000");
     *         var label: Label = new Label();
     *         label.text = "100000";
     *         label.name = "label";//设置 label 的name属性值。
     *         label.size(100, 20);
     *         this.addChild(label);
     *     }
     * }
     */
    class List extends Box {
        /**改变 <code>List</code> 的选择项时执行的处理器，(默认返回参数： 项索引（index:int）)。*/
        selectHandler: Handler | null;
        /**单元格渲染处理器(默认返回参数cell:UIComponent,index:int)。*/
        renderHandler: Handler | null;
        /**单元格鼠标事件处理器(默认返回参数e:Event,index:int)。*/
        mouseHandler: Handler | null;
        /**指定是否可以选择，若值为true则可以选择，否则不可以选择。 @default false*/
        selectEnable: boolean;
        /**最大分页数。*/
        totalPage: number;
        /**禁用滚动条停止 */
        disableStopScroll: boolean;
        /**@private */
        protected _content: Box;
        /**@private */
        protected _scrollBar: ScrollBar | null;
        /**@private */
        protected _itemRender: any;
        /**@private */
        protected _repeatX: number;
        /**@private */
        protected _repeatY: number;
        /**@private */
        protected _repeatX2: number;
        /**@private */
        protected _repeatY2: number;
        /**@private */
        protected _spaceX: number;
        /**@private */
        protected _spaceY: number;
        /**@private */
        protected _cells: UIComponent[];
        /**@private */
        protected _array: any[] | null;
        /**@private */
        protected _startIndex: number;
        /**@private */
        protected _selectedIndex: number;
        /**@private */
        protected _page: number;
        /**@private */
        protected _isVertical: boolean;
        /**@private */
        protected _cellSize: number;
        /**@private */
        protected _cellOffset: number;
        /**@private */
        protected _isMoved: boolean;
        /**是否缓存内容，如果数据源较少，并且list内无动画，设置此属性为true能大大提高性能 */
        cacheContent: boolean;
        /**@private */
        protected _createdLine: number;
        /**@private */
        protected _cellChanged: boolean;
        /**@private */
        protected _offset: Point;
        /**@private */
        protected _usedCache: string | null;
        /**@private */
        protected _elasticEnabled: boolean;
        protected _scrollType: ScrollType;
        protected _vScrollBarSkin: string;
        protected _hScrollBarSkin: string;
        /**
         * @inheritDoc
         * @override
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @inheritDoc
         * @override
         */
        protected createChildren(): void;
        /**
         * @inheritDoc
         * @override
         */
        set cacheAs(value: string);
        /**
         * @inheritDoc
         * @override
         */
        get cacheAs(): string;
        private onScrollStart;
        private onScrollEnd;
        /**
         * 获取对 <code>List</code> 组件所包含的内容容器 <code>Box</code> 组件的引用。
         */
        get content(): Box;
        /**
         * 滚动类型
         */
        get scrollType(): ScrollType;
        set scrollType(value: ScrollType);
        /**
         * 垂直方向滚动条皮肤。
         */
        get vScrollBarSkin(): string;
        set vScrollBarSkin(value: string);
        /**
         * 水平方向滚动条皮肤。
         */
        get hScrollBarSkin(): string;
        set hScrollBarSkin(value: string);
        /**
         * 获取对 <code>List</code> 组件所包含的滚动条 <code>ScrollBar</code> 组件的引用。
         */
        get scrollBar(): ScrollBar | null;
        set scrollBar(value: ScrollBar | null);
        /**
         * 单元格渲染器。
         * <p><b>取值：</b>
         * <ol>
         * <li>单元格类对象。</li>
         * <li> UI 的 JSON 描述。</li>
         * </ol></p>
         * @implements
         */
        get itemRender(): any;
        set itemRender(value: any);
        /**
         * @inheritDoc
         * @override
        */
        _setWidth(value: number): void;
        /**
         * @inheritDoc
         * @override
        */
        _setHeight(value: number): void;
        /**
         * 水平方向显示的单元格数量。
         */
        get repeatX(): number;
        set repeatX(value: number);
        /**
         * 垂直方向显示的单元格数量。
         */
        get repeatY(): number;
        set repeatY(value: number);
        /**
         * 水平方向显示的单元格之间的间距（以像素为单位）。
         */
        get spaceX(): number;
        set spaceX(value: number);
        /**
         * 垂直方向显示的单元格之间的间距（以像素为单位）。
         */
        get spaceY(): number;
        set spaceY(value: number);
        /**
         * @private
         * 更改单元格的信息。
         * 在此销毁、创建单元格，并设置单元格的位置等属性。相当于此列表内容发送改变时调用此函数。
         */
        protected changeCells(): void;
        private _getOneCell;
        private _createItems;
        protected createItem(): UIComponent;
        /**
         * @private
         * 添加单元格。
         * @param cell 需要添加的单元格对象。
         */
        protected addCell(cell: UIComponent): void;
        onAfterDeserialize(): void;
        /**
         * 初始化单元格信息。
         */
        initItems(): void;
        /**
         * 设置可视区域大小。
         * <p>以（0，0，width参数，height参数）组成的矩形区域为可视区域。</p>
         * @param width 可视区域宽度。
         * @param height 可视区域高度。
         */
        setContentSize(width: number, height: number): void;
        /**
         * @private
         * 单元格的鼠标事件侦听处理函数。
         */
        protected onCellMouse(e: Event): void;
        /**
         * @private
         * 改变单元格的可视状态。
         * @param cell 单元格对象。
         * @param visable 是否显示。
         * @param index 单元格的属性 <code>index</code> 值。
         */
        protected changeCellState(cell: UIComponent, visible: boolean, index: number): void;
        /**
         * @inheritDoc
         * @override
        */
        protected _sizeChanged(): void;
        /**
         * @private
         * 滚动条的 <code>Event.CHANGE</code> 事件侦听处理函数。
         */
        protected onScrollBarChange(e?: Event | null): void;
        private posCell;
        /**
         * 表示当前选择的项索引。selectedIndex值更改会引起list重新渲染
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @private
         * 改变单元格的选择状态。
         */
        protected changeSelectStatus(): void;
        /**
         * 当前选中的单元格数据源。
         */
        get selectedItem(): any;
        set selectedItem(value: any);
        /**
         * 获取或设置当前选择的单元格对象。
         */
        get selection(): UIComponent;
        set selection(value: UIComponent);
        /**
         * 当前显示的单元格列表的开始索引。
         */
        get startIndex(): number;
        set startIndex(value: number);
        /**
         * @private
         * 渲染单元格列表。
         */
        protected renderItems(from?: number, to?: number): void;
        /**
         * 渲染一个单元格。
         * @param cell 需要渲染的单元格对象。
         * @param index 单元格索引。
         */
        protected renderItem(cell: UIComponent, index: number): void;
        private _bindData;
        /**
         * 列表数据源。
         */
        get array(): any[];
        private _preLen;
        set array(value: any[]);
        /**
         * 更新数据源，不刷新list，只增加滚动长度
         * @param	array 数据源
         */
        updateArray(array: any[]): void;
        /**
         * 列表的当前页码。
         */
        get page(): number;
        set page(value: number);
        /**
         * 列表的数据总个数。
         */
        get length(): number;
        /**
         * @inheritDoc
         * @override
        */
        set_dataSource(value: any): void;
        /**
         * 单元格集合。
         */
        get cells(): UIComponent[];
        /**是否开启橡皮筋效果*/
        get elasticEnabled(): boolean;
        set elasticEnabled(value: boolean);
        /**
         * 刷新列表数据源。
         */
        refresh(): void;
        /**
         * 获取单元格数据源。
         * @param index 单元格索引。
         */
        getItem(index: number): any;
        /**
         * 修改单元格数据源。
         * @param index 单元格索引。
         * @param source 单元格数据源。
         */
        changeItem(index: number, source: any): void;
        /**
         * 设置单元格数据源。
         * @param index 单元格索引。
         * @param source 单元格数据源。
         */
        setItem(index: number, source: any): void;
        /**
         * 添加单元格数据源。
         * @param source 数据源。
         */
        addItem(source: any): void;
        /**
         * 添加单元格数据源到对应的数据索引处。
         * @param souce 单元格数据源。
         * @param index 索引。
         */
        addItemAt(souce: any, index: number): void;
        /**
         * 通过数据源索引删除单元格数据源。
         * @param index 需要删除的数据源索引值。
         */
        deleteItem(index: number): void;
        /**
         * 通过可视单元格索引，获取单元格。
         * @param index 可视单元格索引。
         * @return 单元格对象。
         */
        getCell(index: number): UIComponent | null;
        /**
         * <p>滚动列表，以设定的数据索引对应的单元格为当前可视列表的第一项。</p>
         * @param index 单元格在数据列表中的索引。
         */
        scrollTo(index: number): void;
        /**
         * <p>缓动滚动列表，以设定的数据索引对应的单元格为当前可视列表的第一项。</p>
         * @param index 单元格在数据列表中的索引。
         * @param time	缓动时间。
         * @param complete	缓动结束回掉
         */
        tweenTo(index: number, time?: number, complete?: Handler | null): void;
        /**@private */
        protected _setCellChanged(): void;
        /**@override */
        protected commitMeasure(): void;
    }
    /**
     * 微信开放数据展示组件，直接实例本组件，即可根据组件宽高，位置，以最优的方式显示开放域数据
     */
    class OpenDataContextView extends UIComponent {
        private _fps;
        constructor();
        get fps(): number;
        set fps(value: number);
        /**
         * @override
         */
        _onActive(): void;
        /**
         * @override
         */
        _onInActive(): void;
        private _onLoop;
        /**
         * @override
         */
        _setWidth(value: number): void;
        /**
         * @override
         */
        _setHeight(value: number): void;
        /**
         * @override
         */
        set x(value: number);
        /**
         * @override
         */
        get x(): number;
        /**
         * @override
         */
        set y(value: number);
        /**
         * @override
         */
        get y(): number;
        private updateViewPort;
        /**向开放数据域发送消息*/
        postMsg(msg: any): void;
    }
    /**
     * <code>Panel</code> 是一个面板容器类。
     */
    class Panel extends Box {
        /**@private */
        protected _content: Box;
        /**@private */
        protected _vScrollBar: VScrollBar;
        /**@private */
        protected _hScrollBar: HScrollBar;
        /**@private */
        protected _scrollChanged: boolean;
        /**@private */
        protected _usedCache: string;
        /**@private */
        protected _elasticEnabled: boolean;
        protected _scrollType: ScrollType;
        protected _vScrollBarSkin: string;
        protected _hScrollBarSkin: string;
        /**
         * 创建一个新的 <code>Panel</code> 类实例。
         * <p>在 <code>Panel</code> 构造函数中设置属性width、height的值都为100。</p>
         */
        constructor();
        /**@inheritDoc @override*/
        destroy(destroyChild?: boolean): void;
        /**@inheritDoc @override*/
        destroyChildren(): void;
        /**@inheritDoc @override*/
        protected createChildren(): void;
        /**@inheritDoc @override*/
        addChild<T extends Node>(child: T): T;
        /**
         * @private
         * 子对象的 <code>Event.RESIZE</code> 事件侦听处理函数。
         */
        private onResize;
        /**@inheritDoc @override*/
        addChildAt(child: Node, index: number): Node;
        /**@inheritDoc @override*/
        removeChild(child: Node): Node;
        /**@inheritDoc @override*/
        removeChildAt(index: number): Node;
        /**@inheritDoc @override*/
        removeChildren(beginIndex?: number, endIndex?: number): Node;
        /**@inheritDoc @override*/
        getChildAt(index: number): Node;
        /**@inheritDoc @override*/
        getChildByName(name: string): Node;
        /**@inheritDoc @override*/
        getChildIndex(child: Node): number;
        /**@inheritDoc @override*/
        get numChildren(): number;
        /**@private */
        private changeScroll;
        /**@inheritDoc @override*/
        protected _sizeChanged(): void;
        /**
         * @private
         * 获取内容宽度（以像素为单位）。
         */
        get contentWidth(): number;
        /**
         * @private
         * 获取内容高度（以像素为单位）。
         */
        get contentHeight(): number;
        /**
         * @private
         * 设置内容的宽度、高度（以像素为单位）。
         * @param width 宽度。
         * @param height 高度。
         */
        private setContentSize;
        /**
         * @inheritDoc
         * @override
         */
        _setWidth(value: number): void;
        /**@inheritDoc @override*/
        _setHeight(value: number): void;
        get scrollType(): ScrollType;
        set scrollType(value: ScrollType);
        private createHScrollBar;
        private createVScrollBar;
        /**
         * 垂直方向滚动条皮肤。
         */
        get vScrollBarSkin(): string;
        set vScrollBarSkin(value: string);
        /**
         * 水平方向滚动条皮肤。
         */
        get hScrollBarSkin(): string;
        set hScrollBarSkin(value: string);
        /**
         * 垂直方向滚动条对象。
         */
        get vScrollBar(): ScrollBar;
        /**
         * 水平方向滚动条对象。
         */
        get hScrollBar(): ScrollBar;
        /**
         * 获取内容容器对象。
         */
        get content(): Sprite;
        /**
         * @private
         * 滚动条的<code><code>Event.MOUSE_DOWN</code>事件侦听处理函数。</code>事件侦听处理函数。
         * @param scrollBar 滚动条对象。
         * @param e Event 对象。
         */
        protected onScrollBarChange(scrollBar: ScrollBar): void;
        /**
         * <p>滚动内容容器至设定的垂直、水平方向滚动条位置。</p>
         * @param x 水平方向滚动条属性value值。滚动条位置数字。
         * @param y 垂直方向滚动条属性value值。滚动条位置数字。
         */
        scrollTo(x?: number, y?: number): void;
        /**
         * 刷新滚动内容。
         */
        refresh(): void;
        /**@inheritDoc @override*/
        set cacheAs(value: string);
        /**
         * @inheritDoc
         * @override
         */
        get cacheAs(): string;
        /**是否开启橡皮筋效果*/
        get elasticEnabled(): boolean;
        set elasticEnabled(value: boolean);
        private onScrollStart;
        private onScrollEnd;
        /**@private */
        protected _setScrollChanged(): void;
    }
    /**
     * 值发生改变后调度。
     * @eventType laya.events.Event
     */
    /**
     * <code>ProgressBar</code> 组件显示内容的加载进度。
     * @example <caption>以下示例代码，创建了一个新的 <code>ProgressBar</code> 实例，设置了它的皮肤、位置、宽高、网格等信息，并添加到舞台上。</caption>
     * package
     *	{
     *		import laya.ui.ProgressBar;
     *		import laya.utils.Handler;
     *		public class ProgressBar_Example
     *		{
     *			private var progressBar:ProgressBar;
     *			public function ProgressBar_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load(["resource/ui/progress.png", "resource/ui/progress$bar.png"], Handler.create(this, onLoadComplete));//加载资源。
     *			}
     *			private function onLoadComplete():void
     *			{
     *				progressBar = new ProgressBar("resource/ui/progress.png");//创建一个 ProgressBar 类的实例对象 progressBar 。
     *				progressBar.x = 100;//设置 progressBar 对象的属性 x 的值，用于控制 progressBar 对象的显示位置。
     *				progressBar.y = 100;//设置 progressBar 对象的属性 y 的值，用于控制 progressBar 对象的显示位置。
     *				progressBar.value = 0.3;//设置 progressBar 的进度值。
     *				progressBar.width = 200;//设置 progressBar 的宽度。
     *				progressBar.height = 50;//设置 progressBar 的高度。
     *				progressBar.sizeGrid = "5,10,5,10";//设置 progressBar 的网格信息。
     *				progressBar.changeHandler = new Handler(this, onChange);//设置 progressBar 的value值改变时执行的处理器。
     *				Laya.stage.addChild(progressBar);//将 progressBar 添加到显示列表。
     *				Laya.timer.once(3000, this, changeValue);//设定 3000ms（毫秒）后，执行函数changeValue。
     *			}
     *			private function changeValue():void
     *			{
     *				trace("改变进度条的进度值。");
     *				progressBar.value = 0.6;
     *			}
     *			private function onChange(value:Number):void
     *			{
     *				trace("进度发生改变： value=" ,value);
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * var res = ["resource/ui/progress.png", "resource/ui/progress$bar.png"];
     * Laya.loader.load(res, laya.utils.Handler.create(this, onLoadComplete));//加载资源。
     * function onLoadComplete()
     * {
     *     progressBar = new laya.ui.ProgressBar("resource/ui/progress.png");//创建一个 ProgressBar 类的实例对象 progressBar 。
     *     progressBar.x = 100;//设置 progressBar 对象的属性 x 的值，用于控制 progressBar 对象的显示位置。
     *     progressBar.y = 100;//设置 progressBar 对象的属性 y 的值，用于控制 progressBar 对象的显示位置。
     *     progressBar.value = 0.3;//设置 progressBar 的进度值。
     *     progressBar.width = 200;//设置 progressBar 的宽度。
     *     progressBar.height = 50;//设置 progressBar 的高度。
     *     progressBar.sizeGrid = "10,5,10,5";//设置 progressBar 的网格信息。
     *     progressBar.changeHandler = new laya.utils.Handler(this, onChange);//设置 progressBar 的value值改变时执行的处理器。
     *     Laya.stage.addChild(progressBar);//将 progressBar 添加到显示列表。
     *     Laya.timer.once(3000, this, changeValue);//设定 3000ms（毫秒）后，执行函数changeValue。
     * }
     * function changeValue()
     * {
     *     console.log("改变进度条的进度值。");
     *     progressBar.value = 0.6;
     * }
     * function onChange(value)
     * {
     *     console.log("进度发生改变： value=" ,value);
     * }
     * @example
     * import ProgressBar = laya.ui.ProgressBar;
     * import Handler = laya.utils.Handler;
     * class ProgressBar_Example {
     *     private progressBar: ProgressBar;
     *     public ProgressBar_Example() {
     *         Laya.init(640, 800);//设置游戏画布宽高。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load(["resource/ui/progress.png", "resource/ui/progress$bar.png"], Handler.create(this, this.onLoadComplete));//加载资源。
     *     }
     *     private onLoadComplete(): void {
     *         this.progressBar = new ProgressBar("resource/ui/progress.png");//创建一个 ProgressBar 类的实例对象 progressBar 。
     *         this.progressBar.x = 100;//设置 progressBar 对象的属性 x 的值，用于控制 progressBar 对象的显示位置。
     *         this.progressBar.y = 100;//设置 progressBar 对象的属性 y 的值，用于控制 progressBar 对象的显示位置。
     *         this.progressBar.value = 0.3;//设置 progressBar 的进度值。
     *         this.progressBar.width = 200;//设置 progressBar 的宽度。
     *         this.progressBar.height = 50;//设置 progressBar 的高度。
     *         this.progressBar.sizeGrid = "5,10,5,10";//设置 progressBar 的网格信息。
     *         this.progressBar.changeHandler = new Handler(this, this.onChange);//设置 progressBar 的value值改变时执行的处理器。
     *         Laya.stage.addChild(this.progressBar);//将 progressBar 添加到显示列表。
     *         Laya.timer.once(3000, this, this.changeValue);//设定 3000ms（毫秒）后，执行函数changeValue。
     *     }
     *     private changeValue(): void {
     *         console.log("改变进度条的进度值。");
     *         this.progressBar.value = 0.6;
     *     }
     *     private onChange(value: number): void {
     *         console.log("进度发生改变： value=", value);
     *     }
     * }
     */
    class ProgressBar extends UIComponent {
        /**
         * 当 <code>ProgressBar</code> 实例的 <code>value</code> 属性发生变化时的函数处理器。
         * <p>默认返回参数<code>value</code> 属性（进度值）。</p>
         */
        changeHandler: Handler;
        /**@private */
        protected _bg: Image;
        /**@private */
        protected _bar: Image;
        /**@private */
        protected _skin: string;
        /**@private */
        protected _value: number;
        /**
         * 创建一个新的 <code>ProgressBar</code> 类实例。
         * @param skin 皮肤地址。
         */
        constructor(skin?: string);
        /**
         * @inheritDoc
         * @override
        */
        destroy(destroyChild?: boolean): void;
        /**
         * @inheritDoc
         * @override
        */
        protected createChildren(): void;
        /**
         * @copy laya.ui.Image#skin
         */
        get skin(): string;
        set skin(value: string);
        _setSkin(url: string): Promise<void>;
        protected _skinLoaded(): void;
        /**
         * @inheritDoc
         * @override
        */
        protected measureWidth(): number;
        /**
         * @inheritDoc
         * @override
        */
        protected measureHeight(): number;
        /**
         * 当前的进度量。
         * <p><b>取值：</b>介于0和1之间。</p>
         */
        get value(): number;
        set value(num: number);
        /**
         * @private
         * 更改进度值的显示。
         */
        protected changeValue(): void;
        /**
         * 获取进度条对象。
         */
        get bar(): Image;
        /**
         * 获取背景条对象。
         */
        get bg(): Image;
        /**
         * <p>当前 <code>ProgressBar</code> 实例的进度条背景位图（ <code>Image</code> 实例）的有效缩放网格数据。</p>
         * <p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
         * <ul><li>例如："4,4,4,4,1"</li></ul></p>
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @inheritDoc
         * @override
        */
        set_width(value: number): void;
        /**
         * @inheritDoc
         * @override
        */
        set_dataSource(value: any): void;
    }
    /**
     * <code>Radio</code> 控件使用户可在一组互相排斥的选择中做出一种选择。
     * 用户一次只能选择 <code>Radio</code> 组中的一个成员。选择未选中的组成员将取消选择该组中当前所选的 <code>Radio</code> 控件。
     * @see laya.ui.RadioGroup
     */
    class Radio extends Button {
        /**@private */
        protected _value: any;
        /**
         * 创建一个新的 <code>Radio</code> 类实例。
         * @param skin 皮肤。
         * @param label 标签。
         */
        constructor(skin?: string, label?: string);
        /**
         * @override
         */
        protected preinitialize(): void;
        /**
         * @inheritDoc
         * @override
         * */
        protected initialize(): void;
        /**
         * @private
         * 对象的<code>Event.CLICK</code>事件侦听处理函数。
         */
        protected onClick(e: Event): void;
        /**
         * 获取或设置 <code>Radio</code> 关联的可选用户定义值。
         */
        get value(): any;
        set value(obj: any);
        protected changeClips(): void;
        _setWidth(value: number): void;
    }
    /**
     * 当 <code>Group</code> 实例的 <code>selectedIndex</code> 属性发生变化时调度。
     * @eventType laya.events.Event
     */
    /**
     * <code>RadioGroup</code> 控件定义一组 <code>Radio</code> 控件，这些控件相互排斥；
     * 因此，用户每次只能选择一个 <code>Radio</code> 控件。
     *
     * @example <caption>以下示例代码，创建了一个 <code>RadioGroup</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.Radio;
     *		import laya.ui.RadioGroup;
     *		import laya.utils.Handler;
     *		public class RadioGroup_Example
     *		{
     *			public function RadioGroup_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load(["resource/ui/radio.png"], Handler.create(this, onLoadComplete));//加载资源。
     *			}
     *			private function onLoadComplete():void
     *			{
     *				var radioGroup:RadioGroup = new RadioGroup();//创建一个 RadioGroup 类的实例对象 radioGroup 。
     *				radioGroup.pos(100, 100);//设置 radioGroup 的位置信息。
     *				radioGroup.labels = "item0,item1,item2";//设置 radioGroup 的标签集。
     *				radioGroup.skin = "resource/ui/radio.png";//设置 radioGroup 的皮肤。
     *				radioGroup.space = 10;//设置 radioGroup 的项间隔距离。
     *				radioGroup.selectHandler = new Handler(this, onSelect);//设置 radioGroup 的选择项发生改变时执行的处理器。
     *				Laya.stage.addChild(radioGroup);//将 radioGroup 添加到显示列表。
     *			}
     *			private function onSelect(index:int):void
     *			{
     *				trace("当前选择的单选按钮索引: index= ", index);
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高、渲染模式
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * Laya.loader.load(["resource/ui/radio.png"], laya.utils.Handler.create(this, onLoadComplete));
     * function onLoadComplete() {
     *     var radioGroup= new laya.ui.RadioGroup();//创建一个 RadioGroup 类的实例对象 radioGroup 。
     *     radioGroup.pos(100, 100);//设置 radioGroup 的位置信息。
     *     radioGroup.labels = "item0,item1,item2";//设置 radioGroup 的标签集。
     *     radioGroup.skin = "resource/ui/radio.png";//设置 radioGroup 的皮肤。
     *     radioGroup.space = 10;//设置 radioGroup 的项间隔距离。
     *     radioGroup.selectHandler = new laya.utils.Handler(this, onSelect);//设置 radioGroup 的选择项发生改变时执行的处理器。
     *     Laya.stage.addChild(radioGroup);//将 radioGroup 添加到显示列表。
     * }
     * function onSelect(index) {
     *     console.log("当前选择的单选按钮索引: index= ", index);
     * }
     * @example
     * import Radio = laya.ui.Radio;
     * import RadioGroup = laya.ui.RadioGroup;
     * import Handler = laya.utils.Handler;
     * class RadioGroup_Example {
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load(["resource/ui/radio.png"], Handler.create(this, this.onLoadComplete));//加载资源。
     *     }
     *     private onLoadComplete(): void {
     *         var radioGroup: RadioGroup = new RadioGroup();//创建一个 RadioGroup 类的实例对象 radioGroup 。
     *         radioGroup.pos(100, 100);//设置 radioGroup 的位置信息。
     *         radioGroup.labels = "item0,item1,item2";//设置 radioGroup 的标签集。
     *         radioGroup.skin = "resource/ui/radio.png";//设置 radioGroup 的皮肤。
     *         radioGroup.space = 10;//设置 radioGroup 的项间隔距离。
     *         radioGroup.selectHandler = new Handler(this, this.onSelect);//设置 radioGroup 的选择项发生改变时执行的处理器。
     *         Laya.stage.addChild(radioGroup);//将 radioGroup 添加到显示列表。
     *     }
     *     private onSelect(index: number): void {
     *         console.log("当前选择的单选按钮索引: index= ", index);
     *     }
     * }
     */
    class RadioGroup extends UIGroup {
        /**@inheritDoc
         * @override
        */
        protected createItem(skin: string, label: string): Sprite;
    }
    /**
     * 自适应缩放容器，容器设置大小后，容器大小始终保持stage大小，子内容按照原始最小宽高比缩放
     */
    class ScaleBox extends Box {
        private _oldW;
        private _oldH;
        /**
         * @override
         */
        onEnable(): void;
        /**
         * @override
         */
        onDisable(): void;
        private onResize;
        /**
         * @override
         */
        set_width(value: number): void;
        /**
         * @override
         */
        set_height(value: number): void;
    }
    /**
     * 滚动条滑块位置发生变化后调度。
     * @eventType laya.events.Event
     */
    /**
     * 开始滑动。
     * @eventType laya.events.Event
     */
    /**
     * 结束滑动。
     * @eventType laya.events.Event
     */
    /**
     * <code>ScrollBar</code> 组件是一个滚动条组件。
     * <p>当数据太多以至于显示区域无法容纳时，最终用户可以使用 <code>ScrollBar</code> 组件控制所显示的数据部分。</p>
     * <p> 滚动条由四部分组成：两个箭头按钮、一个轨道和一个滑块。 </p>	 *
     *
     * @see laya.ui.VScrollBar
     * @see laya.ui.HScrollBar
     */
    class ScrollBar extends UIComponent {
        /** 设置全局的滚动速度变化曲线函数 */
        static easeFunction: typeof Ease.sineOut;
        /**滚动衰减系数*/
        rollRatio: number;
        /**滚动变化时回调，回传value参数。*/
        changeHandler: Handler;
        /**是否缩放滑动条，默认值为true。 */
        scaleBar: boolean;
        /**一个布尔值，指定是否自动隐藏滚动条(无需滚动时)，默认值为false。*/
        autoHide: boolean;
        /**橡皮筋效果极限距离，0为没有橡皮筋效果。*/
        elasticDistance: number;
        /**橡皮筋回弹时间，单位为毫秒。*/
        elasticBackTime: number;
        /**上按钮 */
        upButton: Button;
        /**下按钮 */
        downButton: Button;
        /**滑条 */
        slider: Slider;
        /**顶部移动限制（达到限制后，会抛出dragTopLimit事件，配合stopMoveLimit()，可让开发者做一些动态数据更新的操作）*/
        topMoveLimit: number;
        /**底部移动限制（达到限制后，会抛出dragTopLimit事件，配合stopMoveLimit()，可让开发者做一些动态数据更新的操作）*/
        bottomMoveLimit: number;
        /** 调用滚动停止接口stopMoveLimit时，是否禁止内容的拖拽 */
        disableDrag: boolean;
        /**@private */
        protected _showButtons: boolean;
        /**@private */
        protected _scrollSize: number;
        /**@private */
        protected _skin: string;
        /**@private */
        protected _thumbPercent: number;
        /**@private */
        protected _target: Sprite;
        /**@private */
        protected _lastPoint: Point;
        /**@private */
        protected _lastOffset: number;
        /**@private */
        protected _checkElastic: boolean;
        /**@private */
        protected _isElastic: boolean;
        /**@private */
        protected _value: number;
        /**@private */
        protected _hide: boolean;
        /**@private */
        protected _clickOnly: boolean;
        /**@private */
        protected _offsets: any[];
        /**@private */
        protected _touchScrollEnable: boolean;
        /**@private */
        protected _mouseWheelEnable: boolean;
        /**
         * 创建一个新的 <code>ScrollBar</code> 实例。
         * @param skin 皮肤资源地址。
         */
        constructor(skin?: string);
        /**
         * @inheritDoc
         * @override
        */
        destroy(destroyChild?: boolean): void;
        /**
         * @override
         */
        protected createChildren(): void;
        /**
         * @override
         */
        protected initialize(): void;
        /**
         * @private
         * 滑块位置发生改变的处理函数。
         */
        protected onSliderChange(): void;
        /**
         * @private
         * 向上和向下按钮的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
         */
        protected onButtonMouseDown(e: Event): void;
        /**@private */
        protected startLoop(isUp: boolean): void;
        /**@private */
        protected slide(isUp: boolean): void;
        /**
         * @private
         * 舞台的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
         */
        protected onStageMouseUp(e: Event): void;
        /**
         * @copy laya.ui.Image#skin
         */
        get skin(): string;
        set skin(value: string);
        _setSkin(url: string): Promise<void>;
        protected _skinLoaded(): void;
        /**
         * @private
         * 更改对象的皮肤及位置。
         */
        protected changeScrollBar(): void;
        /**
         * @inheritDoc
         * @override
        */
        protected _sizeChanged(): void;
        /**@private */
        private resetPositions;
        /**@private */
        protected resetButtonPosition(): void;
        /**
         * @inheritDoc
         * @override
        */
        protected measureWidth(): number;
        /**
         * @inheritDoc
         * @override
        */
        protected measureHeight(): number;
        /**
         * 设置滚动条信息。
         * @param min 滚动条最小位置值。
         * @param max 滚动条最大位置值。
         * @param value 滚动条当前位置值。
         */
        setScroll(min: number, max: number, value?: number): void;
        /**
         * 获取或设置表示最高滚动位置的数字。
         */
        get max(): number;
        set max(value: number);
        /**
         * 获取或设置表示最低滚动位置的数字。
         */
        get min(): number;
        set min(value: number);
        /**
         * 获取或设置表示当前滚动位置的数字。
         */
        get value(): number;
        set value(v: number);
        /**
         * 一个布尔值，指示滚动条是否为垂直滚动。如果值为true，则为垂直滚动，否则为水平滚动。
         * <p>默认值为：true。</p>
         */
        get isVertical(): boolean;
        set isVertical(value: boolean);
        /**
         * <p>当前实例的 <code>Slider</code> 实例的有效缩放网格数据。</p>
         * <p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
         * <ul><li>例如："4,4,4,4,1"</li></ul></p>
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**获取或设置一个值，该值表示按下滚动条轨道时页面滚动的增量。 */
        get scrollSize(): number;
        set scrollSize(value: number);
        /**
         * @inheritDoc
         * @override
         */
        set_dataSource(value: any): void;
        /**获取或设置一个值，该值表示滑条长度比例，值为：（0-1）。 */
        get thumbPercent(): number;
        set thumbPercent(value: number);
        /**
         * 设置滚动对象。
         * @see laya.ui.TouchScroll#target
         */
        get target(): Sprite;
        set target(value: Sprite);
        /**是否隐藏滚动条，不显示滚动条，但是可以正常滚动，默认为false。*/
        get hide(): boolean;
        set hide(value: boolean);
        /**一个布尔值，指定是否显示向上、向下按钮，默认值为true。*/
        get showButtons(): boolean;
        set showButtons(value: boolean);
        /**一个布尔值，指定是否开启触摸，默认值为true。*/
        get touchScrollEnable(): boolean;
        set touchScrollEnable(value: boolean);
        /** 一个布尔值，指定是否滑轮滚动，默认值为true。*/
        get mouseWheelEnable(): boolean;
        set mouseWheelEnable(value: boolean);
        /**@private */
        protected onTargetMouseWheel(e: Event): void;
        isLockedFun: Function;
        /**@private */
        protected onTargetMouseDown(e: Event): void;
        startDragForce(): void;
        private cancelDragOp;
        triggerDownDragLimit: Function;
        triggerUpDragLimit: Function;
        /** 暂停滚动的重载方法-add:xiaosong */
        stopMoveLimit: Function;
        private checkTriggers;
        get lastOffset(): number;
        startTweenMoveForce(lastOffset: number): void;
        /**@private */
        protected loop(): void;
        /**@private */
        protected onStageMouseUp2(e: Event): void;
        /**@private */
        private elasticOver;
        /**@private */
        protected tweenMove(maxDistance: number): void;
        /**
         * 停止滑动。
         */
        stopScroll(): void;
        /**
         * 滚动的刻度值，滑动数值为tick的整数倍。默认值为1。
         */
        get tick(): number;
        set tick(value: number);
        /** 恢复到正常的弹性缓动效果 */
        backToNormal(): void;
        private _backToNormal;
    }
    /**
     * 移动滑块位置时调度。
     * @eventType laya.events.Event
     */
    /**
     * 移动滑块位置完成（用户鼠标抬起）后调度。
     * @eventType @eventType laya.events.EventD
     *
     */
    /**
     * 使用 <code>Slider</code> 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。
     * <p>滑块的当前值由滑块端点（对应于滑块的最小值和最大值）之间滑块的相对位置确定。</p>
     * <p>滑块允许最小值和最大值之间特定间隔内的值。滑块还可以使用数据提示显示其当前值。</p>
     *
     * @see laya.ui.HSlider
     * @see laya.ui.VSlider
     */
    class Slider extends UIComponent {
        /** @private 获取对 <code>Slider</code> 组件所包含的 <code>Label</code> 组件的引用。*/
        static label: Label;
        /**
         * 数据变化处理器。
         * <p>默认回调参数为滑块位置属性 <code>value</code>属性值：Number 。</p>
         */
        changeHandler: Handler;
        /**
         * 一个布尔值，指示是否为垂直滚动。如果值为true，则为垂直方向，否则为水平方向。
         * <p>默认值为：true。</p>
         * @default true
         */
        isVertical: boolean;
        /**
         * 一个布尔值，指示是否显示标签。
         * @default true
         */
        showLabel: boolean;
        /**
         * 一个布尔值，指示是否显示进度条。
         */
        protected _showProgress: boolean;
        /**@private */
        protected _allowClickBack: boolean;
        /**@private */
        protected _max: number;
        /**@private */
        protected _min: number;
        /**@private */
        protected _tick: number;
        /**@private */
        protected _value: number;
        /**@private */
        protected _skin: string;
        /**@private */
        protected _bg: Image;
        /**@private */
        protected _progress: Image;
        /**@private */
        protected _bar: Button;
        /**@private */
        protected _tx: number;
        /**@private */
        protected _ty: number;
        /**@private */
        protected _maxMove: number;
        /**@private */
        protected _globalSacle: Point;
        /**
         * 创建一个新的 <code>Slider</code> 类示例。
         * @param skin 皮肤。
         */
        constructor(skin?: string);
        /**
         *@inheritDoc
         @override
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @inheritDoc
         * @override
        */
        protected createChildren(): void;
        /**
         * @inheritDoc
         * @override
        */
        protected initialize(): void;
        /**
         * @private
         * 滑块的的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
         */
        protected onBarMouseDown(e: Event): void;
        /**
         * @private
         * 显示标签。
         */
        protected showValueText(): void;
        /**
         * @private
         * 隐藏标签。
         */
        protected hideValueText(): void;
        /**
         * @private
         */
        private mouseUp;
        /**
         * @private
         */
        private mouseMove;
        /**
         * @private
         */
        protected sendChangeEvent(type?: string): void;
        /**
         * @copy laya.ui.Image#skin
         */
        get skin(): string;
        set skin(value: string);
        get showProgress(): boolean;
        set showProgress(value: boolean);
        _setSkin(url: string): Promise<void>;
        protected _skinLoaded(): void;
        /**
         * @private
         * 设置滑块的位置信息。
         */
        protected setBarPoint(): void;
        /**@inheritDoc @override*/
        protected measureWidth(): number;
        /**
         * @inheritDoc
         * @override
        */
        protected measureHeight(): number;
        /**
         * @inheritDoc
         * @override
        */
        protected _sizeChanged(): void;
        /**
         * <p>当前实例的背景图（ <code>Image</code> ）和滑块按钮（ <code>Button</code> ）实例的有效缩放网格数据。</p>
         * <p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
         * <ul><li>例如："4,4,4,4,1"</li></ul></p>
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * 设置滑动条的信息。
         * @param min 滑块的最小值。
         * @param max 滑块的最小值。
         * @param value 滑块的当前值。
         */
        setSlider(min: number, max: number, value?: number): void;
        /**
         * 滑动的刻度值，滑动数值为tick的整数倍。默认值为1。
         */
        get tick(): number;
        set tick(value: number);
        /**
         * @private
         * 改变滑块的位置值。
         */
        changeValue(): void;
        /**
         * 获取或设置表示最高位置的数字。 默认值为100。
         */
        get max(): number;
        set max(value: number);
        /**
         * 获取或设置表示最低位置的数字。 默认值为0。
         */
        get min(): number;
        set min(value: number);
        /**
         * 获取或设置表示当前滑块位置的数字。
         */
        get value(): number;
        set value(num: number);
        /**
         * 一个布尔值，指定是否允许通过点击滑动条改变 <code>Slider</code> 的 <code>value</code> 属性值。
         */
        get allowClickBack(): boolean;
        set allowClickBack(value: boolean);
        /**
         * @private
         * 滑动条的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
         */
        protected onBgMouseDown(e: Event): void;
        /**
         * @inheritDoc
         * @override
         */
        set_dataSource(value: any): void;
        /**
         * 表示滑块按钮的引用。
         */
        get bar(): Button;
    }
    class StatUI implements IStatUI {
        private _txt;
        private _sp;
        private _view;
        private _toggleView;
        private _toggleSprite;
        private _checkBoxArray;
        private _show;
        private _showToggle;
        /**
         * @override
         * 显示性能统计信息。
         * @param	x X轴显示位置。
         * @param	y Y轴显示位置。
         */
        show(x?: number, y?: number, views?: Array<StatUIParams>): void;
        showToggle(x?: number, y?: number, views?: Array<StatToggleUIParams>): void;
        /**
        * @override
        * 隐藏性能统计信息。
        */
        hide(): void;
        update(): void;
        private createUI;
        private createToggleUI;
        render(ctx: any, x: number, y: number): void;
    }
    /**
     * <code>Styles</code> 定义了组件常用的样式属性。
     */
    class Styles {
        /**
         * 默认九宫格信息。
         * @see laya.ui.AutoBitmap#sizeGrid
         */
        static defaultSizeGrid: any[];
        /**
         * 标签颜色。
         */
        static labelColor: string;
        /**
         * 标签的边距。
         * <p><b>格式：</b>[上边距，右边距，下边距，左边距]。</p>
         */
        static labelPadding: any[];
        /**
         * 标签的边距。
         * <p><b>格式：</b>[上边距，右边距，下边距，左边距]。</p>
         */
        static inputLabelPadding: any[];
        /**
         * 按钮皮肤的状态数，支持1,2,3三种状态值。
         */
        static buttonStateNum: number;
        /**
         * 按钮标签颜色。
         * <p><b>格式：</b>[upColor,overColor,downColor]。</p>
         */
        static buttonLabelColors: any[];
        /**
         * 下拉框项颜色。
         * <p><b>格式：</b>[overBgColor,overLabelColor,outLabelColor,borderColor,bgColor]。</p>
         */
        static comboBoxItemColors: any[];
        /**
         * 滚动条的最小值。
         */
        static scrollBarMinNum: number;
        /**
         * 长按按钮，等待时间，使其可激活连续滚动。
         */
        static scrollBarDelayTime: number;
    }
    enum ScrollType {
        None = 0,
        Horizontal = 1,
        Vertical = 2,
        Both = 3
    }
    /**
     * 当 <code>Group</code> 实例的 <code>selectedIndex</code> 属性发生变化时调度。
     * @eventType laya.events.Event
     */
    /**
     * <code>Tab</code> 组件用来定义选项卡按钮组。	 *
     * <p>属性：<code>selectedIndex</code> 的默认值为-1。</p>
     *
     * @example <caption>以下示例代码，创建了一个 <code>Tab</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.Tab;
     *		import laya.utils.Handler;
     *		public class Tab_Example
     *		{
     *			public function Tab_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load(["resource/ui/tab.png"], Handler.create(this, onLoadComplete));//加载资源。
     *			}
     *			private function onLoadComplete():void
     *			{
     *				var tab:Tab = new Tab();//创建一个 Tab 类的实例对象 tab 。
     *				tab.skin = "resource/ui/tab.png";//设置 tab 的皮肤。
     *				tab.labels = "item0,item1,item2";//设置 tab 的标签集。
     *				tab.x = 100;//设置 tab 对象的属性 x 的值，用于控制 tab 对象的显示位置。
     *				tab.y = 100;//设置 tab 对象的属性 y 的值，用于控制 tab 对象的显示位置。
     *				tab.selectHandler = new Handler(this, onSelect);//设置 tab 的选择项发生改变时执行的处理器。
     *				Laya.stage.addChild(tab);//将 tab 添到显示列表。
     *			}
     *			private function onSelect(index:int):void
     *			{
     *				trace("当前选择的表情页索引: index= ", index);
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * Laya.loader.load(["resource/ui/tab.png"], laya.utils.Handler.create(this, onLoadComplete));
     * function onLoadComplete() {
     *     var tab = new laya.ui.Tab();//创建一个 Tab 类的实例对象 tab 。
     *     tab.skin = "resource/ui/tab.png";//设置 tab 的皮肤。
     *     tab.labels = "item0,item1,item2";//设置 tab 的标签集。
     *     tab.x = 100;//设置 tab 对象的属性 x 的值，用于控制 tab 对象的显示位置。
     *     tab.y = 100;//设置 tab 对象的属性 y 的值，用于控制 tab 对象的显示位置。
     *     tab.selectHandler = new laya.utils.Handler(this, onSelect);//设置 tab 的选择项发生改变时执行的处理器。
     *     Laya.stage.addChild(tab);//将 tab 添到显示列表。
     * }
     * function onSelect(index) {
     *     console.log("当前选择的标签页索引: index= ", index);
     * }
     * @example
     * import Tab = laya.ui.Tab;
     * import Handler = laya.utils.Handler;
     * class Tab_Example {
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load(["resource/ui/tab.png"], Handler.create(this, this.onLoadComplete));//加载资源。
     *     }
     *     private onLoadComplete(): void {
     *         var tab: Tab = new Tab();//创建一个 Tab 类的实例对象 tab 。
     *         tab.skin = "resource/ui/tab.png";//设置 tab 的皮肤。
     *         tab.labels = "item0,item1,item2";//设置 tab 的标签集。
     *         tab.x = 100;//设置 tab 对象的属性 x 的值，用于控制 tab 对象的显示位置。
     *         tab.y = 100;//设置 tab 对象的属性 y 的值，用于控制 tab 对象的显示位置。
     *         tab.selectHandler = new Handler(this, this.onSelect);//设置 tab 的选择项发生改变时执行的处理器。
     *         Laya.stage.addChild(tab);//将 tab 添到显示列表。
     *     }
     *     private onSelect(index: number): void {
     *         console.log("当前选择的表情页索引: index= ", index);
     *     }
     * }
     */
    class Tab extends UIGroup {
        constructor();
        /**
         * @private
         * @inheritDoc
         * @override
         */
        protected createItem(skin: string, label: string): Sprite;
    }
    /**
     * <code>TextArea</code> 类用于创建显示对象以显示和输入文本。
     * @example <caption>以下示例代码，创建了一个 <code>TextArea</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.TextArea;
     *		import laya.utils.Handler;
     *		public class TextArea_Example
     *		{
     *			public function TextArea_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load(["resource/ui/input.png"], Handler.create(this, onLoadComplete));//加载资源。
     *			}
     *			private function onLoadComplete():void
     *			{
     *				var textArea:TextArea = new TextArea("这个一个TextArea实例。");//创建一个 TextArea 类的实例对象 textArea 。
     *				textArea.skin = "resource/ui/input.png";//设置 textArea 的皮肤。
     *				textArea.sizeGrid = "4,4,4,4";//设置 textArea 的网格信息。
     *				textArea.color = "#008fff";//设置 textArea 的文本颜色。
     *				textArea.font = "Arial";//设置 textArea 的字体。
     *				textArea.bold = true;//设置 textArea 的文本显示为粗体。
     *				textArea.fontSize = 20;//设置 textArea 的文本字体大小。
     *				textArea.wordWrap = true;//设置 textArea 的文本自动换行。
     *				textArea.x = 100;//设置 textArea 对象的属性 x 的值，用于控制 textArea 对象的显示位置。
     *				textArea.y = 100;//设置 textArea 对象的属性 y 的值，用于控制 textArea 对象的显示位置。
     *				textArea.width = 300;//设置 textArea 的宽度。
     *				textArea.height = 200;//设置 textArea 的高度。
     *				Laya.stage.addChild(textArea);//将 textArea 添加到显示列表。
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高、渲染模式
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * Laya.loader.load(["resource/ui/input.png"], laya.utils.Handler.create(this, onLoadComplete));//加载资源。
     * function onLoadComplete() {
     *     var textArea = new laya.ui.TextArea("这个一个TextArea实例。");//创建一个 TextArea 类的实例对象 textArea 。
     *     textArea.skin = "resource/ui/input.png";//设置 textArea 的皮肤。
     *     textArea.sizeGrid = "4,4,4,4";//设置 textArea 的网格信息。
     *     textArea.color = "#008fff";//设置 textArea 的文本颜色。
     *     textArea.font = "Arial";//设置 textArea 的字体。
     *     textArea.bold = true;//设置 textArea 的文本显示为粗体。
     *     textArea.fontSize = 20;//设置 textArea 的文本字体大小。
     *     textArea.wordWrap = true;//设置 textArea 的文本自动换行。
     *     textArea.x = 100;//设置 textArea 对象的属性 x 的值，用于控制 textArea 对象的显示位置。
     *     textArea.y = 100;//设置 textArea 对象的属性 y 的值，用于控制 textArea 对象的显示位置。
     *     textArea.width = 300;//设置 textArea 的宽度。
     *     textArea.height = 200;//设置 textArea 的高度。
     *     Laya.stage.addChild(textArea);//将 textArea 添加到显示列表。
     * }
     * @example
     * import TextArea = laya.ui.TextArea;
     * import Handler = laya.utils.Handler;
     * class TextArea_Example {
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load(["resource/ui/input.png"], Handler.create(this, this.onLoadComplete));//加载资源。
     *     }
        
     *     private onLoadComplete(): void {
     *         var textArea: TextArea = new TextArea("这个一个TextArea实例。");//创建一个 TextArea 类的实例对象 textArea 。
     *         textArea.skin = "resource/ui/input.png";//设置 textArea 的皮肤。
     *         textArea.sizeGrid = "4,4,4,4";//设置 textArea 的网格信息。
     *         textArea.color = "#008fff";//设置 textArea 的文本颜色。
     *         textArea.font = "Arial";//设置 textArea 的字体。
     *         textArea.bold = true;//设置 textArea 的文本显示为粗体。
     *         textArea.fontSize = 20;//设置 textArea 的文本字体大小。
     *         textArea.wordWrap = true;//设置 textArea 的文本自动换行。
     *         textArea.x = 100;//设置 textArea 对象的属性 x 的值，用于控制 textArea 对象的显示位置。
     *         textArea.y = 100;//设置 textArea 对象的属性 y 的值，用于控制 textArea 对象的显示位置。
     *         textArea.width = 300;//设置 textArea 的宽度。
     *         textArea.height = 200;//设置 textArea 的高度。
     *         Laya.stage.addChild(textArea);//将 textArea 添加到显示列表。
     *     }
     * }
     */
    class TextArea extends TextInput {
        protected _scrollType: ScrollType;
        protected _vScrollBarSkin: string;
        protected _hScrollBarSkin: string;
        /**@private */
        protected _vScrollBar: VScrollBar;
        /**@private */
        protected _hScrollBar: HScrollBar;
        /**
         * <p>创建一个新的 <code>TextArea</code> 示例。</p>
         * @param text 文本内容字符串。
         */
        constructor(text?: string);
        protected _onPostLayout(): void;
        /**
         *
         * @param destroyChild
         * @override
         */
        destroy(destroyChild?: boolean): void;
        /**
         * @override
         */
        protected initialize(): void;
        /**
         * @override
         */
        _setWidth(value: number): void;
        /**
    
        /**
         * @override
         */
        _setHeight(value: number): void;
        get scrollType(): ScrollType;
        set scrollType(value: ScrollType);
        private createHScrollBar;
        private createVScrollBar;
        /**
         * 垂直方向滚动条皮肤。
         */
        get vScrollBarSkin(): string;
        set vScrollBarSkin(value: string);
        /**
         * 水平方向滚动条皮肤。
         */
        get hScrollBarSkin(): string;
        set hScrollBarSkin(value: string);
        protected onVBarChanged(e: Event): void;
        protected onHBarChanged(e: Event): void;
        /**垂直滚动条实体*/
        get vScrollBar(): VScrollBar;
        /**水平滚动条实体*/
        get hScrollBar(): HScrollBar;
        /**垂直滚动最大值*/
        get maxScrollY(): number;
        /**垂直滚动值*/
        get scrollY(): number;
        /**水平滚动最大值*/
        get maxScrollX(): number;
        /**水平滚动值*/
        get scrollX(): number;
        private changeScroll;
        /**滚动到某个位置*/
        scrollTo(y: number): void;
    }
    /**
     * 输入文本后调度。
     * @eventType Event.INPUT
     */
    /**
     * 在输入框内敲回车键后调度。
     * @eventType Event.ENTER
     */
    /**
     * 当获得输入焦点后调度。
     * @eventType Event.FOCUS
     */
    /**
     * 当失去输入焦点后调度。
     * @eventType Event.BLUR
     */
    /**
     * <code>TextInput</code> 类用于创建显示对象以显示和输入文本。
     *
     * @example <caption>以下示例代码，创建了一个 <code>TextInput</code> 实例。</caption>
     * package
     *	{
     *		import laya.display.Stage;
     *		import laya.ui.TextInput;
     *		import laya.utils.Handler;
     *		public class TextInput_Example
     *		{
     *			public function TextInput_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load(["resource/ui/input.png"], Handler.create(this, onLoadComplete));//加载资源。
     *			}
     *			private function onLoadComplete():void
     *			{
     *				var textInput:TextInput = new TextInput("这是一个TextInput实例。");//创建一个 TextInput 类的实例对象 textInput 。
     *				textInput.skin = "resource/ui/input.png";//设置 textInput 的皮肤。
     *				textInput.sizeGrid = "4,4,4,4";//设置 textInput 的网格信息。
     *				textInput.color = "#008fff";//设置 textInput 的文本颜色。
     *				textInput.font = "Arial";//设置 textInput 的文本字体。
     *				textInput.bold = true;//设置 textInput 的文本显示为粗体。
     *				textInput.fontSize = 30;//设置 textInput 的字体大小。
     *				textInput.wordWrap = true;//设置 textInput 的文本自动换行。
     *				textInput.x = 100;//设置 textInput 对象的属性 x 的值，用于控制 textInput 对象的显示位置。
     *				textInput.y = 100;//设置 textInput 对象的属性 y 的值，用于控制 textInput 对象的显示位置。
     *				textInput.width = 300;//设置 textInput 的宽度。
     *				textInput.height = 200;//设置 textInput 的高度。
     *				Laya.stage.addChild(textInput);//将 textInput 添加到显示列表。
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * Laya.loader.load(["resource/ui/input.png"], laya.utils.Handler.create(this, onLoadComplete));//加载资源。
     * function onLoadComplete() {
     *     var textInput = new laya.ui.TextInput("这是一个TextInput实例。");//创建一个 TextInput 类的实例对象 textInput 。
     *     textInput.skin = "resource/ui/input.png";//设置 textInput 的皮肤。
     *     textInput.sizeGrid = "4,4,4,4";//设置 textInput 的网格信息。
     *     textInput.color = "#008fff";//设置 textInput 的文本颜色。
     *     textInput.font = "Arial";//设置 textInput 的文本字体。
     *     textInput.bold = true;//设置 textInput 的文本显示为粗体。
     *     textInput.fontSize = 30;//设置 textInput 的字体大小。
     *     textInput.wordWrap = true;//设置 textInput 的文本自动换行。
     *     textInput.x = 100;//设置 textInput 对象的属性 x 的值，用于控制 textInput 对象的显示位置。
     *     textInput.y = 100;//设置 textInput 对象的属性 y 的值，用于控制 textInput 对象的显示位置。
     *     textInput.width = 300;//设置 textInput 的宽度。
     *     textInput.height = 200;//设置 textInput 的高度。
     *     Laya.stage.addChild(textInput);//将 textInput 添加到显示列表。
     * }
     * @example
     * import Stage = laya.display.Stage;
     * import TextInput = laya.ui.TextInput;
     * import Handler = laya.utils.Handler;
     * class TextInput_Example {
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load(["resource/ui/input.png"], Handler.create(this, this.onLoadComplete));//加载资源。
     *     }
     *     private onLoadComplete(): void {
     *         var textInput: TextInput = new TextInput("这是一个TextInput实例。");//创建一个 TextInput 类的实例对象 textInput 。
     *         textInput.skin = "resource/ui/input.png";//设置 textInput 的皮肤。
     *         textInput.sizeGrid = "4,4,4,4";//设置 textInput 的网格信息。
     *         textInput.color = "#008fff";//设置 textInput 的文本颜色。
     *         textInput.font = "Arial";//设置 textInput 的文本字体。
     *         textInput.bold = true;//设置 textInput 的文本显示为粗体。
     *         textInput.fontSize = 30;//设置 textInput 的字体大小。
     *         textInput.wordWrap = true;//设置 textInput 的文本自动换行。
     *         textInput.x = 100;//设置 textInput 对象的属性 x 的值，用于控制 textInput 对象的显示位置。
     *         textInput.y = 100;//设置 textInput 对象的属性 y 的值，用于控制 textInput 对象的显示位置。
     *         textInput.width = 300;//设置 textInput 的宽度。
     *         textInput.height = 200;//设置 textInput 的高度。
     *         Laya.stage.addChild(textInput);//将 textInput 添加到显示列表。
     *     }
     * }
     */
    class TextInput extends Label {
        /** @private */
        protected _skin: string;
        _graphics: AutoBitmap;
        _tf: Input;
        /**
         * 创建一个新的 <code>TextInput</code> 类实例。
         * @param text 文本内容。
         */
        constructor(text?: string);
        /**
         * @inheritDoc
         * @override
        */
        protected preinitialize(): void;
        /**
         * @inheritDoc
         * @override
        */
        protected createChildren(): void;
        /**
         * @inheritDoc
         * @override
        */
        protected initialize(): void;
        /**
         * @copy laya.ui.Image#skin
         */
        get skin(): string;
        set skin(value: string);
        _setSkin(url: string): Promise<void>;
        protected _skinLoaded(source: any): void;
        /**
         * <p>当前实例的背景图（ <code>AutoBitmap</code> ）实例的有效缩放网格数据。</p>
         * <p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
         * <ul><li>例如："4,4,4,4,1"</li></ul></p>
         */
        get sizeGrid(): string;
        set sizeGrid(value: string);
        /**
         * @inheritDoc
         * @override
         */
        _setWidth(value: number): void;
        /**
         * @inheritDoc
         * @override
         */
        _setHeight(value: number): void;
        /**
         * <p>指示当前是否是文本域。</p>
         * 值为true表示当前是文本域，否则不是文本域。
         */
        get multiline(): boolean;
        set multiline(value: boolean);
        /**
         * 设置可编辑状态。
         */
        set editable(value: boolean);
        get editable(): boolean;
        /**选中输入框内的文本。*/
        select(): void;
        /**限制输入的字符。*/
        get restrict(): string;
        set restrict(pattern: string);
        /**
         * @copy laya.display.Input#prompt
         */
        get prompt(): string;
        set prompt(value: string);
        /**
         * @copy laya.display.Input#promptColor
         */
        get promptColor(): string;
        set promptColor(value: string);
        /**
         * @copy laya.display.Input#maxChars
         */
        get maxChars(): number;
        set maxChars(value: number);
        /**
         * @copy laya.display.Input#focus
         */
        get focus(): boolean;
        set focus(value: boolean);
        /**
         * @copy laya.display.Input#type
         */
        get type(): string;
        set type(value: string);
        setSelection(startIndex: number, endIndex: number): void;
    }
    /**鼠标提示管理类*/
    class TipManager extends UIComponent {
        static offsetX: number;
        static offsetY: number;
        static tipTextColor: string;
        static tipBackColor: string;
        static tipDelay: number;
        private _tipBox;
        private _tipText;
        private _defaultTipHandler;
        constructor();
        /**
         * @private
         */
        private _onStageHideTip;
        /**
         * @private
         */
        private _onStageShowTip;
        /**
         * @private
         */
        private _showTip;
        /**
         * @private
         */
        private _onStageMouseDown;
        /**
         * @private
         */
        private _onStageMouseMove;
        /**
         * @private
         */
        private _showToStage;
        /**关闭所有鼠标提示*/
        closeAll(): void;
        /**
         * 显示显示对象类型的tip
         */
        showDislayTip(tip: Sprite): void;
        /**
         * @private
         */
        private _showDefaultTip;
        /**默认鼠标提示函数*/
        get defaultTipHandler(): Function;
        set defaultTipHandler(value: Function);
    }
    /**
     * 实例的 <code>selectedIndex</code> 属性发生变化时调度。
     * @eventType laya.events.Event
     */
    /**
     * 节点打开关闭时触发。
     * @eventType laya.events.Event
     */
    /**
     * <code>Tree</code> 控件使用户可以查看排列为可扩展树的层次结构数据。
     *
     * @example
     * package
     *	{
     *		import laya.ui.Tree;
     *		import laya.utils.Browser;
     *		import laya.utils.Handler;
        
     *		public class Tree_Example
     *		{
        
     *			public function Tree_Example()
     *			{
     *				Laya.init(640, 800);
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load(["resource/ui/vscroll.png", "resource/ui/vscroll$bar.png", "resource/ui/vscroll$down.png", "resource/ui/vscroll$up.png", "resource/ui/clip_selectBox.png", "resource/ui/clip_tree_folder.png", "resource/ui/clip_tree_arrow.png"], Handler.create(this, onLoadComplete));
     *			}
        
     *			private function onLoadComplete():void
     *			{
     *				var xmlString:String;//创建一个xml字符串，用于存储树结构数据。
     *				xmlString = "&lt;root&gt;&lt;item label='box1'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;abc label='child5'/&gt;&lt;/item&gt;&lt;item label='box2'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;/item&gt;&lt;/root&gt;";
     *				var domParser:* = new Browser.window.DOMParser();//创建一个DOMParser实例domParser。
     *				var xml:* = domParser.parseFromString(xmlString, "text/xml");//解析xml字符。
        
     *				var tree:Tree = new Tree();//创建一个 Tree 类的实例对象 tree 。
     *				tree.scrollBarSkin = "resource/ui/vscroll.png";//设置 tree 的皮肤。
     *				tree.itemRender = Item;//设置 tree 的项渲染器。
     *				tree.xml = xml;//设置 tree 的树结构数据。
     *				tree.x = 100;//设置 tree 对象的属性 x 的值，用于控制 tree 对象的显示位置。
     *				tree.y = 100;//设置 tree 对象的属性 y 的值，用于控制 tree 对象的显示位置。
     *				tree.width = 200;//设置 tree 的宽度。
     *				tree.height = 100;//设置 tree 的高度。
     *				Laya.stage.addChild(tree);//将 tree 添加到显示列表。
     *			}
     *		}
     *	}
        
     * import laya.ui.Box;
     * import laya.ui.Clip;
     * import laya.ui.Label;
     *	class Item extends Box
     *	{
     *		public function Item()
     *		{
     *			this.name = "render";
     *			this.right = 0;
     *			this.left = 0;
        
     *			var selectBox:Clip = new Clip("resource/ui/clip_selectBox.png", 1, 2);
     *			selectBox.name = "selectBox";
     *			selectBox.height = 24;
     *			selectBox.x = 13;
     *			selectBox.y = 0;
     *			selectBox.left = 12;
     *			addChild(selectBox);
        
     *			var folder:Clip = new Clip("resource/ui/clip_tree_folder.png", 1, 3);
     *			folder.name = "folder";
     *			folder.x = 14;
     *			folder.y = 4;
     *			addChild(folder);
        
     *			var label:Label = new Label("treeItem");
     *			label.name = "label";
     *			label.color = "#ffff00";
     *			label.width = 150;
     *			label.height = 22;
     *			label.x = 33;
     *			label.y = 1;
     *			label.left = 33;
     *			label.right = 0;
     *			addChild(label);
        
     *			var arrow:Clip = new Clip("resource/ui/clip_tree_arrow.png", 1, 2);
     *			arrow.name = "arrow";
     *			arrow.x = 0;
     *			arrow.y = 5;
     *			addChild(arrow);
     *		}
     *	 }
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高、渲染模式
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * var res = ["resource/ui/vscroll.png", "resource/ui/vscroll$bar.png", "resource/ui/vscroll$down.png", "resource/ui/vscroll$up.png", "resource/ui/clip_selectBox.png", "resource/ui/clip_tree_folder.png", "resource/ui/clip_tree_arrow.png"];
     * Laya.loader.load(res, new laya.utils.Handler(this, onLoadComplete));
     * function onLoadComplete() {
     *     var xmlString;//创建一个xml字符串，用于存储树结构数据。
     *     xmlString = "&lt;root&gt;&lt;item label='box1'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;abc label='child5'/&gt;&lt;/item&gt;&lt;item label='box2'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;/item&gt;&lt;/root&gt;";
     *     var domParser = new laya.utils.Browser.window.DOMParser();//创建一个DOMParser实例domParser。
     *     var xml = domParser.parseFromString(xmlString, "text/xml");//解析xml字符。
        
     *     var tree = new laya.ui.Tree();//创建一个 Tree 类的实例对象 tree 。
     *     tree.scrollBarSkin = "resource/ui/vscroll.png";//设置 tree 的皮肤。
     *     tree.itemRender = mypackage.treeExample.Item;//设置 tree 的项渲染器。
     *     tree.xml = xml;//设置 tree 的树结构数据。
     *     tree.x = 100;//设置 tree 对象的属性 x 的值，用于控制 tree 对象的显示位置。
     *     tree.y = 100;//设置 tree 对象的属性 y 的值，用于控制 tree 对象的显示位置。
     *     tree.width = 200;//设置 tree 的宽度。
     *     tree.height = 100;//设置 tree 的高度。
     *     Laya.stage.addChild(tree);//将 tree 添加到显示列表。
     * }
     * (function (_super) {
     *     function Item() {
     *         Item.__super.call(this);//初始化父类。
     *         this.right = 0;
     *         this.left = 0;
        
     *         var selectBox = new laya.ui.Clip("resource/ui/clip_selectBox.png", 1, 2);
     *         selectBox.name = "selectBox";//设置 selectBox 的name 为“selectBox”时，将被识别为树结构的项的背景。2帧：悬停时背景、选中时背景。
     *         selectBox.height = 24;
     *         selectBox.x = 13;
     *         selectBox.y = 0;
     *         selectBox.left = 12;
     *         this.addChild(selectBox);//需要使用this.访问父类的属性或方法。
        
     *         var folder = new laya.ui.Clip("resource/ui/clip_tree_folder.png", 1, 3);
     *         folder.name = "folder";//设置 folder 的name 为“folder”时，将被识别为树结构的文件夹开启状态图表。2帧：折叠状态、打开状态。
     *         folder.x = 14;
     *         folder.y = 4;
     *         this.addChild(folder);
        
     *         var label = new laya.ui.Label("treeItem");
     *         label.name = "label";//设置 label 的name 为“label”时，此值将用于树结构数据赋值。
     *         label.color = "#ffff00";
     *         label.width = 150;
     *         label.height = 22;
     *         label.x = 33;
     *         label.y = 1;
     *         label.left = 33;
     *         label.right = 0;
     *         this.addChild(label);
        
     *         var arrow = new laya.ui.Clip("resource/ui/clip_tree_arrow.png", 1, 2);
     *         arrow.name = "arrow";//设置 arrow 的name 为“arrow”时，将被识别为树结构的文件夹开启状态图表。2帧：折叠状态、打开状态。
     *         arrow.x = 0;
     *         arrow.y = 5;
     *         this.addChild(arrow);
     *     };
     *     Laya.class(Item,"mypackage.treeExample.Item",_super);//注册类 Item 。
     * })(laya.ui.Box);
     * @example
     * import Tree = laya.ui.Tree;
     * import Browser = laya.utils.Browser;
     * import Handler = laya.utils.Handler;
     * class Tree_Example {
        
     *     constructor() {
     *         Laya.init(640, 800);
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load(["resource/ui/vscroll.png", "resource/ui/vscroll$bar.png", "resource/ui/vscroll$down.png", "resource/ui/vscroll$up.png", "resource/ui/vscroll$up.png", "resource/ui/clip_selectBox.png", "resource/ui/clip_tree_folder * . * png", "resource/ui/clip_tree_arrow.png"], Handler.create(this, this.onLoadComplete));
     *     }
     *     private onLoadComplete(): void {
     *         var xmlString: String;//创建一个xml字符串，用于存储树结构数据。
     *         xmlString = "&lt;root&gt;&lt;item label='box1'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;abc label='child5'/&gt;&lt;/item&gt;&lt;item label='box2'&gt;&lt;abc  * label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;/item&gt;&lt;/root&gt;";
     *         var domParser: any = new Browser.window.DOMParser();//创建一个DOMParser实例domParser。
     *         var xml: any = domParser.parseFromString(xmlString, "text/xml");//解析xml字符。
        
     *         var tree: Tree = new Tree();//创建一个 Tree 类的实例对象 tree 。
     *         tree.scrollBarSkin = "resource/ui/vscroll.png";//设置 tree 的皮肤。
     *         tree.itemRender = Item;//设置 tree 的项渲染器。
     *         tree.xml = xml;//设置 tree 的树结构数据。
     *         tree.x = 100;//设置 tree 对象的属性 x 的值，用于控制 tree 对象的显示位置。
     *         tree.y = 100;//设置 tree 对象的属性 y 的值，用于控制 tree 对象的显示位置。
     *         tree.width = 200;//设置 tree 的宽度。
     *         tree.height = 100;//设置 tree 的高度。
     *         Laya.stage.addChild(tree);//将 tree 添加到显示列表。
     *     }
     * }
     * import Box = laya.ui.Box;
     * import Clip = laya.ui.Clip;
     * import Label = laya.ui.Label;
     * class Item extends Box {
     *     constructor() {
     *         super();
     *         this.name = "render";
     *         this.right = 0;
     *         this.left = 0;
     *         var selectBox: Clip = new Clip("resource/ui/clip_selectBox.png", 1, 2);
     *         selectBox.name = "selectBox";
     *         selectBox.height = 24;
     *         selectBox.x = 13;
     *         selectBox.y = 0;
     *         selectBox.left = 12;
     *         this.addChild(selectBox);
        
     *         var folder: Clip = new Clip("resource/ui/clip_tree_folder.png", 1, 3);
     *         folder.name = "folder";
     *         folder.x = 14;
     *         folder.y = 4;
     *         this.addChild(folder);
        
     *         var label: Label = new Label("treeItem");
     *         label.name = "label";
     *         label.color = "#ffff00";
     *         label.width = 150;
     *         label.height = 22;
     *         label.x = 33;
     *         label.y = 1;
     *         label.left = 33;
     *         label.right = 0;
     *         this.addChild(label);
        
     *         var arrow: Clip = new Clip("resource/ui/clip_tree_arrow.png", 1, 2);
     *         arrow.name = "arrow";
     *         arrow.x = 0;
     *         arrow.y = 5;
     *         this.addChild(arrow);
     *     }
     * }
     */
    class Tree extends Box {
        /**@private */
        protected _list: List;
        /**@private */
        protected _source: any[];
        /**@private */
        protected _renderHandler: Handler;
        /**@private */
        protected _spaceLeft: number;
        /**@private */
        protected _spaceBottom: number;
        /**@private */
        protected _keepStatus: boolean;
        /**
         * 创建一个新的 <code>Tree</code> 类实例。
         * <p>在 <code>Tree</code> 构造函数中设置属性width、height的值都为200。</p>
         */
        constructor();
        /**
         * @inheritDoc
         * @override
        */
        destroy(destroyChild?: boolean): void;
        /**
         * @override
         */
        protected createChildren(): void;
        /**
         * @private
         * 此对象包含的<code>List</code>实例的<code>Event.CHANGE</code>事件侦听处理函数。
         */
        protected onListChange(e?: Event): void;
        /**
         * 数据源发生变化后，是否保持之前打开状态，默认为true。
         * <p><b>取值：</b>
         * <li>true：保持之前打开状态。</li>
         * <li>false：不保持之前打开状态。</li>
         * </p>
         */
        get keepStatus(): boolean;
        set keepStatus(value: boolean);
        /**
         * 列表数据源，只包含当前可视节点数据。
         */
        get array(): any[];
        set array(value: any[]);
        /**
         * 数据源，全部节点数据。
         */
        get source(): any[];
        /**
         * 此对象包含的<code>List</code>实例对象。
         */
        get list(): List;
        /**
         * 此对象包含的<code>List</code>实例的单元格渲染器。
         * <p><b>取值：</b>
         * <ol>
         * <li>单元格类对象。</li>
         * <li> UI 的 JSON 描述。</li>
         * </ol></p>
         * @implements
         */
        get itemRender(): any;
        set itemRender(value: any);
        /**
         * 滚动条皮肤。
         */
        get scrollBarSkin(): string;
        set scrollBarSkin(value: string);
        /**滚动条*/
        get scrollBar(): ScrollBar;
        /**
         * 单元格鼠标事件处理器。
         * <p>默认返回参数（e:Event,index:int）。</p>
         */
        get mouseHandler(): Handler;
        set mouseHandler(value: Handler);
        /**
         * <code>Tree</code> 实例的渲染处理器。
         */
        get renderHandler(): Handler;
        set renderHandler(value: Handler);
        /**
         * 左侧缩进距离（以像素为单位）。
         */
        get spaceLeft(): number;
        set spaceLeft(value: number);
        /**
         * 每一项之间的间隔距离（以像素为单位）。
         */
        get spaceBottom(): number;
        set spaceBottom(value: number);
        /**
         * 表示当前选择的项索引。
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * 当前选中的项对象的数据源。
         */
        get selectedItem(): any;
        set selectedItem(value: any);
        /**
         * @private
         * 获取数据源集合。
         */
        protected getArray(): any[];
        /**
         * @private
         * 获取项对象的深度。
         */
        protected getDepth(item: any, num?: number): number;
        /**
         * @private
         * 获取项对象的上一级的打开状态。
         */
        protected getParentOpenStatus(item: any): boolean;
        /**
         * @private
         * 渲染一个项对象。
         * @param cell 一个项对象。
         * @param index 项的索引。
         */
        protected renderItem(cell: Box, index: number): void;
        /**
         * @private
         */
        private onArrowClick;
        /**
         * 设置指定项索引的项对象的打开状态。
         * @param index 项索引。
         * @param isOpen 是否处于打开状态。
         */
        setItemState(index: number, isOpen: boolean): void;
        /**
         * 刷新项列表。
         */
        fresh(): void;
        /**
         * @inheritDoc
         * @override
         */
        set_dataSource(value: any): void;
        /**
         *  xml结构的数据源。
         */
        set xml(value: XML);
        /**
         * @private
         * 解析并处理XML类型的数据源。
         */
        protected parseXml(xml: XML, source: any[], nodeParent: any, isRoot: boolean): void;
        /**
         * @private
         * 处理数据项的打开状态。
         */
        protected parseOpenStatus(oldSource: any[], newSource: any[]): void;
        /**
         * @private
         * 判断两个项对象在树结构中的父节点是否相同。
         * @param item1 项对象。
         * @param item2 项对象。
         * @return 如果父节点相同值为true，否则值为false。
         */
        protected isSameParent(item1: any, item2: any): boolean;
        /**
         * 表示选择的树节点项的<code>path</code>属性值。
         */
        get selectedPath(): string;
        /**
         * 更新项列表，显示指定键名的数据项。
         * @param	key 键名。
         */
        filter(key: string): void;
        /**
         * @private
         * 获取数据源中指定键名的值。
         */
        private getFilterSource;
    }
    /**
     * <code>Component</code> 是ui控件类的基类。
     * <p>生命周期：preinitialize > createChildren > initialize > 组件构造函数</p>
     */
    class UIComponent extends Sprite {
        /**@private 控件的数据源。 */
        protected _dataSource: any;
        /**@private 鼠标悬停提示 */
        protected _toolTip: any;
        /**@private 禁用 */
        protected _disabled: boolean;
        /**@private 变灰*/
        protected _gray: boolean;
        /**@private 相对布局组件*/
        protected _widget: Widget;
        /**
         * <p>创建一个新的 <code>Component</code> 实例。</p>
         */
        constructor(createChildren?: boolean);
        /**
         * @inheritDoc
         * @override
         */
        destroy(destroyChild?: boolean): void;
        /**
         * <p>预初始化。</p>
         * 子类可在此函数内设置、修改属性默认值
         */
        protected preinitialize(): void;
        /**
         * <p>创建并添加控件子节点。</p>
         * 子类可在此函数内创建并添加子节点。
         */
        protected createChildren(): void;
        /**
         * <p>控件初始化。</p>
         * 在此子对象已被创建，可以对子对象进行修改。
         */
        protected initialize(): void;
        /**
         * @override
         */
        get_width(): number;
        /**
         * <p>显示对象的实际显示区域宽度（以像素为单位）。</p>
         */
        protected measureWidth(): number;
        /**
         * <p>立即执行影响宽高度量的延迟调用函数。</p>
         * <p>使用 <code>runCallLater</code> 函数，立即执行影响宽高度量的延迟运行函数(使用 <code>callLater</code> 设置延迟执行函数)。</p>
         * @see #callLater()
         * @see #runCallLater()
         */
        protected commitMeasure(): void;
        /**
         * @override
         */
        get_height(): number;
        /**
         * <p>显示对象的实际显示区域高度（以像素为单位）。</p>
         */
        protected measureHeight(): number;
        /**
         * @implements
         * <p>数据赋值，通过对UI赋值来控制UI显示逻辑。</p>
         * <p>简单赋值会更改组件的默认属性，使用大括号可以指定组件的任意属性进行赋值。</p>
         * @example
           //默认属性赋值
           dataSource = {label1: "改变了label", checkbox1: true};//(更改了label1的text属性值，更改checkbox1的selected属性)。
           //任意属性赋值
           dataSource = {label2: {text:"改变了label",size:14}, checkbox2: {selected:true,x:10}};
         */
        get dataSource(): any;
        get_dataSource(): any;
        set dataSource(value: any);
        set_dataSource(value: any): void;
        /**
         * <p>从组件顶边到其内容区域顶边之间的垂直距离（以像素为单位）。</p>
         */
        get top(): number;
        get_top(): number;
        set top(value: number);
        set_top(value: number): void;
        /**
         * <p>从组件底边到其内容区域底边之间的垂直距离（以像素为单位）。</p>
         */
        get bottom(): number;
        get_bottom(): number;
        set bottom(value: number);
        set_bottom(value: number): void;
        /**
         * <p>从组件左边到其内容区域左边之间的水平距离（以像素为单位）。</p>
         */
        get left(): number;
        set left(value: number);
        /**
         * <p>从组件右边到其内容区域右边之间的水平距离（以像素为单位）。</p>
         */
        get right(): number;
        set right(value: number);
        /**
         * <p>在父容器中，此对象的水平方向中轴线与父容器的水平方向中心线的距离（以像素为单位）。</p>
         */
        get centerX(): number;
        set centerX(value: number);
        /**
         * <p>在父容器中，此对象的垂直方向中轴线与父容器的垂直方向中心线的距离（以像素为单位）。</p>
         */
        get centerY(): number;
        set centerY(value: number);
        protected _shouldRefreshLayout(): void;
        protected _sizeChanged(): void;
        /**
         * <p>鼠标悬停提示。</p>
         * <p>可以赋值为文本 <code>String</code> 或函数 <code>Handler</code> ，用来实现自定义样式的鼠标提示和参数携带等。</p>
         * @example
         * private var _testTips:TestTipsUI = new TestTipsUI();
         * private function testTips():void {
           //简单鼠标提示
         * btn2.toolTip = "这里是鼠标提示&lt;b&gt;粗体&lt;/b&gt;&lt;br&gt;换行";
           //自定义的鼠标提示
         * btn1.toolTip = showTips1;
           //带参数的自定义鼠标提示
         * clip.toolTip = new Handler(this,showTips2, ["clip"]);
         * }
         * private function showTips1():void {
         * _testTips.label.text = "这里是按钮[" + btn1.label + "]";
         * tip.addChild(_testTips);
         * }
         * private function showTips2(name:String):void {
         * _testTips.label.text = "这里是" + name;
         * tip.addChild(_testTips);
         * }
         */
        get toolTip(): any;
        set toolTip(value: any);
        /**
         * 对象的 <code>Event.MOUSE_OVER</code> 事件侦听处理函数。
         */
        private onMouseOver;
        /**
         * 对象的 <code>Event.MOUSE_OUT</code> 事件侦听处理函数。
         */
        private onMouseOut;
        /** 是否变灰。*/
        get gray(): boolean;
        set gray(value: boolean);
        /** 是否禁用页面，设置为true后，会变灰并且禁用鼠标。*/
        get disabled(): boolean;
        set disabled(value: boolean);
        /**
         * @private
         * <p>获取对象的布局样式。请不要直接修改此对象</p>
         */
        private _getWidget;
        /**@private */
        protected onCompResize(): void;
        /**
         *
         * @param child
         * @override
         */
        protected _childChanged(child?: Node): void;
        /**
         * 重新排版
         */
        freshLayout(): void;
    }
    /**
     * <code>UIEvent</code> 类用来定义UI组件类的事件类型。
     */
    class UIEvent {
        /**
         * 显示提示信息。
         */
        static SHOW_TIP: string;
        /**
         * 隐藏提示信息。
         */
        static HIDE_TIP: string;
    }
    /**
     * 当 <code>Group</code> 实例的 <code>selectedIndex</code> 属性发生变化时调度。
     * @eventType laya.events.Event
     */
    /**
     * <code>Group</code> 是一个可以自动布局的项集合控件。
     * <p> <code>Group</code> 的默认项对象为 <code>Button</code> 类实例。
     * <code>Group</code> 是 <code>Tab</code> 和 <code>RadioGroup</code> 的基类。</p>
     */
    class UIGroup extends Box {
        /**
         * 改变 <code>Group</code> 的选择项时执行的处理器，(默认返回参数： 项索引（index:int）)。
         */
        selectHandler: Handler;
        /**@private */
        protected _items: ISelect[];
        /**@private */
        protected _selectedIndex: number;
        /**@private */
        protected _skin: string;
        /**@private */
        protected _direction: string;
        /**@private */
        protected _space: number;
        /**@private */
        protected _labels: string;
        /**@private */
        protected _labelColors: string;
        /**@private */
        private _labelFont;
        /**@private */
        protected _labelStrokeColor: string;
        /**@private */
        protected _strokeColors: string;
        /**@private */
        protected _labelStroke: number;
        /**@private */
        protected _labelSize: number;
        /**@private */
        protected _labelBold: boolean;
        /**@private */
        protected _labelPadding: string;
        /**@private */
        protected _labelAlign: string;
        /**@private */
        protected _stateNum: number;
        /**@private */
        protected _labelChanged: boolean;
        /**
         * 创建一个新的 <code>Group</code> 类实例。
         * @param labels 标签集字符串。以逗号做分割，如"item0,item1,item2,item3,item4,item5"。
         * @param skin 皮肤。
         */
        constructor(labels?: string, skin?: string);
        /**
         * @override
         */
        protected preinitialize(): void;
        /**
         * @inheritDoc
         * @override
        */
        destroy(destroyChild?: boolean): void;
        /**
         * 添加一个项对象，返回此项对象的索引id。
         *
         * @param item 需要添加的项对象。
         * @param autoLayout 是否自动布局，如果为true，会根据 <code>direction</code> 和 <code>space</code> 属性计算item的位置。
         * @return
         */
        addItem(item: ISelect, autoLayout?: boolean): number;
        /**
         * 删除一个项对象。
         * @param item 需要删除的项对象。
         * @param autoLayout 是否自动布局，如果为true，会根据 <code>direction</code> 和 <code>space</code> 属性计算item的位置。
         */
        delItem(item: ISelect, autoLayout?: boolean): void;
        onAfterDeserialize(): void;
        /**
         * 初始化项对象们。
         */
        initItems(): void;
        /**
         * @private
         * 项对象的点击事件侦听处理函数。
         * @param index 项索引。
         */
        protected itemClick(index: number): void;
        /**
         * 表示当前选择的项索引。默认值为-1。
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @private
         * 通过对象的索引设置项对象的 <code>selected</code> 属性值。
         * @param index 需要设置的项对象的索引。
         * @param selected 表示项对象的选中状态。
         */
        protected setSelect(index: number, selected: boolean): void;
        /**
         * @copy laya.ui.Image#skin
         */
        get skin(): string;
        set skin(value: string);
        _setSkin(url: string): Promise<void>;
        protected _skinLoaded(): void;
        /**
         * 标签集合字符串。以逗号做分割，如"item0,item1,item2,item3,item4,item5"。
         */
        get labels(): string;
        set labels(value: string);
        /**
         * @private
         * 创建一个项显示对象。
         * @param skin 项对象的皮肤。
         * @param label 项对象标签。
         */
        protected createItem(skin: string, label: string): Sprite;
        /**
         * @copy laya.ui.Button#labelColors()
         */
        get labelColors(): string;
        set labelColors(value: string);
        /**
         * <p>描边宽度（以像素为单位）。</p>
         * 默认值0，表示不描边。
         * @see laya.display.Text.stroke()
         */
        get labelStroke(): number;
        set labelStroke(value: number);
        /**
         * <p>描边颜色，以字符串表示。</p>
         * 默认值为 "#000000"（黑色）;
         * @see laya.display.Text.strokeColor()
         */
        get labelStrokeColor(): string;
        set labelStrokeColor(value: string);
        /**
         * <p>表示各个状态下的描边颜色。</p>
         * @see laya.display.Text.strokeColor()
         */
        get strokeColors(): string;
        set strokeColors(value: string);
        /**
         * 表示按钮文本标签的字体大小。
         */
        get labelSize(): number;
        set labelSize(value: number);
        /**
         * 表示按钮的状态值，以数字表示，默认为3态。
         * @see laya.ui.Button#stateNum
         */
        get stateNum(): number;
        set stateNum(value: number);
        /**
         * 表示按钮文本标签是否为粗体字。
         */
        get labelBold(): boolean;
        set labelBold(value: boolean);
        /**
         * 表示按钮文本标签的字体名称，以字符串形式表示。
         * @see laya.display.Text.font()
         */
        get labelFont(): string;
        set labelFont(value: string);
        /**
         * 表示按钮文本标签的边距。
         * <p><b>格式：</b>"上边距,右边距,下边距,左边距"。</p>
         */
        get labelPadding(): string;
        set labelPadding(value: string);
        /**
         * 布局方向。
         * <p>默认值为"horizontal"。</p>
         * <p><b>取值：</b>
         * <li>"horizontal"：表示水平布局。</li>
         * <li>"vertical"：表示垂直布局。</li>
         * </p>
         */
        get direction(): string;
        set direction(value: string);
        /**
         * 项对象们之间的间隔（以像素为单位）。
         */
        get space(): number;
        set space(value: number);
        /**
         * @private
         * 更改项对象的属性值。
         */
        protected changeLabels(): void;
        /**
         * @inheritDoc
         * @override
        */
        protected commitMeasure(): void;
        /**
         * 项对象们的存放数组。
         */
        get items(): ISelect[];
        /**
         * 获取或设置当前选择的项对象。
         */
        get selection(): ISelect;
        set selection(value: ISelect);
        /**
         * @inheritDoc
         * @override
         */
        set_dataSource(value: any): void;
        /**@private */
        protected _setLabelChanged(): void;
    }
    /**
     * <code>UIUtils</code> 是文本工具集。
     */
    class UIUtils {
        private static grayFilter;
        /**
         * 用字符串填充数组，并返回数组副本。
         * @param	arr 源数组对象。
         * @param	str 用逗号连接的字符串。如"p1,p2,p3,p4"。
         * @param	type 如果值不为null，则填充的是新增值得类型。
         * @return 填充后的数组。
         */
        static fillArray(arr: any[], str: string, type?: typeof Number | typeof String): any[];
        /**
         * 转换uint类型颜色值为字符型颜色值。
         * @param color uint颜色值。
         * @return 字符型颜色值。
         */
        static toColor(color: number): string;
        /**
         * 给指定的目标显示对象添加或移除灰度滤镜。
         * @param	target 目标显示对象。
         * @param	isGray 如果值true，则添加灰度滤镜，否则移除灰度滤镜。
         */
        static gray(target: Sprite, isGray?: boolean): void;
        /**@private */
        private static _funMap;
        /**
         * @private 根据字符串，返回函数表达式
         */
        static getBindFun(value: string): Function;
    }
    /**
         * <code>VBox</code> 是一个垂直布局容器类。
         */
    class VBox extends LayoutBox {
        /**
         * 无对齐。
         */
        static NONE: string;
        /**
         * 左对齐。
         */
        static LEFT: string;
        /**
         * 居中对齐。
         */
        static CENTER: string;
        /**
         * 右对齐。
         */
        static RIGHT: string;
        /** 兼容以前的changeItems逻辑，是否在发生变动时，使用 sortItem 排序所有item */
        isSortItem: boolean;
        /**
         * @override
         */
        _setWidth(value: number): void;
        /**
         * @inheritDoc
         * @override
        */
        protected changeItems(): void;
    }
    /**
     * <code>View</code> 是一个视图类
     * 在2.0里，View继承自Scene类，但这是不合理的，Scene是一个2D+3D的大概念。所以在3.0里请忽略这个继承。
     */
    class View extends Scene {
        /**@private 兼容老版本*/
        static uiMap: any;
        /**@private 控件的数据源。 */
        protected _dataSource: any;
        constructor();
        /**
         * @private 兼容老版本
         * 注册UI配置信息，比如注册一个路径为"test/TestPage"的页面，UI内容是IDE生成的json
         * @param	url		UI的路径
         * @param	json	UI内容
         */
        static regUI(url: string, json: any): void;
        /**@private */
        changeData(key: string): void;
        set_dataSource(value: any): void;
    }
    /**
     * <code>ViewStack</code> 类用于视图堆栈类，用于视图的显示等设置处理。
     */
    class ViewStack extends Box {
        /**@private */
        protected _items: any[];
        /**@private */
        protected _setIndexHandler: Handler;
        /**@private */
        protected _selectedIndex: number;
        constructor();
        /**
         * 批量设置视图对象。
         * @param views 视图对象数组。
         */
        setItems(views: any[]): void;
        /**
         * 添加视图。
         * 添加视图对象，并设置此视图对象的<code>name</code> 属性。
         * @param view 需要添加的视图对象。
         */
        addItem(view: Node): void;
        onAfterDeserialize(): void;
        /**
         * 初始化视图对象集合。
         */
        initItems(): void;
        /**
         * 表示当前视图索引。
         */
        get selectedIndex(): number;
        set selectedIndex(value: number);
        /**
         * @private
         * 通过对象的索引设置项对象的 <code>selected</code> 属性值。
         * @param index 需要设置的对象的索引。
         * @param selected 表示对象的选中状态。
         */
        protected setSelect(index: number, selected: boolean): void;
        /**
         * 获取或设置当前选择的项对象。
         */
        get selection(): Node;
        set selection(value: Node);
        /**
         *  索引设置处理器。
         * <p>默认回调参数：index:int</p>
         */
        get setIndexHandler(): Handler;
        set setIndexHandler(value: Handler);
        /**
         * @private
         * 设置属性<code>selectedIndex</code>的值。
         * @param index 选中项索引值。
         */
        protected setIndex(index: number): void;
        /**
         * 视图集合数组。
         */
        get items(): any[];
        /**
         * @inheritDoc
         * @override
        */
        set_dataSource(value: any): void;
    }
    /**
     *
     * 使用 <code>VScrollBar</code> （垂直 <code>ScrollBar</code> ）控件，可以在因数据太多而不能在显示区域完全显示时控制显示的数据部分。
     *
     * @example <caption>以下示例代码，创建了一个 <code>VScrollBar</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.vScrollBar;
     *		import laya.ui.VScrollBar;
     *		import laya.utils.Handler;
     *		public class VScrollBar_Example
     *		{
     *			private var vScrollBar:VScrollBar;
     *			public function VScrollBar_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load(["resource/ui/vscroll.png", "resource/ui/vscroll$bar.png", "resource/ui/vscroll$down.png", "resource/ui/vscroll$up.png"], Handler.create(this, onLoadComplete));
     *			}
     *			private function onLoadComplete():void
     *			{
     *				vScrollBar = new VScrollBar();//创建一个 vScrollBar 类的实例对象 hScrollBar 。
     *				vScrollBar.skin = "resource/ui/vscroll.png";//设置 vScrollBar 的皮肤。
     *				vScrollBar.x = 100;//设置 vScrollBar 对象的属性 x 的值，用于控制 vScrollBar 对象的显示位置。
     *				vScrollBar.y = 100;//设置 vScrollBar 对象的属性 y 的值，用于控制 vScrollBar 对象的显示位置。
     *				vScrollBar.changeHandler = new Handler(this, onChange);//设置 vScrollBar 的滚动变化处理器。
     *				Laya.stage.addChild(vScrollBar);//将此 vScrollBar 对象添加到显示列表。
     *			}
     *			private function onChange(value:Number):void
     *			{
     *				trace("滚动条的位置： value=" + value);
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * var vScrollBar;
     * var res = ["resource/ui/vscroll.png", "resource/ui/vscroll$bar.png", "resource/ui/vscroll$down.png", "resource/ui/vscroll$up.png"];
     * Laya.loader.load(res, laya.utils.Handler.create(this, onLoadComplete));//加载资源。
     * function onLoadComplete() {
     *     vScrollBar = new laya.ui.VScrollBar();//创建一个 vScrollBar 类的实例对象 hScrollBar 。
     *     vScrollBar.skin = "resource/ui/vscroll.png";//设置 vScrollBar 的皮肤。
     *     vScrollBar.x = 100;//设置 vScrollBar 对象的属性 x 的值，用于控制 vScrollBar 对象的显示位置。
     *     vScrollBar.y = 100;//设置 vScrollBar 对象的属性 y 的值，用于控制 vScrollBar 对象的显示位置。
     *     vScrollBar.changeHandler = new laya.utils.Handler(this, onChange);//设置 vScrollBar 的滚动变化处理器。
     *     Laya.stage.addChild(vScrollBar);//将此 vScrollBar 对象添加到显示列表。
     * }
     * function onChange(value) {
     *     console.log("滚动条的位置： value=" + value);
     * }
     * @example
     * import VScrollBar = laya.ui.VScrollBar;
     * import Handler = laya.utils.Handler;
     * class VScrollBar_Example {
     *     private vScrollBar: VScrollBar;
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高、渲染模式。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load(["resource/ui/vscroll.png", "resource/ui/vscroll$bar.png", "resource/ui/vscroll$down.png", "resource/ui/vscroll$up.png"], Handler.create(this, this.onLoadComplete));
     *     }
     *     private onLoadComplete(): void {
     *         this.vScrollBar = new VScrollBar();//创建一个 vScrollBar 类的实例对象 hScrollBar 。
     *         this.vScrollBar.skin = "resource/ui/vscroll.png";//设置 vScrollBar 的皮肤。
     *         this.vScrollBar.x = 100;//设置 vScrollBar 对象的属性 x 的值，用于控制 vScrollBar 对象的显示位置。
     *         this.vScrollBar.y = 100;//设置 vScrollBar 对象的属性 y 的值，用于控制 vScrollBar 对象的显示位置。
     *         this.vScrollBar.changeHandler = new Handler(this, this.onChange);//设置 vScrollBar 的滚动变化处理器。
     *         Laya.stage.addChild(this.vScrollBar);//将此 vScrollBar 对象添加到显示列表。
     *     }
     *     private onChange(value: number): void {
     *         console.log("滚动条的位置： value=" + value);
     *     }
     * }
     */
    class VScrollBar extends ScrollBar {
    }
    /**
     * 使用 <code>VSlider</code> 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。
     * <p> <code>VSlider</code> 控件采用垂直方向。滑块轨道从下往上扩展，而标签位于轨道的左右两侧。</p>
     *
     * @example <caption>以下示例代码，创建了一个 <code>VSlider</code> 实例。</caption>
     * package
     *	{
     *		import laya.ui.HSlider;
     *		import laya.ui.VSlider;
     *		import laya.utils.Handler;
     *		public class VSlider_Example
     *		{
     *			private var vSlider:VSlider;
     *			public function VSlider_Example()
     *			{
     *				Laya.init(640, 800);//设置游戏画布宽高。
     *				Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *				Laya.loader.load(["resource/ui/vslider.png", "resource/ui/vslider$bar.png"], Handler.create(this, onLoadComplete));//加载资源。
     *			}
     *			private function onLoadComplete():void
     *			{
     *				vSlider = new VSlider();//创建一个 VSlider 类的实例对象 vSlider 。
     *				vSlider.skin = "resource/ui/vslider.png";//设置 vSlider 的皮肤。
     *				vSlider.min = 0;//设置 vSlider 最低位置值。
     *				vSlider.max = 10;//设置 vSlider 最高位置值。
     *				vSlider.value = 2;//设置 vSlider 当前位置值。
     *				vSlider.tick = 1;//设置 vSlider 刻度值。
     *				vSlider.x = 100;//设置 vSlider 对象的属性 x 的值，用于控制 vSlider 对象的显示位置。
     *				vSlider.y = 100;//设置 vSlider 对象的属性 y 的值，用于控制 vSlider 对象的显示位置。
     *				vSlider.changeHandler = new Handler(this, onChange);//设置 vSlider 位置变化处理器。
     *				Laya.stage.addChild(vSlider);//把 vSlider 添加到显示列表。
     *			}
     *			private function onChange(value:Number):void
     *			{
     *				trace("滑块的位置： value=" + value);
     *			}
     *		}
     *	}
     * @example
     * Laya.init(640, 800);//设置游戏画布宽高
     * Laya.stage.bgColor = "#efefef";//设置画布的背景颜色
     * var vSlider;
     * Laya.loader.load(["resource/ui/vslider.png", "resource/ui/vslider$bar.png"], laya.utils.Handler.create(this, onLoadComplete));//加载资源。
     * function onLoadComplete() {
     *     vSlider = new laya.ui.VSlider();//创建一个 VSlider 类的实例对象 vSlider 。
     *     vSlider.skin = "resource/ui/vslider.png";//设置 vSlider 的皮肤。
     *     vSlider.min = 0;//设置 vSlider 最低位置值。
     *     vSlider.max = 10;//设置 vSlider 最高位置值。
     *     vSlider.value = 2;//设置 vSlider 当前位置值。
     *     vSlider.tick = 1;//设置 vSlider 刻度值。
     *     vSlider.x = 100;//设置 vSlider 对象的属性 x 的值，用于控制 vSlider 对象的显示位置。
     *     vSlider.y = 100;//设置 vSlider 对象的属性 y 的值，用于控制 vSlider 对象的显示位置。
     *     vSlider.changeHandler = new laya.utils.Handler(this, onChange);//设置 vSlider 位置变化处理器。
     *     Laya.stage.addChild(vSlider);//把 vSlider 添加到显示列表。
     * }
     * function onChange(value) {
     *     console.log("滑块的位置： value=" + value);
     * }
     * @example
     * import HSlider = laya.ui.HSlider;
     * import VSlider = laya.ui.VSlider;
     * import Handler = laya.utils.Handler;
     * class VSlider_Example {
     *     private vSlider: VSlider;
     *     constructor() {
     *         Laya.init(640, 800);//设置游戏画布宽高。
     *         Laya.stage.bgColor = "#efefef";//设置画布的背景颜色。
     *         Laya.loader.load(["resource/ui/vslider.png", "resource/ui/vslider$bar.png"], Handler.create(this, this.onLoadComplete));//加载资源。
     *     }
     *     private onLoadComplete(): void {
     *         this.vSlider = new VSlider();//创建一个 VSlider 类的实例对象 vSlider 。
     *         this.vSlider.skin = "resource/ui/vslider.png";//设置 vSlider 的皮肤。
     *         this.vSlider.min = 0;//设置 vSlider 最低位置值。
     *         this.vSlider.max = 10;//设置 vSlider 最高位置值。
     *         this.vSlider.value = 2;//设置 vSlider 当前位置值。
     *         this.vSlider.tick = 1;//设置 vSlider 刻度值。
     *         this.vSlider.x = 100;//设置 vSlider 对象的属性 x 的值，用于控制 vSlider 对象的显示位置。
     *         this.vSlider.y = 100;//设置 vSlider 对象的属性 y 的值，用于控制 vSlider 对象的显示位置。
     *         this.vSlider.changeHandler = new Handler(this, this.onChange);//设置 vSlider 位置变化处理器。
     *         Laya.stage.addChild(this.vSlider);//把 vSlider 添加到显示列表。
     *     }
     *     private onChange(value: number): void {
     *         console.log("滑块的位置： value=" + value);
     *     }
     * }
     * @see laya.ui.Slider
     */
    class VSlider extends Slider {
    }
    class Base64Tool {
        static chars: string;
        static reg: RegExp;
        static reghead: RegExp;
        static lookup: Uint8Array;
        static init(): void;
        /**
         * 判断字符串是否是 base64
         * @param str
         */
        static isBase64String(str: string): boolean;
        /**
         * 编码ArrayBuffer
         * @param arraybuffer
         * @return
         *
         */
        static encode(arraybuffer: ArrayBuffer): string;
        /**
         * 解码成ArrayBuffer
         * @param base64
         * @return
         *
         */
        static decode(base64: string): ArrayBuffer;
    }
    /**
     * <code>Browser</code> 是浏览器代理类。封装浏览器及原生 js 提供的一些功能。
     */
    class Browser {
        /** 浏览器代理信息。*/
        static userAgent: string;
        /** 表示是否在移动设备，包括IOS和安卓等设备内。*/
        static onMobile: boolean;
        /** 表示是否在 IOS 设备内。*/
        static onIOS: boolean;
        /** 表示是否在 Mac 设备。*/
        static onMac: boolean;
        /** 表示是否在 IPhone 设备内。*/
        static onIPhone: boolean;
        /** 表示是否在 IPad 设备内。*/
        static onIPad: boolean;
        /** 表示是否在 Android 设备内。*/
        static onAndroid: boolean;
        /** 表示是否在 Windows Phone 设备内。*/
        static onWP: boolean;
        /** 表示是否在 QQ 浏览器内。*/
        static onQQBrowser: boolean;
        /** 表示是否在移动端 QQ 或 QQ 浏览器内。*/
        static onMQQBrowser: boolean;
        /** 表示是否在 Safari 内。*/
        static onSafari: boolean;
        /** 表示是否在 Chrome 内 */
        static onChrome: boolean;
        /** 表示是否在 IE 浏览器内*/
        static onIE: boolean;
        /** 表示是否在 微信 内*/
        static onWeiXin: boolean;
        /** 表示是否在 PC 端。*/
        static onPC: boolean;
        /** 微信小游戏 **/
        static onMiniGame: boolean;
        /** 百度小游戏 **/
        static onBDMiniGame: boolean;
        /** 小米戏小游戏 **/
        static onKGMiniGame: boolean;
        /** OPPO小游戏 **/
        static onQGMiniGame: boolean;
        /** VIVO小游戏 **/
        static onVVMiniGame: boolean;
        /** 阿里小游戏 **/
        static onAlipayMiniGame: boolean;
        /***手机QQ小游戏 */
        static onQQMiniGame: boolean;
        /*** BILIBILI小游戏 */
        static onBLMiniGame: boolean;
        /** 抖音小游戏*/
        static onTTMiniGame: boolean;
        /** 华为快游戏 */
        static onHWMiniGame: boolean;
        /** 淘宝小程序 */
        static onTBMiniGame: boolean;
        /** @private */
        static onFirefox: boolean;
        /** Edge浏览器 */
        static onEdge: boolean;
        /** @private */
        static onLayaRuntime: boolean;
        /** 真实平台类型，onMobile等是通过UserAgent判断，可能具有欺骗性 **/
        static platform: number;
        static PLATFORM_PC: number;
        static PLATFORM_ANDROID: number;
        static PLATFORM_IOS: number;
        /** 表示是否支持WebAudio*/
        static supportWebAudio: boolean;
        /** 表示是否支持LocalStorage*/
        static supportLocalStorage: boolean;
        /** 全局离线画布（非主画布）。主要用来测量字体、获取image数据。*/
        static canvas: any;
        /** 全局离线画布上绘图的环境（非主画布）。 */
        static context: CanvasRenderingContext2D;
        /** 小游戏平台服务对象 */
        static miniGameContext: any;
        /** @private */
        private static _window;
        /** @private */
        private static _document;
        /** @private */
        private static _container;
        /** @private */
        private static _pixelRatio;
        /** @private */
        private static _clientWidth;
        /** @private */
        private static _clientHeight;
        /** @private */
        static mainCanvas: any;
        /**@private */
        private static hanzi;
        /**@private */
        private static fontMap;
        /**@private */
        static measureText: Function;
        /**
         * 获取是否为小游戏环境
         * @returns onMiniGame || onBDMiniGame || onQGMiniGame || onKGMiniGame || onVVMiniGame || onAlipayMiniGame || onQQMiniGame || onBLMiniGame || onTTMiniGame || onHWMiniGame || onTBMiniGame
         */
        static get _isMiniGame(): boolean;
        /**
         * 创建浏览器原生节点。
         * @param	type 节点类型。
         * @return	创建的节点对象的引用。
         */
        static createElement(type: string): any;
        /**
         * 返回 Document 对象中拥有指定 id 的第一个对象的引用。
         * @param	type 节点id。
         * @return	节点对象。
         */
        static getElementById(type: string): any;
        /**
         * 移除指定的浏览器原生节点对象。
         * @param	type 节点对象。
         */
        static removeElement(ele: any): void;
        /**
         * 获取浏览器当前时间戳，单位为毫秒。
         */
        static now(): number;
        /**
         * 浏览器窗口可视宽度。
         * 通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerWidth(包含滚动条宽度) > document.body.clientWidth(不包含滚动条宽度)，如果前者为0或为空，则选择后者。
         */
        static get clientWidth(): number;
        static set clientWidth(value: number);
        /**
         * 浏览器窗口可视高度。
         * 通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerHeight(包含滚动条高度) > document.body.clientHeight(不包含滚动条高度) > document.documentElement.clientHeight(不包含滚动条高度)，如果前者为0或为空，则选择后者。
         */
        static get clientHeight(): number;
        static set clientHeight(value: number);
        /** 浏览器窗口物理宽度。考虑了设备像素比。*/
        static get width(): number;
        /** 浏览器窗口物理高度。考虑了设备像素比。*/
        static get height(): number;
        /** 获得设备像素比。*/
        static get pixelRatio(): number;
        /**画布容器，用来盛放画布的容器。方便对画布进行控制*/
        static get container(): any;
        static set container(value: any);
        /**浏览器原生 window 对象的引用。*/
        static get window(): any;
        /**浏览器原生 document 对象的引用。*/
        static get document(): any;
        /**
         * 获得URL参数值
         * @param	name 参数名称
         * @return	参数值
         */
        static getQueryString(name: string): string;
        static getSafariToolbarOffset(): number;
        static loadLib(src: string): Promise<void>;
    }
    function arrayBufferSlice(this: ArrayBuffer, start: number, end: number): ArrayBuffer;
    function uint8ArraySlice(this: Uint8Array): Uint8Array;
    function float32ArraySlice(this: Float32Array): Float32Array;
    function uint16ArraySlice(this: Uint16Array, ...arg: any[]): Uint16Array;
    /**
     * <p> <code>Byte</code> 类提供用于优化读取、写入以及处理二进制数据的方法和属性。</p>
     * <p> <code>Byte</code> 类适用于需要在字节层访问数据的高级开发人员。</p>
     */
    class Byte {
        /**
         * <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 <code>getSystemEndian</code> 可以获取当前系统的字节序。</p>
         * <p> <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。<br/>
         * <code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
         */
        static BIG_ENDIAN: string;
        /**
         * <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 <code>getSystemEndian</code> 可以获取当前系统的字节序。</p>
         * <p> <code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。<br/>
         * <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。</p>
         */
        static LITTLE_ENDIAN: string;
        /**@private */
        private static _sysEndian;
        /**@private 是否为小端数据。*/
        protected _xd_: boolean;
        /**@private */
        private _allocated_;
        /**@private 原始数据。*/
        protected _d_: any;
        /**@private DataView*/
        protected _u8d_: any;
        /**@private */
        protected _pos_: number;
        /**@private */
        protected _length: number;
        /**
         * <p>获取当前主机的字节序。</p>
         * <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。</p>
         * <p> <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。<br/>
         * <code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
         * @return 当前系统的字节序。
         */
        static getSystemEndian(): string;
        /**
         * 创建一个 <code>Byte</code> 类的实例。
         * @param	data	用于指定初始化的元素数目，或者用于初始化的TypedArray对象、ArrayBuffer对象。如果为 null ，则预分配一定的内存空间，当可用空间不足时，优先使用这部分内存，如果还不够，则重新分配所需内存。
         */
        constructor(data?: any);
        /**
         * 获取此对象的 ArrayBuffer 数据，数据只包含有效数据部分。
         */
        get buffer(): ArrayBuffer;
        /**
         * <p> <code>Byte</code> 实例的字节序。取值为：<code>BIG_ENDIAN</code> 或 <code>BIG_ENDIAN</code> 。</p>
         * <p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 <code>getSystemEndian</code> 可以获取当前系统的字节序。</p>
         * <p> <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。<br/>
         *  <code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
         */
        get endian(): string;
        set endian(value: string);
        /**
         * <p> <code>Byte</code> 对象的长度（以字节为单位）。</p>
         * <p>如果将长度设置为大于当前长度的值，则用零填充字节数组的右侧；如果将长度设置为小于当前长度的值，将会截断该字节数组。</p>
         * <p>如果要设置的长度大于当前已分配的内存空间的字节长度，则重新分配内存空间，大小为以下两者较大者：要设置的长度、当前已分配的长度的2倍，并将原有数据拷贝到新的内存空间中；如果要设置的长度小于当前已分配的内存空间的字节长度，也会重新分配内存空间，大小为要设置的长度，并将原有数据从头截断为要设置的长度存入新的内存空间中。</p>
         */
        set length(value: number);
        get length(): number;
        /**@private */
        private _resizeBuffer;
        /**
         * @private
         * <p>常用于解析固定格式的字节流。</p>
         * <p>先从字节流的当前字节偏移位置处读取一个 <code>Uint16</code> 值，然后以此值为长度，读取此长度的字符串。</p>
         * @return 读取的字符串。
         */
        getString(): string;
        /**
         * <p>常用于解析固定格式的字节流。</p>
         * <p>先从字节流的当前字节偏移位置处读取一个 <code>Uint16</code> 值，然后以此值为长度，读取此长度的字符串。</p>
         * @return 读取的字符串。
         */
        readString(): string;
        /**
         * @private
         * <p>从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Float32Array</code> 对象并返回此对象。</p>
         * <p><b>注意：</b>返回的 Float32Array 对象，在 JavaScript 环境下，是原生的 HTML5 Float32Array 对象，对此对象的读取操作都是基于运行此程序的当前主机字节序，此顺序可能与实际数据的字节序不同，如果使用此对象进行读取，需要用户知晓实际数据的字节序和当前主机字节序，如果相同，可正常读取，否则需要用户对实际数据(Float32Array.buffer)包装一层 DataView ，使用 DataView 对象可按照指定的字节序进行读取。</p>
         * @param	start	开始位置。
         * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return  读取的 Float32Array 对象。
         */
        getFloat32Array(start: number, len: number): any;
        /**
         * 从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Float32Array</code> 对象并返回此对象。
         * @param	start	开始位置。
         * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return  读取的 Float32Array 对象。
         */
        readFloat32Array(start: number, len: number): any;
        /**
         * @private
         * 从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Uint8Array</code> 对象并返回此对象。
         * @param	start	开始位置。
         * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return  读取的 Uint8Array 对象。
         */
        getUint8Array(start: number, len: number): Uint8Array;
        /**
         * 从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Uint8Array</code> 对象并返回此对象。
         * @param	start	开始位置。
         * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return  读取的 Uint8Array 对象。
         */
        readUint8Array(start: number, len: number): Uint8Array;
        /**
         * @private
         * <p>从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Int16Array</code> 对象并返回此对象。</p>
         * <p><b>注意：</b>返回的 Int16Array 对象，在 JavaScript 环境下，是原生的 HTML5 Int16Array 对象，对此对象的读取操作都是基于运行此程序的当前主机字节序，此顺序可能与实际数据的字节序不同，如果使用此对象进行读取，需要用户知晓实际数据的字节序和当前主机字节序，如果相同，可正常读取，否则需要用户对实际数据(Int16Array.buffer)包装一层 DataView ，使用 DataView 对象可按照指定的字节序进行读取。</p>
         * @param	start	开始读取的字节偏移量位置。
         * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return  读取的 Int16Array 对象。
         */
        getInt16Array(start: number, len: number): any;
        /**
         * 从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Int16Array</code> 对象并返回此对象。
         * @param	start	开始读取的字节偏移量位置。
         * @param	len		需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
         * @return  读取的 Uint8Array 对象。
         */
        readInt16Array(start: number, len: number): any;
        /**
         * @private
         * 从字节流的当前字节偏移位置处读取一个 IEEE 754 单精度（32 位）浮点数。
         * @return 单精度（32 位）浮点数。
         */
        getFloat32(): number;
        /**
         * 从字节流的当前字节偏移位置处读取一个 IEEE 754 单精度（32 位）浮点数。
         * @return 单精度（32 位）浮点数。
         */
        readFloat32(): number;
        /**
         * @private
         * 从字节流的当前字节偏移量位置处读取一个 IEEE 754 双精度（64 位）浮点数。
         * @return 双精度（64 位）浮点数。
         */
        getFloat64(): number;
        /**
         * 从字节流的当前字节偏移量位置处读取一个 IEEE 754 双精度（64 位）浮点数。
         * @return 双精度（64 位）浮点数。
         */
        readFloat64(): number;
        /**
         * 在字节流的当前字节偏移量位置处写入一个 IEEE 754 单精度（32 位）浮点数。
         * @param	value	单精度（32 位）浮点数。
         */
        writeFloat32(value: number): void;
        /**
         * 在字节流的当前字节偏移量位置处写入一个 IEEE 754 双精度（64 位）浮点数。
         * @param	value	双精度（64 位）浮点数。
         */
        writeFloat64(value: number): void;
        /**
         * @private
         * 从字节流的当前字节偏移量位置处读取一个 Int32 值。
         * @return Int32 值。
         */
        getInt32(): number;
        /**
         * 从字节流的当前字节偏移量位置处读取一个 Int32 值。
         * @return Int32 值。
         */
        readInt32(): number;
        /**
         * @private
         * 从字节流的当前字节偏移量位置处读取一个 Uint32 值。
         * @return Uint32 值。
         */
        getUint32(): number;
        /**
         * 从字节流的当前字节偏移量位置处读取一个 Uint32 值。
         * @return Uint32 值。
         */
        readUint32(): number;
        /**
         * 在字节流的当前字节偏移量位置处写入指定的 Int32 值。
         * @param	value	需要写入的 Int32 值。
         */
        writeInt32(value: number): void;
        /**
         * 在字节流的当前字节偏移量位置处写入 Uint32 值。
         * @param	value	需要写入的 Uint32 值。
         */
        writeUint32(value: number): void;
        /**
         * @private
         * 从字节流的当前字节偏移量位置处读取一个 Int16 值。
         * @return Int16 值。
         */
        getInt16(): number;
        /**
         * 从字节流的当前字节偏移量位置处读取一个 Int16 值。
         * @return Int16 值。
         */
        readInt16(): number;
        /**
         * @private
         * 从字节流的当前字节偏移量位置处读取一个 Uint16 值。
         * @return Uint16 值。
         */
        getUint16(): number;
        /**
         * 从字节流的当前字节偏移量位置处读取一个 Uint16 值。
         * @return Uint16 值。
         */
        readUint16(): number;
        /**
         * 在字节流的当前字节偏移量位置处写入指定的 Uint16 值。
         * @param	value	需要写入的Uint16 值。
         */
        writeUint16(value: number): void;
        /**
         * 在字节流的当前字节偏移量位置处写入指定的 Int16 值。
         * @param	value	需要写入的 Int16 值。
         */
        writeInt16(value: number): void;
        /**
         * @private
         * 从字节流的当前字节偏移量位置处读取一个 Uint8 值。
         * @return Uint8 值。
         */
        getUint8(): number;
        /**
         * 从字节流的当前字节偏移量位置处读取一个 Uint8 值。
         * @return Uint8 值。
         */
        readUint8(): number;
        /**
         * 在字节流的当前字节偏移量位置处写入指定的 Uint8 值。
         * @param	value	需要写入的 Uint8 值。
         */
        writeUint8(value: number): void;
        /**
         * @private
         * 读取指定长度的 UTF 型字符串。
         * @param	len 需要读取的长度。
         * @return 读取的字符串。
         */
        private _rUTF;
        /**
         * @private
         * 读取 <code>len</code> 参数指定的长度的字符串。
         * @param	len	要读取的字符串的长度。
         * @return 指定长度的字符串。
         */
        getCustomString(len: number): string;
        /**
         * @private
         * 读取 <code>len</code> 参数指定的长度的字符串。
         * @param	len	要读取的字符串的长度。
         * @return 指定长度的字符串。
         */
        readCustomString(len: number): string;
        /**
         * 移动或返回 Byte 对象的读写指针的当前位置（以字节为单位）。下一次调用读取方法时将在此位置开始读取，或者下一次调用写入方法时将在此位置开始写入。
         */
        get pos(): number;
        set pos(value: number);
        /**
         * 可从字节流的当前位置到末尾读取的数据的字节数。
         */
        get bytesAvailable(): number;
        /**
         * 清除字节数组的内容，并将 length 和 pos 属性重置为 0。调用此方法将释放 Byte 实例占用的内存。
         */
        clear(): void;
        /**
         * <p>将 UTF-8 字符串写入字节流。类似于 writeUTF() 方法，但 writeUTFBytes() 不使用 16 位长度的字为字符串添加前缀。</p>
         * <p>对应的读取方法为： getUTFBytes 。</p>
         * @param value 要写入的字符串。
         */
        writeUTFBytes(value: string): void;
        /**
         * <p>将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节。</p>
         * <p>对应的读取方法为： getUTFString 。</p>
         * @param	value 要写入的字符串值。
         */
        writeUTFString(value: string): void;
        /**
         * <p>将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 32 位整数），然后写入表示字符串字符的字节。</p>
         * @param	value 要写入的字符串值。
         */
        writeUTFString32(value: string): void;
        /**
         * @private
         * 读取 UTF-8 字符串。
         * @return 读取的字符串。
         */
        readUTFString(): string;
        /**
         * @private
         */
        readUTFString32(): string;
        /**
         * <p>从字节流中读取一个 UTF-8 字符串。假定字符串的前缀是一个无符号的短整型（以此字节表示要读取的长度）。</p>
         * <p>对应的写入方法为： writeUTFString 。</p>
         * @return 读取的字符串。
         */
        getUTFString(): string;
        /**
         * @private
         * 读字符串，必须是 writeUTFBytes 方法写入的字符串。
         * @param len	要读的buffer长度，默认将读取缓冲区全部数据。
         * @return 读取的字符串。
         */
        readUTFBytes(len?: number): string;
        /**
         * <p>从字节流中读取一个由 length 参数指定的长度的 UTF-8 字节序列，并返回一个字符串。</p>
         * <p>一般读取的是由 writeUTFBytes 方法写入的字符串。</p>
         * @param len	要读的buffer长度，默认将读取缓冲区全部数据。
         * @return 读取的字符串。
         */
        getUTFBytes(len?: number): string;
        /**
         * <p>在字节流中写入一个字节。</p>
         * <p>使用参数的低 8 位。忽略高 24 位。</p>
         * @param	value
         */
        writeByte(value: number): void;
        /**
         * <p>从字节流中读取带符号的字节。</p>
         * <p>返回值的范围是从 -128 到 127。</p>
         * @return 介于 -128 和 127 之间的整数。
         */
        readByte(): number;
        /**
         * @private
         * 从字节流中读取带符号的字节。
         */
        getByte(): number;
        /**
         * <p>将指定 arraybuffer 对象中的以 offset 为起始偏移量， length 为长度的字节序列写入字节流。</p>
         * <p>如果省略 length 参数，则使用默认长度 0，该方法将从 offset 开始写入整个缓冲区；如果还省略了 offset 参数，则写入整个缓冲区。</p>
         * <p>如果 offset 或 length 小于0，本函数将抛出异常。</p>
         * @param	arraybuffer	需要写入的 Arraybuffer 对象。
         * @param	offset		Arraybuffer 对象的索引的偏移量（以字节为单位）
         * @param	length		从 Arraybuffer 对象写入到 Byte 对象的长度（以字节为单位）
         */
        writeArrayBuffer(arraybuffer: any, offset?: number, length?: number): void;
        /**
         * 读取ArrayBuffer数据
         * @param	length
         * @return
         */
        readArrayBuffer(length: number): ArrayBuffer;
    }
    /**
     * @private
     * 对象缓存统一管理类
     */
    class CacheManger {
        /**
         * 单次清理检测允许执行的时间，单位ms。
         */
        static loopTimeLimit: number;
        /**
         * @private
         */
        private static _cacheList;
        /**
         * @private
         * 当前检测的索引
         */
        private static _index;
        constructor();
        /**
         * 注册cache管理函数
         * @param disposeFunction 释放函数 fun(force:Boolean)
         * @param getCacheListFunction 获取cache列表函数fun():Array
         *
         */
        static regCacheByFunction(disposeFunction: Function, getCacheListFunction: Function): void;
        /**
         * 移除cache管理函数
         * @param disposeFunction 释放函数 fun(force:Boolean)
         * @param getCacheListFunction 获取cache列表函数fun():Array
         *
         */
        static unRegCacheByFunction(disposeFunction: Function, getCacheListFunction: Function): void;
        /**
         * 强制清理所有管理器
         *
         */
        static forceDispose(): void;
        /**
         * 开始检测循环
         * @param waitTime 检测间隔时间
         *
         */
        static beginCheck(waitTime?: number): void;
        /**
         * 停止检测循环
         *
         */
        static stopCheck(): void;
        /**
         * @private
         * 检测函数
         */
        private static _checkLoop;
    }
    /**
     * @private
     */
    class CallLater {
        static I: CallLater;
        /**@private */
        private _pool;
        /**@private */
        private _map;
        /**@private */
        private _laters;
        /** @private */
        private _getHandler;
        /**
         * 延迟执行。
         * @param	caller 执行域(this)。
         * @param	method 定时器回调函数。
         * @param	args 回调参数。
         */
        callLater(caller: any, method: Function, args?: any[]): void;
        /**
         * 立即执行 callLater 。
         * @param	caller 执行域(this)。
         * @param	method 定时器回调函数。
         */
        runCallLater(caller: any, method: Function): void;
        clear(caller: any, method: Function): boolean;
        clearAll(caller: any): void;
    }
    /**
     * <code>ClassUtils</code> 是一个类工具类。
     */
    class ClassUtils {
        static _classMap: Record<string, any>;
        /**
         * 注册 Class 映射，方便在class反射时获取。
         * @param	className 映射的名字或者别名。
         * @param	classDef 类的全名或者类的引用，全名比如:"laya.Sprite"。
         */
        static regClass(className: string, classDef: any): void;
        /**
         * 根据名字返回类对象。
         * @param	className 类名(比如laya.display.Sprite)或者注册的别名(比如Sprite)。
         * @return 类对象
         */
        static getClass(className: string): any;
        /**
         * 根据名称创建 Class 实例。
         * @param	className 类名(比如laya.display.Sprite)或者注册的别名(比如Sprite)。
         * @return	返回类的实例。
         */
        static getInstance(className: string): any;
    }
    /**
     * @private
     * <code>ColorUtils</code> 是一个颜色值处理类。
     */
    class ColorUtils {
        /**@private */
        static _SAVE: any;
        /**@private */
        static _SAVE_SIZE: number;
        /**@private */
        /**@private */
        private static _DEFAULT;
        /**rgba 取值范围0-1*/
        arrColor: any[];
        /** 字符串型颜色值。*/
        strColor: string;
        /** uint 型颜色值。*/
        numColor: number;
        /**
         * 根据指定的属性值，创建一个 <code>Color</code> 类的实例。
         * @param	value 颜色值，可以是字符串："#ff0000"或者16进制颜色 0xff0000。
         */
        constructor(value: any);
        /**@private */
        static _initDefault(): any;
        /**@private 缓存太大，则清理缓存*/
        static _initSaveMap(): void;
        /**
         * 根据指定的属性值，创建并返回一个 <code>Color</code> 类的实例。
         * @param	value 颜色值，可以是字符串："#ff0000"或者16进制颜色 0xff0000。
         * @return 一个 <code>Color</code> 类的实例。
         */
        static create(value: any): ColorUtils;
    }
    class Delegate {
        private _flag;
        private _items;
        constructor();
        add(callback: Function, target?: any, args?: any[]): void;
        once(callback: Function, target?: any, args?: any[]): void;
        remove(callback: Function, target?: any): void;
        clear(): void;
        clearForTarget(target: any): void;
        get count(): number;
        invoke(...args: any[]): void;
    }
    /**
     * @private
     * <code>Dragging</code> 类是触摸滑动控件。
     */
    class Dragging {
        /** 被拖动的对象。*/
        target: Sprite;
        /** 缓动衰减系数。*/
        ratio: number;
        /** 单帧最大偏移量。*/
        maxOffset: number;
        /** 滑动范围。*/
        area: Rectangle;
        /** 表示拖动是否有惯性。*/
        hasInertia: boolean;
        /** 橡皮筋最大值。*/
        elasticDistance: number;
        /** 橡皮筋回弹时间，单位为毫秒。*/
        elasticBackTime: number;
        /** 事件携带数据。*/
        data: any;
        private _dragging;
        private _clickOnly;
        private _elasticRateX;
        private _elasticRateY;
        private _lastX;
        private _lastY;
        private _offsetX;
        private _offsetY;
        private _offsets;
        private _tween;
        private _parent;
        /**
         * 开始拖拽。
         * @param	target 待拖拽的 <code>Sprite</code> 对象。
         * @param	area 滑动范围。
         * @param	hasInertia 拖动是否有惯性。
         * @param	elasticDistance 橡皮筋最大值。
         * @param	elasticBackTime 橡皮筋回弹时间，单位为毫秒。
         * @param	data 事件携带数据。
         * @param	ratio 惯性阻尼系数
         */
        start(target: Sprite, area: Rectangle, hasInertia: boolean, elasticDistance: number, elasticBackTime: number, data: any, ratio?: number): void;
        /**
         * 清除计时器。
         */
        private clearTimer;
        /**
         * 停止拖拽。
         */
        stop(): void;
        /**
         * 拖拽的循环处理函数。
         */
        private loop;
        /**
         * 拖拽区域检测。
         */
        private checkArea;
        /**
         * 移动至设定的拖拽区域。
         */
        private backToArea;
        /**
         * 舞台的抬起事件侦听函数。
         * @param	e Event 对象。
         */
        private onStageMouseUp;
        /**
         * 橡皮筋效果检测。
         */
        private checkElastic;
        /**
         * 移动。
         */
        private tweenMove;
        /**
         * 结束拖拽。
         */
        private clear;
    }
    /**
    * <code>Ease</code> 类定义了缓动函数，以便实现 <code>Tween</code> 动画的缓动效果。
    */
    class Ease {
        /**
         * 定义无加速持续运动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static linearNone(t: number, b: number, c: number, d: number): number;
        /**
         * 定义无加速持续运动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static linearIn(t: number, b: number, c: number, d: number): number;
        /**
         * 定义无加速持续运动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static linearInOut(t: number, b: number, c: number, d: number): number;
        /**
         * 定义无加速持续运动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static linearOut(t: number, b: number, c: number, d: number): number;
        /**
         * 方法以零速率开始运动，然后在执行时加快运动速度。
         * 它的运动是类似一个球落向地板又弹起后，几次逐渐减小的回弹运动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static bounceIn(t: number, b: number, c: number, d: number): number;
        /**
         * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * 它的运动是类似一个球落向地板又弹起后，几次逐渐减小的回弹运动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static bounceInOut(t: number, b: number, c: number, d: number): number;
        /**
         * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * 它的运动是类似一个球落向地板又弹起后，几次逐渐减小的回弹运动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static bounceOut(t: number, b: number, c: number, d: number): number;
        /**
         * 开始时往后运动，然后反向朝目标移动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @param	s 指定过冲量，此处数值越大，过冲越大。
         * @return 指定时间的插补属性的值。
         */
        static backIn(t: number, b: number, c: number, d: number, s?: number): number;
        /**
         * 开始运动时是向后跟踪，再倒转方向并朝目标移动，稍微过冲目标，然后再次倒转方向，回来朝目标移动。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @param	s 指定过冲量，此处数值越大，过冲越大。
         * @return 指定时间的插补属性的值。
         */
        static backInOut(t: number, b: number, c: number, d: number, s?: number): number;
        /**
         * 开始运动时是朝目标移动，稍微过冲，再倒转方向回来朝着目标。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @param	s 指定过冲量，此处数值越大，过冲越大。
         * @return 指定时间的插补属性的值。
         */
        static backOut(t: number, b: number, c: number, d: number, s?: number): number;
        /**
         * 方法以零速率开始运动，然后在执行时加快运动速度。
         * 其中的运动由按照指数方式衰减的正弦波来定义。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @param	a 指定正弦波的幅度。
         * @param	p 指定正弦波的周期。
         * @return 指定时间的插补属性的值。
         */
        static elasticIn(t: number, b: number, c: number, d: number, a?: number, p?: number): number;
        /**
         * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * 其中的运动由按照指数方式衰减的正弦波来定义。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @param	a 指定正弦波的幅度。
         * @param	p 指定正弦波的周期。
         * @return 指定时间的插补属性的值。
         */
        static elasticInOut(t: number, b: number, c: number, d: number, a?: number, p?: number): number;
        /**
         * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * 其中的运动由按照指数方式衰减的正弦波来定义。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @param	a 指定正弦波的幅度。
         * @param	p 指定正弦波的周期。
         * @return 指定时间的插补属性的值。
         */
        static elasticOut(t: number, b: number, c: number, d: number, a?: number, p?: number): number;
        /**
         * 以零速率开始运动，然后在执行时加快运动速度。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static strongIn(t: number, b: number, c: number, d: number): number;
        /**
         * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static strongInOut(t: number, b: number, c: number, d: number): number;
        /**
         * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static strongOut(t: number, b: number, c: number, d: number): number;
        /**
         * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Sine 缓动方程中的运动加速度小于 Quad 方程中的运动加速度。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static sineInOut(t: number, b: number, c: number, d: number): number;
        /**
         * 以零速率开始运动，然后在执行时加快运动速度。
         * Sine 缓动方程中的运动加速度小于 Quad 方程中的运动加速度。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static sineIn(t: number, b: number, c: number, d: number): number;
        /**
         * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Sine 缓动方程中的运动加速度小于 Quad 方程中的运动加速度。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static sineOut(t: number, b: number, c: number, d: number): number;
        /**
         * 以零速率开始运动，然后在执行时加快运动速度。
         * Quint 缓动方程的运动加速大于 Quart 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quintIn(t: number, b: number, c: number, d: number): number;
        /**
         * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Quint 缓动方程的运动加速大于 Quart 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quintInOut(t: number, b: number, c: number, d: number): number;
        /**
         * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Quint 缓动方程的运动加速大于 Quart 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quintOut(t: number, b: number, c: number, d: number): number;
        /**
         * 方法以零速率开始运动，然后在执行时加快运动速度。
         * Quart 缓动方程的运动加速大于 Cubic 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quartIn(t: number, b: number, c: number, d: number): number;
        /**
         * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Quart 缓动方程的运动加速大于 Cubic 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quartInOut(t: number, b: number, c: number, d: number): number;
        /**
         * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Quart 缓动方程的运动加速大于 Cubic 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quartOut(t: number, b: number, c: number, d: number): number;
        /**
         * 方法以零速率开始运动，然后在执行时加快运动速度。
         * Cubic 缓动方程的运动加速大于 Quad 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static cubicIn(t: number, b: number, c: number, d: number): number;
        /**
         * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Cubic 缓动方程的运动加速大于 Quad 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static cubicInOut(t: number, b: number, c: number, d: number): number;
        /**
         * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Cubic 缓动方程的运动加速大于 Quad 缓动方程。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static cubicOut(t: number, b: number, c: number, d: number): number;
        /**
         * 方法以零速率开始运动，然后在执行时加快运动速度。
         * Quad 缓动方程中的运动加速度等于 100% 缓动的时间轴补间的运动加速度，并且显著小于 Cubic 缓动方程中的运动加速度。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quadIn(t: number, b: number, c: number, d: number): number;
        /**
         * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * Quad 缓动方程中的运动加速度等于 100% 缓动的时间轴补间的运动加速度，并且显著小于 Cubic 缓动方程中的运动加速度。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quadInOut(t: number, b: number, c: number, d: number): number;
        /**
         * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * Quad 缓动方程中的运动加速度等于 100% 缓动的时间轴补间的运动加速度，并且显著小于 Cubic 缓动方程中的运动加速度。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static quadOut(t: number, b: number, c: number, d: number): number;
        /**
         * 方法以零速率开始运动，然后在执行时加快运动速度。
         * 其中每个时间间隔是剩余距离减去一个固定比例部分。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static expoIn(t: number, b: number, c: number, d: number): number;
        /**
         * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * 其中每个时间间隔是剩余距离减去一个固定比例部分。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static expoInOut(t: number, b: number, c: number, d: number): number;
        /**
         * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * 其中每个时间间隔是剩余距离减去一个固定比例部分。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static expoOut(t: number, b: number, c: number, d: number): number;
        /**
         * 方法以零速率开始运动，然后在执行时加快运动速度。
         * 缓动方程的运动加速会产生突然的速率变化。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static circIn(t: number, b: number, c: number, d: number): number;
        /**
         * 开始运动时速率为零，先对运动进行加速，再减速直到速率为零。
         * 缓动方程的运动加速会产生突然的速率变化。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static circInOut(t: number, b: number, c: number, d: number): number;
        /**
         * 以较快速度开始运动，然后在执行时减慢运动速度，直至速率为零。
         * 缓动方程的运动加速会产生突然的速率变化。
         * @param	t 指定当前时间，介于 0 和持续时间之间（包括二者）。
         * @param	b 指定动画属性的初始值。
         * @param	c 指定动画属性的更改总计。
         * @param	d 指定运动的持续时间。
         * @return 指定时间的插补属性的值。
         */
        static circOut(t: number, b: number, c: number, d: number): number;
    }
    class FontInfo {
        private static _cache;
        /**
         * 解析字体模型
         * @param font
         */
        static parse(font: string): FontInfo;
        constructor(font: string | null);
        /**
         * 设置字体格式
         * @param value
         */
        setFont(value: string): void;
    }
    /**
     * <code>HalfFloatUtils</code> 类用于创建HalfFloat工具。
     */
    class HalfFloatUtils {
        /**
         * round a number to a half float number bits.
         * @param {number} num
         */
        static roundToFloat16Bits(num: number): number;
        /**
         * convert a half float number bits to a number.
         * @param {number} float16bits - half float number bits
         */
        static convertToNumber(float16bits: number): number;
    }
    /**
     * <p><code>Handler</code> 是事件处理器类。</p>
     * <p>推荐使用 Handler.create() 方法从对象池创建，减少对象创建消耗。创建的 Handler 对象不再使用后，可以使用 Handler.recover() 将其回收到对象池，回收后不要再使用此对象，否则会导致不可预料的错误。</p>
     * <p><b>注意：</b>由于鼠标事件也用本对象池，不正确的回收及调用，可能会影响鼠标事件的执行。</p>
     */
    class Handler {
        /**@private handler对象池*/
        protected static _pool: Handler[];
        /**@private */
        private static _gid;
        /** 执行域(this)。*/
        caller: Object | null;
        /** 处理方法。*/
        method: Function | null;
        /** 参数。*/
        args: any[] | null;
        /** 表示是否只执行一次。如果为true，回调后执行recover()进行回收，回收后会被再利用，默认为false 。*/
        once: boolean;
        /**@private */
        protected _id: number;
        /**
         * 根据指定的属性值，创建一个 <code>Handler</code> 类的实例。
         * @param	caller 执行域。
         * @param	method 处理函数。
         * @param	args 函数参数。
         * @param	once 是否只执行一次。
         */
        constructor(caller?: Object | null, method?: Function | null, args?: any[] | null, once?: boolean);
        /**
         * 设置此对象的指定属性值。
         * @param	caller 执行域(this)。
         * @param	method 回调方法。
         * @param	args 携带的参数。
         * @param	once 是否只执行一次，如果为true，执行后执行recover()进行回收。
         * @return  返回 handler 本身。
         */
        setTo(caller: any, method: Function | null, args: any[] | null, once?: boolean): Handler;
        /**
         * 执行处理器。
         */
        run(): any;
        /**
         * 执行处理器，并携带额外数据。
         * @param	data 附加的回调数据，可以是单数据或者Array(作为多参)。
         */
        runWith(data: any): any;
        /**
         * 清理对象引用。
         */
        clear(): Handler;
        /**
         * 清理并回收到 Handler 对象池内。
         */
        recover(): void;
        /**
         * 从对象池内创建一个Handler，默认会执行一次并立即回收，如果不需要自动回收，设置once参数为false。
         * @param	caller 执行域(this)。
         * @param	method 回调方法。
         * @param	args 携带的参数。
         * @param	once 是否只执行一次，如果为true，回调后执行recover()进行回收，默认为true。
         * @return  返回创建的handler实例。
         */
        static create(caller: any, method: Function | null, args?: any[] | null, once?: boolean): Handler;
    }
    /**
     * 鼠标点击区域，可以设置绘制一系列矢量图作为点击区域和非点击区域（目前只支持圆形，矩形，多边形）
     *
     */
    class HitArea implements IHitArea {
        _hit: Graphics;
        _unHit: Graphics;
        /**
         * 检测对象是否包含指定的点。
         * @param	x	点的 X 轴坐标值（水平位置）。
         * @param	y	点的 Y 轴坐标值（垂直位置）。
         * @return	如果包含指定的点，则值为 true；否则为 false。
         */
        contains(x: number, y: number, sp: Sprite): boolean;
        /**
         * 可点击区域，可以设置绘制一系列矢量图作为点击区域（目前只支持圆形，矩形，多边形）
         */
        get hit(): Graphics;
        set hit(value: Graphics);
        /**
         * 不可点击区域，可以设置绘制一系列矢量图作为非点击区域（目前只支持圆形，矩形，多边形）
         */
        get unHit(): Graphics;
        set unHit(value: Graphics);
        onAfterDeserialize(): void;
    }
    /**
     * @private
     * <code>IClone</code> 资源克隆接口。
     */
    interface IClone {
        clone(): any;
        cloneTo(destObject: any): void;
    }
    interface IHitArea {
        contains(x: number, y: number, sp?: Sprite): boolean;
    }
    /**
    * 图片二进制处理类
    * @ author:xs
    * @ data: 2021-11-03 10:54
    */
    class ImgUtils {
        /**存储数据池*/
        static data: any;
        /**是否保存使用的数据*/
        static isSavaData: boolean;
        /**
         * 比较版本内容
         * @param curVersion 当前版本
         * @param needVersion 要求的版本
         * @returns
         */
        private static compareVersion;
        /**
         * 是否支持数据预处理
         */
        static get isSupport(): boolean;
        /**
         * 通过二进制获取URL对象
         * @param url
         * @param arrayBuffer
         * @returns
         */
        static arrayBufferToURL(url: string, arrayBuffer: ArrayBuffer): any;
        static _arrayBufferToURL(arrayBuffer: ArrayBuffer): string;
        /**
         * 销毁指定URL的二进制内存数据
         * @param url
         */
        static destroy(url: string): void;
    }
    type StatUnit = "M" | "K" | "int";
    type StatColor = "yellow" | "white" | "red";
    type StatMode = "summit" | "average";
    interface StatUIParams {
        title: string;
        value: string;
        color: StatColor;
        units: StatUnit;
        mode: StatMode;
    }
    interface StatToggleUIParams {
        title: string;
        value: string;
        color: StatColor;
    }
    /**
     * @author laya
     */
    interface IStatUI {
        /**
         * 显示性能统计信息。
         * @param	x X轴显示位置。
         * @param	y Y轴显示位置。
         * @views
         */
        show(x?: number, y?: number, views?: Array<StatUIParams>): void;
        showToggle(x?: number, y?: number, views?: Array<StatToggleUIParams>): void;
        /**
         * 隐藏性能统计信息。
         */
        hide(): void;
        /**
         * 每帧更新的调用接口
         */
        update(): void;
        /**
         * 渲染接口
         */
        render(ctx: any, x: number, y: number): void;
    }
    /**
     * <code>Log</code> 类用于在界面内显示日志记录信息。
     * 注意：在加速器内不可使用
     */
    class Log {
        /**@private */
        private static _logdiv;
        /**@private */
        private static _btn;
        /**@private */
        private static _count;
        /**最大打印数量，超过这个数量，则自动清理一次，默认为50次*/
        static maxCount: number;
        /**是否自动滚动到底部，默认为true*/
        static autoScrollToBottom: boolean;
        /**
         * 激活Log系统，使用方法Laya.init(800,600,Laya.Log);
         */
        static enable(): void;
        /**隐藏/显示日志面板*/
        static toggle(): void;
        /**
         * 增加日志内容。
         * @param	value 需要增加的日志内容。
         */
        static print(value: string): void;
        /**
         * 清理日志
         */
        static clear(): void;
    }
    /**
     * <code>Mouse</code> 类用于控制鼠标光标样式。
     */
    class Mouse {
        /**@private */
        private static _style;
        /**@private */
        private static _preCursor;
        /**
         * 设置鼠标样式
         * @param cursorStr
         * 例如auto move no-drop col-resize
         * all-scroll pointer not-allowed row-resize
         * crosshair progress e-resize ne-resize
         * default text n-resize nw-resize
         * help vertical-text s-resize se-resize
         * inherit wait w-resize sw-resize
         */
        static set cursor(cursorStr: string);
        static get cursor(): string;
        /**
         * 隐藏鼠标
         */
        static hide(): void;
        /**
         * 显示鼠标
         */
        static show(): void;
    }
    class ParseJSON {
        static parse(str: string): any;
        private static findIndex;
        private static finCurrObj;
        private static formatVal;
        private static len;
        private static ret;
        private static currStr;
        private static currArr;
        private static cobj;
        /**type为0代表没有找到任何状态，1为当前在寻找key，2为当前在寻找val */
        private static type;
        private static finCurrStr;
        private static parseStart;
    }
    /**
     * <p> <code>Pool</code> 是对象池类，用于对象的存储、重复使用。</p>
     * <p>合理使用对象池，可以有效减少对象创建的开销，避免频繁的垃圾回收，从而优化游戏流畅度。</p>
     */
    class Pool {
        /**@private */
        private static _CLSID;
        /**@private */
        private static POOLSIGN;
        /**@private  对象存放池。*/
        private static _poolDic;
        /**
         * 根据对象类型标识字符，获取对象池。
         * @param sign 对象类型标识字符。
         * @return 对象池。
         */
        static getPoolBySign(sign: string): any[];
        /**
         * 清除对象池的对象。
         * @param sign 对象类型标识字符。
         */
        static clearBySign(sign: string): void;
        /**
         * 将对象放到对应类型标识的对象池中。
         * @param sign 对象类型标识字符。
         * @param item 对象。
         */
        static recover(sign: string, item: any): void;
        /**
         * 根据类名进行回收，如果类有类名才进行回收，没有则不回收
         * @param	instance 类的具体实例
         */
        static recoverByClass(instance: any): void;
        /**
         * 返回类的唯一标识
         */
        private static _getClassSign;
        /**
         * 根据类型创建对象
         * @param	cls 类型
         */
        static createByClass<T>(cls: new () => T): T;
        /**
         * <p>根据传入的对象类型标识字符，获取对象池中此类型标识的一个对象实例。</p>
         * <p>当对象池中无此类型标识的对象时，则根据传入的类型，创建一个新的对象返回。</p>
         * @param sign 对象类型标识字符。
         * @param cls 用于创建该类型对象的类。
         * @return 此类型标识的一个对象。
         */
        static getItemByClass<T>(sign: string, cls: new () => T): T;
        /**
         * <p>根据传入的对象类型标识字符，获取对象池中此类型标识的一个对象实例。</p>
         * <p>当对象池中无此类型标识的对象时，则使用传入的创建此类型对象的函数，新建一个对象返回。</p>
         * @param sign 对象类型标识字符。
         * @param createFun 用于创建该类型对象的方法。
         * @param caller this对象
         * @return 此类型标识的一个对象。
         */
        static getItemByCreateFun(sign: string, createFun: Function, caller?: any): any;
        /**
         * 根据传入的对象类型标识字符，获取对象池中已存储的此类型的一个对象，如果对象池中无此类型的对象，则返回 null 。
         * @param sign 对象类型标识字符。
         * @return 对象池中此类型的一个对象，如果对象池中无此类型的对象，则返回 null 。
         */
        static getItem(sign: string): any;
    }
    /**
     * @private
     * 基于个数的对象缓存管理器
     */
    class PoolCache {
        /**
         * 对象在Pool中的标识
         */
        sign: string;
        /**
         * 允许缓存的最大数量
         */
        maxCount: number;
        /**
         * 获取缓存的对象列表
         * @return
         *
         */
        getCacheList(): any[];
        /**
         * 尝试清理缓存
         * @param force 是否强制清理
         *
         */
        tryDispose(force: boolean): void;
        /**
         * 添加对象缓存管理
         * @param sign 对象在Pool中的标识
         * @param maxCount 允许缓存的最大数量
         *
         */
        static addPoolCacheManager(sign: string, maxCount?: number): void;
    }
    /**
     * @private
     */
    class RunDriver {
        /**
         * 用于改变 WebGL宽高信息。
         */
        static changeWebGLSize: Function;
    }
    /**
     * <code>SingletonList</code> 类用于实现单例队列。
     */
    class SingletonList<T> {
        /**
         * 创建一个新的 <code>SingletonList</code> 实例。
         */
        constructor();
        indexof(element: T): number;
        destroy(): void;
    }
    class FastSinglelist<T> extends SingletonList<T> {
    }
    class SpriteUtils {
        /**
         * @private
         * 根据传入的显示对象 <code>Sprite</code> 和此显示对象上的 两个点，返回此对象上的两个点在舞台坐标系上组成的最小的矩形区域对象。
         * @param	sprite 显示对象 <code>Sprite</code>。
         * @param	x0	点一的 X 轴坐标点。
         * @param	y0	点一的 Y 轴坐标点。
         * @param	x1	点二的 X 轴坐标点。
         * @param	y1	点二的 Y 轴坐标点。
         * @return 两个点在舞台坐标系组成的矩形对象 <code>Rectangle</code>。
         */
        static getGlobalRecByPoints(sprite: Sprite, x0: number, y0: number, x1: number, y1: number): Rectangle;
        /**
         * 计算传入的显示对象 <code>Sprite</code> 的全局坐标系的坐标和缩放值，返回 <code>Rectangle</code> 对象存放计算出的坐标X值、Y值、ScaleX值、ScaleY值。
         * @param	sprite <code>Sprite</code> 对象。
         * @return  矩形对象 <code>Rectangle</code>
         */
        static getGlobalPosAndScale(sprite: Sprite): Rectangle;
        /**
        * 获取指定区域内相对于窗口左上角的transform。
        * @param	coordinateSpace	坐标空间，不能是Stage引用
        * @param	x				相对于coordinateSpace的x坐标
        * @param	y				相对于coordinateSpace的y坐标
        * @return
        */
        static getTransformRelativeToWindow(coordinateSpace: Sprite, x: number, y: number): any;
        /**
         * 使DOM元素使用舞台内的某块区域内。
         * @param	dom				DOM元素引用
         * @param	coordinateSpace	坐标空间，不能是Stage引用
         * @param	x				相对于coordinateSpace的x坐标
         * @param	y				相对于coordinateSpace的y坐标
         * @param	width			宽度
         * @param	height			高度
         */
        static fitDOMElementInArea(dom: any, coordinateSpace: Sprite, x: number, y: number, width: number, height: number): void;
        /**
         * @private
         * 对传入的数组列表，根据子项的属性 Z 值进行重新排序。返回是否已重新排序的 Boolean 值。
         * @param	array 子对象数组。
         * @return	Boolean 值，表示是否已重新排序。
         */
        static updateOrder(array: any[]): boolean;
    }
    /**
     * <p> <code>Stat</code> 是一个性能统计面板，可以实时更新相关的性能参数。</p>
     * <p>参与统计的性能参数如下（所有参数都是每大约1秒进行更新）：<br/>
     * FPS(WebGL)：WebGL 模式下的帧频，也就是每秒显示的帧数，值越高、越稳定，感觉越流畅；<br/>
     * Sprite：统计所有渲染节点（包括容器）数量，它的大小会影响引擎进行节点遍历、数据组织和渲染的效率。其值越小，游戏运行效率越高；<br/>
     * DrawCall：此值是决定性能的重要指标，其值越小，游戏运行效率越高。Canvas模式下表示每大约1秒的图像绘制次数；WebGL模式下表示每大约1秒的渲染提交批次，每次准备数据并通知GPU渲染绘制的过程称为1次DrawCall，在每次DrawCall中除了在通知GPU的渲染上比较耗时之外，切换材质与shader也是非常耗时的操作；<br/>
     * CurMem：Canvas模式下，表示内存占用大小，值越小越好，过高会导致游戏闪退；WebGL模式下，表示内存与显存的占用，值越小越好；<br/>
     * Shader：是 WebGL 模式独有的性能指标，表示每大约1秒 Shader 提交次数，值越小越好；<br/>
     * Canvas：由三个数值组成，只有设置 CacheAs 后才会有值，默认为0/0/0。从左到右数值的意义分别为：每帧重绘的画布数量 / 缓存类型为"normal"类型的画布数量 / 缓存类型为"bitmap"类型的画布数量。</p>
     */
    class Stat {
        static FPSStatUIParams: StatUIParams;
        static NodeStatUIParams: StatUIParams;
        static Sprite3DStatUIParams: StatUIParams;
        static DrawCall: StatUIParams;
        static TriangleFace: StatUIParams;
        static RenderNode: StatUIParams;
        static SkinRenderNode: StatUIParams;
        static ParticleRenderNode: StatUIParams;
        static FrustumCulling: StatUIParams;
        static UniformUpload: StatUIParams;
        static OpaqueDrawCall: StatUIParams;
        static TransDrawCall: StatUIParams;
        static DepthCastDrawCall: StatUIParams;
        static InstanceDrawCall: StatUIParams;
        static CMDDrawCall: StatUIParams;
        static BlitDrawCall: StatUIParams;
        static GPUMemory: StatUIParams;
        static TextureMemeory: StatUIParams;
        static RenderTextureMemory: StatUIParams;
        static BufferMemory: StatUIParams;
        static uploadUniformNum: StatUIParams;
        static AllShow: Array<StatUIParams>;
        static memoryShow: Array<StatUIParams>;
        static renderShow: Array<StatUIParams>;
        static AllToggle: Array<StatToggleUIParams>;
        static RenderModeToggle: Array<StatToggleUIParams>;
        static RenderFuncToggle: Array<StatToggleUIParams>;
        /** 每秒帧数。*/
        static FPS: number;
        /**主舞台 <code>Stage</code> 渲染次数计数。 */
        static loopCount: number;
        /** 精灵渲染使用缓存<code>Sprite</code> 的数量。*/
        static spriteRenderUseCacheCount: number;
        /** 画布 canvas 使用标准渲染的次数。*/
        static canvasNormal: number;
        /** 画布 canvas 使用位图渲染的次数。*/
        static canvasBitmap: number;
        /** 画布 canvas 缓冲区重绘次数。*/
        static canvasReCache: number;
        /** 表示当前使用的是否为慢渲染模式。*/
        static renderSlow: boolean;
        /** 资源管理器所管理资源的累计内存,以字节为单位。*/
        static cpuMemory: number;
        static blitDrawCall: number;
        /** 资源管理器所管理资源的累计内存,以字节为单位。*/
        static gpuMemory: number;
        /**@interanl */
        static bufferMemory: number;
        static _statUI: IStatUI;
        /**
         * 显示性能统计信息。
         * @param	x X轴显示位置。
         * @param	y Y轴显示位置。
         */
        static show(x?: number, y?: number, views?: Array<StatUIParams>): void;
        static showToggle(x?: number, y?: number, views?: Array<StatToggleUIParams>): void;
        private static checkUI;
        /**
         * 隐藏性能统计信息。
         */
        static hide(): void;
        /**
         * @private
         * 性能统计参数计算循环处理函数。
         */
        static loop(): void;
        static updateEngineData(): void;
        /**
         * @private
         * 清零性能统计计算相关的数据。
         */
        static clear(): void;
        static render(ctx: any, x: number, y: number): void;
    }
    /**
     * @private
     * <code>StringKey</code> 类用于存取字符串对应的数字。
     */
    class StringKey {
        private _strsToID;
        private _idToStrs;
        private _length;
        /**
         * 添加一个字符。
         * @param	str 字符，将作为key 存储相应生成的数字。
         * @return 此字符对应的数字。
         */
        add(str: string): number;
        /**
         * 获取指定字符对应的ID。
         * @param	str 字符。
         * @return 此字符对应的ID。
         */
        getID(str: string): number;
        /**
         * 根据指定ID获取对应字符。
         * @param  id ID。
         * @return 此id对应的字符。
         */
        getName(id: number): string;
    }
    /**
     * 整个缓动结束的时候会调度
     * @eventType Event.COMPLETE
     */
    /**
     * 当缓动到达标签时会调度。
     * @eventType Event.LABEL
     */
    /**
     * <code>TimeLine</code> 是一个用来创建时间轴动画的类。
     */
    class TimeLine extends EventDispatcher {
        private _labelDic;
        private _tweenDic;
        private _tweenDataList;
        private _endTweenDataList;
        private _currTime;
        private _lastTime;
        private _startTime;
        /**当前动画数据播放到第几个了*/
        private _index;
        /**为TWEEN创建属于自己的唯一标识，方便管理*/
        private _gidIndex;
        /**保留所有对象第一次注册动画时的状态（根据时间跳转时，需要把对象的恢复，再计算接下来的状态）*/
        private _firstTweenDic;
        /**是否需要排序*/
        private _startTimeSort;
        private _endTimeSort;
        /**是否循环*/
        private _loopKey;
        /** 缩放动画播放的速度。*/
        scale: number;
        private _frameRate;
        private _frameIndex;
        private _total;
        /**
         * 控制一个对象，从当前点移动到目标点。
         * @param	target		要控制的对象。
         * @param	props		要控制对象的属性。
         * @param	duration	对象TWEEN的时间。
         * @param	ease		缓动类型
         * @param	offset		相对于上一个对象，偏移多长时间（单位：毫秒）。
         */
        static to(target: any, props: any, duration: number, ease?: Function, offset?: number): TimeLine;
        /**
         * 从 props 属性，缓动到当前状态。
         * @param	target		target 目标对象(即将更改属性值的对象)
         * @param	props		要控制对象的属性
         * @param	duration	对象TWEEN的时间
         * @param	ease		缓动类型
         * @param	offset		相对于上一个对象，偏移多长时间（单位：毫秒）
         */
        static from(target: any, props: any, duration: number, ease?: Function, offset?: number): TimeLine;
        /**
         * 控制一个对象，从当前点移动到目标点。
         * @param	target		要控制的对象。
         * @param	props		要控制对象的属性。
         * @param	duration	对象TWEEN的时间。
         * @param	ease		缓动类型
         * @param	offset		相对于上一个对象，偏移多长时间（单位：毫秒）。
         */
        to(target: any, props: any, duration: number, ease?: Function, offset?: number): TimeLine;
        /**
         * 从 props 属性，缓动到当前状态。
         * @param	target		target 目标对象(即将更改属性值的对象)
         * @param	props		要控制对象的属性
         * @param	duration	对象TWEEN的时间
         * @param	ease		缓动类型
         * @param	offset		相对于上一个对象，偏移多长时间（单位：毫秒）
         */
        from(target: any, props: any, duration: number, ease?: Function, offset?: number): TimeLine;
        /** @private */
        private _create;
        /**
         * 在时间队列中加入一个标签。
         * @param	label	标签名称。
         * @param	offset	标签相对于上个动画的偏移时间(单位：毫秒)。
         */
        addLabel(label: string, offset: number): TimeLine;
        /**
         * 移除指定的标签
         * @param	label
         */
        removeLabel(label: string): void;
        /**
         * 动画从整个动画的某一时间开始。
         * @param	time(单位：毫秒)。
         */
        gotoTime(time: number): void;
        /**
         * 从指定的标签开始播。
         * @param	Label 标签名。
         */
        gotoLabel(Label: string): void;
        /**
         * 暂停整个动画。
         */
        pause(): void;
        /**
         * 恢复暂停动画的播放。
         */
        resume(): void;
        /**
         * 播放动画。
         * @param	timeOrLabel 开启播放的时间点或标签名。
         * @param	loop 是否循环播放。
         */
        play(timeOrLabel?: any, loop?: boolean): void;
        /**
         * 更新当前动画。
         */
        private _update;
        /**
         * 指定的动画索引处的动画播放完成后，把此动画从列表中删除。
         * @param	index
         */
        private _animComplete;
        /** @private */
        private _complete;
        /**
         * @private
         * 得到帧索引
         */
        get index(): number;
        /**
         * @private
         * 设置帧索引
         */
        set index(value: number);
        /**
         * 得到总帧数。
         */
        get total(): number;
        /**
         * 重置所有对象，复用对象的时候使用。
         */
        reset(): void;
        /**
         * 彻底销毁此对象。
         */
        destroy(): void;
    }
    /**
     * <code>Timer</code> 是时钟管理类。它是一个单例，不要手动实例化此类，应该通过 Laya.timer 访问。
     */
    class Timer {
        /**@private */
        static gSysTimer: Timer;
        /**@private */
        private static _pool;
        /**@private */
        static _mid: number;
        /** 时针缩放。*/
        scale: number;
        /** 当前帧开始的时间。*/
        currTimer: number;
        /** 当前的帧数。*/
        currFrame: number;
        /**@private */
        private _map;
        /**@private */
        private _handlers;
        /**@private */
        private _temp;
        /**@private */
        private _count;
        /**
         * 创建 <code>Timer</code> 类的一个实例。
         */
        constructor(autoActive?: boolean);
        /**两帧之间的时间间隔,单位毫秒。*/
        get delta(): number;
        /** @private */
        private _clearHandlers;
        /** @private */
        private _recoverHandler;
        /**
         * @private
         * get now time data
         * @returns
         */
        _getNowData(): number;
        /** @private */
        private _indexHandler;
        /**
         * 定时执行一次。
         * @param	delay	延迟时间(单位为毫秒)。
         * @param	caller	执行域(this)。
         * @param	method	定时器回调函数。
         * @param	args	回调参数。
         * @param	coverBefore	是否覆盖之前的延迟执行，默认为 true 。
         */
        once(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * 定时重复执行。
         * @param	delay	间隔时间(单位毫秒)。
         * @param	caller	执行域(this)。
         * @param	method	定时器回调函数。
         * @param	args	回调参数。
         * @param	coverBefore	是否覆盖之前的延迟执行，默认为 true 。
         * @param	jumpFrame 时钟是否跳帧。基于时间的循环回调，单位时间间隔内，如能执行多次回调，出于性能考虑，引擎默认只执行一次，设置jumpFrame=true后，则回调会连续执行多次
         */
        loop(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean, jumpFrame?: boolean): void;
        /**
         * 定时执行一次(基于帧率)。
         * @param	delay	延迟几帧(单位为帧)。
         * @param	caller	执行域(this)。
         * @param	method	定时器回调函数。
         * @param	args	回调参数。
         * @param	coverBefore	是否覆盖之前的延迟执行，默认为 true 。
         */
        frameOnce(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /**
         * 定时重复执行(基于帧率)。
         * @param	delay	间隔几帧(单位为帧)。
         * @param	caller	执行域(this)。
         * @param	method	定时器回调函数。
         * @param	args	回调参数。
         * @param	coverBefore	是否覆盖之前的延迟执行，默认为 true 。
         */
        frameLoop(delay: number, caller: any, method: Function, args?: any[], coverBefore?: boolean): void;
        /** 返回统计信息。*/
        toString(): string;
        /**
         * 清理定时器。
         * @param	caller 执行域(this)。
         * @param	method 定时器回调函数。
         */
        clear(caller: any, method: Function): void;
        /**
         * 清理对象身上的所有定时器。
         * @param	caller 执行域(this)。
         */
        clearAll(caller: any): void;
        /** @private */
        private _getHandler;
        /**
         * 延迟执行。
         * @param	caller 执行域(this)。
         * @param	method 定时器回调函数。
         * @param	args 回调参数。
         */
        callLater(caller: any, method: Function, args?: any[]): void;
        /**
         * 立即执行 callLater 。
         * @param	caller 执行域(this)。
         * @param	method 定时器回调函数。
         */
        runCallLater(caller: any, method: Function): void;
        /**
         * 取消执行 callLater 。
         * @param	caller 执行域(this)。
         * @param	method 定时器回调函数。
         */
        clearCallLater(caller: any, method: Function): void;
        /**
         * 立即提前执行定时器，执行之后从队列中删除
         * @param	caller 执行域(this)。
         * @param	method 定时器回调函数。
         */
        runTimer(caller: any, method: Function): void;
        /**
         * 暂停时钟
         */
        pause(): void;
        /**
         * 恢复时钟
         */
        resume(): void;
        destroy(): void;
    }
    /**
     * <code>Tween</code>  是一个缓动类。使用此类能够实现对目标对象属性的渐变。
     */
    class Tween {
        /**@private */
        private static tweenMap;
        /**@private */
        private _complete;
        /**@private */
        private _target;
        /**@private */
        private _ease;
        /**@private */
        private _props;
        /**@private */
        private _duration;
        /**@private */
        private _delay;
        /**@private */
        private _startTimer;
        /**@private */
        private _usedTimer;
        /**@private */
        private _usedPool;
        /**@private */
        private _delayParam;
        /**@private 唯一标识，TimeLintLite用到*/
        gid: number;
        /**更新回调，缓动数值发生变化时，回调变化的值*/
        update: Handler;
        /**重播次数，如果repeat=0，则表示无限循环播放*/
        repeat: number;
        /**当前播放次数*/
        private _count;
        /**
         * 缓动对象的props属性到目标值。
         * @param	target 目标对象(即将更改属性值的对象)。
         * @param	props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
         * @param	duration 花费的时间，单位毫秒。
         * @param	ease 缓动类型，默认为匀速运动。
         * @param	complete 结束回调函数。
         * @param	delay 延迟执行时间。
         * @param	coverBefore 是否覆盖之前的缓动。
         * @param	autoRecover 是否自动回收，默认为true，缓动结束之后自动回收到对象池。
         * @return	返回Tween对象。
         */
        static to(target: any, props: any, duration: number, ease?: Function | null, complete?: Handler | null, delay?: number, coverBefore?: boolean, autoRecover?: boolean): Tween;
        /**
         * 从props属性，缓动到当前状态。
         * @param	target 目标对象(即将更改属性值的对象)。
         * @param	props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
         * @param	duration 花费的时间，单位毫秒。
         * @param	ease 缓动类型，默认为匀速运动。
         * @param	complete 结束回调函数。
         * @param	delay 延迟执行时间。
         * @param	coverBefore 是否覆盖之前的缓动。
         * @param	autoRecover 是否自动回收，默认为true，缓动结束之后自动回收到对象池。
         * @return	返回Tween对象。
         */
        static from(target: any, props: any, duration: number, ease?: Function, complete?: Handler, delay?: number, coverBefore?: boolean, autoRecover?: boolean): Tween;
        /**
         * 缓动对象的props属性到目标值。
         * @param	target 目标对象(即将更改属性值的对象)。
         * @param	props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
         * @param	duration 花费的时间，单位毫秒。
         * @param	ease 缓动类型，默认为匀速运动。
         * @param	complete 结束回调函数。
         * @param	delay 延迟执行时间。
         * @param	coverBefore 是否覆盖之前的缓动。
         * @return	返回Tween对象。
         */
        to(target: any, props: any, duration: number, ease?: Function, complete?: Handler, delay?: number, coverBefore?: boolean): Tween;
        /**
         * 从props属性，缓动到当前状态。
         * @param	target 目标对象(即将更改属性值的对象)。
         * @param	props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
         * @param	duration 花费的时间，单位毫秒。
         * @param	ease 缓动类型，默认为匀速运动。
         * @param	complete 结束回调函数。
         * @param	delay 延迟执行时间。
         * @param	coverBefore 是否覆盖之前的缓动。
         * @return	返回Tween对象。
         */
        from(target: any, props: any, duration: number, ease?: Function | null, complete?: Handler | null, delay?: number, coverBefore?: boolean): Tween;
        private firstStart;
        private _initProps;
        private _beginLoop;
        /**执行缓动**/
        private _doEase;
        /**设置当前执行比例**/
        set progress(v: number);
        /**
         * 立即结束缓动并到终点。
         */
        complete(): void;
        /**
         * 暂停缓动，可以通过resume或restart重新开始。
         */
        pause(): void;
        /**
         * 设置开始时间。
         * @param	startTime 开始时间。
         */
        setStartTime(startTime: number): void;
        /**
         * 清理指定目标对象上的所有缓动。
         * @param	target 目标对象。
         */
        static clearAll(target: any): void;
        /**
         * 清理某个缓动。
         * @param	tween 缓动对象。
         */
        static clear(tween: Tween): void;
        /**@private 同clearAll，废弃掉，尽量别用。*/
        static clearTween(target: any): void;
        /**
         * 停止并清理当前缓动。
         */
        clear(): void;
        /** 回收到对象池。*/
        recover(): void;
        private _remove;
        /**
         * 重新开始暂停的缓动。
         */
        restart(): void;
        /**
         * 恢复暂停的缓动。
         */
        resume(): void;
        private static easeNone;
    }
    /**
     * <code>Utils</code> 是工具类。
     */
    class Utils {
        /**
         * 角度转弧度。
         * @param	angle 角度值。
         * @return	返回弧度值。
         */
        static toRadian(angle: number): number;
        /**
         * 弧度转换为角度。
         * @param	radian 弧度值。
         * @return	返回角度值。
         */
        static toAngle(radian: number): number;
        /**
         * 将传入的 uint 类型颜色值转换为字符串型颜色值。
         * @param color 颜色值。
         * @return 字符串型颜色值。
         */
        static toHexColor(color: number): string;
        static fromStringColor(value: string): number;
        /**获取一个全局唯一ID。*/
        static getGID(): number;
        /**
         * @private
         * 清空source数组，复制array数组的值。
         * @param	source 需要赋值的数组。
         * @param	array 新的数组值。
         * @return 	复制后的数据 source 。
         */
        static copyArray(source: any[], array: any[]): any[];
        /**
         * @private
         * 批量移动点坐标。
         * @param points 坐标列表。
         * @param x x轴偏移量。
         * @param y y轴偏移量。
         */
        static transPointList(points: any[], x: number, y: number): void;
        /**
         * 解析一个字符串，并返回一个整数。和JS原生的parseInt不同：如果str为空或者非数字，原生返回NaN，这里返回0。
         * @param	str		要被解析的字符串。
         * @param	radix	表示要解析的数字的基数。默认值为0，表示10进制，其他值介于 2 ~ 36 之间。如果它以 “0x” 或 “0X” 开头，将以 16 为基数。如果该参数不在上述范围内，则此方法返回 0。
         * @return	返回解析后的数字。
         */
        static parseInt(str: string, radix?: number): number;
        /**
         * 获得路径中的文件名（包含扩展名）
         */
        static getBaseName(path: string): string;
        /**
         * 获取文件名的扩展名，并转换为小写字母。例如"1.abc"将返回abc。
         */
        static getFileExtension(path: string): string;
        /**
         * 更改文件名的扩展名。
         */
        static replaceFileExtension(path: string, newExt: string, excludeDot?: boolean): string;
    }
    /**
     * @private
     * TODO:
     */
    class VectorGraphManager {
        static instance: VectorGraphManager;
        useDic: any;
        shapeDic: any;
        shapeLineDic: any;
        private _id;
        private _checkKey;
        private _freeIdArray;
        constructor();
        static getInstance(): VectorGraphManager;
        /**
         * 得到个空闲的ID
         * @return
         */
        getId(): number;
        /**
         * 添加一个图形到列表中
         * @param	id
         * @param	shape
         */
        addShape(id: number, shape: any): void;
        /**
         * 添加一个线图形到列表中
         * @param	id
         * @param	Line
         */
        addLine(id: number, Line: any): void;
        /**
         * 检测一个对象是否在使用中
         * @param	id
         */
        getShape(id: number): void;
        /**
         * 删除一个图形对象
         * @param	id
         */
        deleteShape(id: number): void;
        /**
         * 得到缓存列表
         * @return
         */
        getCacheList(): any[];
        /**
         * 开始清理状态，准备销毁
         */
        startDispose(key: boolean): void;
        /**
         * 确认销毁
         */
        endDispose(): void;
    }
    /**
     * 封装弱引用WeakMap
     * 如果支持WeakMap，则使用WeakMap，如果不支持，则用Object代替
     * 注意：如果采用Object，为了防止内存泄漏，则采用定时清理缓存策略
     *
     * 这里的设计是错误的，为了兼容，先不删掉这个类，直接采用Object
     */
    class WeakObject {
        /**是否支持WeakMap*/
        static supportWeakMap: boolean;
        /**如果不支持WeakMap，则多少时间清理一次缓存，默认10分钟清理一次*/
        static delInterval: number;
        /**全局WeakObject单例*/
        static I: WeakObject;
        /**@private */
        private static _maps;
        /**清理缓存，回收内存*/
        static clearCache(): void;
        constructor();
        /**
         * 设置缓存
         * @param	key kye对象，可被回收
         * @param	value object对象，可被回收
         */
        set(key: any, value: any): void;
        /**
         * 获取缓存
         * @param	key kye对象，可被回收
         */
        get(key: any): any;
        /**
         * 删除缓存
         */
        del(key: any): void;
        /**
         * 是否有缓存
         */
        has(key: any): boolean;
    }
    /**
     * @private
     */
    class WordText {
        text: string;
        width: number;
        pageChars: any[];
        pagecharsCtx: Context;
        scalex: number;
        scaley: number;
        _nativeObj: any;
        _splitRender: boolean;
        constructor();
        setText(txt: string): void;
        toString(): string;
        get length(): number;
        /**
         * 自己主动清理缓存，需要把关联的贴图删掉
         * 不做也可以，textrender会自动清理不用的
         * TODO 重用
         */
        cleanCache(): void;
        get splitRender(): boolean;
        set splitRender(value: boolean);
    }
    class BlendMode {
        static activeBlendFunction: Function;
        static NORMAL: string;
        static MASK: string;
        static LIGHTER: string;
        static fns: any[];
        static targetFns: any[];
        static BlendNormal(): void;
        static BlendAdd(): void;
        static BlendMultiply(): void;
        static BlendScreen(): void;
        static BlendOverlay(): void;
        static BlendLight(): void;
        static BlendNormalTarget(): void;
        static BlendAddTarget(): void;
        static BlendMultiplyTarget(): void;
        static BlendScreenTarget(): void;
        static BlendOverlayTarget(): void;
        static BlendLightTarget(): void;
        static BlendMask(): void;
        static BlendDestinationOut(): void;
        static BlendSourceAlpha(): void;
    }
    class DrawStyle {
        static DEFAULT: DrawStyle;
        _color: ColorUtils;
        static create(value: any): DrawStyle;
        constructor(value: any);
        setValue(value: any): void;
        reset(): void;
        toInt(): number;
        equal(value: any): boolean;
        toColorStr(): string;
    }
    class NativeWebGLCacheAsNormalCanvas {
        _nativeObj: any;
        _context: any;
        constructor(ctx: any, sp: any);
        startRec(): void;
        endRec(): void;
        isCacheValid(): boolean;
        isTextNeedRestore(): boolean;
        get context(): any;
    }
    class Path {
        paths: any[];
        private _curPath;
        constructor();
        beginPath(convex: boolean): void;
        closePath(): void;
        newPath(): void;
        addPoint(pointX: number, pointY: number): void;
        push(points: any[], convex: boolean): void;
        reset(): void;
    }
    interface ISaveData {
        isSaveMark(): boolean;
        restore(context: Context): void;
    }
    class SaveBase implements ISaveData {
        static TYPE_ALPHA: number;
        static TYPE_FILESTYLE: number;
        static TYPE_FONT: number;
        static TYPE_LINEWIDTH: number;
        static TYPE_STROKESTYLE: number;
        static TYPE_MARK: number;
        static TYPE_TRANSFORM: number;
        static TYPE_TRANSLATE: number;
        static TYPE_ENABLEMERGE: number;
        static TYPE_TEXTBASELINE: number;
        static TYPE_TEXTALIGN: number;
        static TYPE_GLOBALCOMPOSITEOPERATION: number;
        static TYPE_CLIPRECT: number;
        static TYPE_CLIPRECT_STENCIL: number;
        static TYPE_IBVB: number;
        static TYPE_SHADER: number;
        static TYPE_FILTERS: number;
        static TYPE_FILTERS_TYPE: number;
        static TYPE_COLORFILTER: number;
        private static POOL;
        private static _namemap;
        private _valueName;
        private _value;
        private _dataObj;
        private _newSubmit;
        constructor();
        isSaveMark(): boolean;
        restore(context: Context): void;
        static save(context: Context, type: number, dataObj: any, newSubmit: boolean): void;
    }
    class SaveClipRect implements ISaveData {
        private static POOL;
        _globalClipMatrix: Matrix;
        _clipInfoID: number;
        _clipRect: Rectangle;
        incache: boolean;
        isSaveMark(): boolean;
        restore(context: Context): void;
        static save(context: Context): void;
    }
    class SaveMark implements ISaveData {
        private static POOL;
        constructor();
        isSaveMark(): boolean;
        restore(context: Context): void;
        static Create(context: Context): SaveMark;
    }
    class SaveTransform implements ISaveData {
        private static POOL;
        constructor();
        isSaveMark(): boolean;
        restore(context: Context): void;
        static save(context: Context): void;
    }
    class SaveTranslate implements ISaveData {
        private static POOL;
        isSaveMark(): boolean;
        restore(context: Context): void;
        static save(context: Context): void;
    }
    /**
     * 对象 cacheas normal的时候，本质上只是想把submit缓存起来，以后直接执行
     * 为了避免各种各样的麻烦，这里采用复制相应部分的submit的方法。执行环境还是在原来的context中
     * 否则包括clip等都非常难以处理
     */
    class WebGLCacheAsNormalCanvas {
        submitStartPos: number;
        submitEndPos: number;
        context: Context;
        touches: any[];
        submits: any[];
        sprite: Sprite | null;
        private _pathMesh;
        private _triangleMesh;
        meshlist: any[];
        private _oldMesh;
        private _oldPathMesh;
        private _oldTriMesh;
        private _oldMeshList;
        private cachedClipInfo;
        private oldTx;
        private oldTy;
        private static matI;
        invMat: Matrix;
        constructor(ctx: Context, sp: Sprite);
        startRec(): void;
        endRec(): void;
        /**
         * 当前缓存是否还有效。例如clip变了就失效了，因为clip太难自动处理
         * @return
         */
        isCacheValid(): boolean;
        isTextNeedRestore(): boolean;
        flushsubmit(): void;
        releaseMem(): void;
    }
    /**
     * ...
     * @author ...
     */
    class BaseShader extends Resource {
        static activeShader: BaseShader | null;
        static bindShader: BaseShader;
        constructor();
    }
    class Shader2D {
        /**
         * primitive Mesh Descript
         */
        static readonly primitiveAttribute: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        /**
         * TextureSV Mesh Descript
         */
        static readonly textureAttribute: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        /**
         * init 2D internal Shader
         */
        static __init__(): void;
    }
    class ShaderDefines2D {
        static UNIFORM_CLIPMATDIR: number;
        static UNIFORM_CLIPMATPOS: number;
        static UNIFORM_MMAT2: number;
        static UNIFORM_SIZE: number;
        static UNIFORM_CLIPOFF: number;
        static UNIFORM_MVPMatrix: number;
        static UNIFORM_SPRITETEXTURE: number;
        static UNIFORM_STRENGTH_SIG2_2SIG2_GAUSS1: number;
        static UNIFORM_BLURINFO: number;
        static UNIFORM_COLORALPHA: number;
        static UNIFORM_COLORMAT: number;
        static UNIFORM_COLOR: number;
        static UNIFORM_BLURINFO1: number;
        static UNIFORM_BLURINFO2: number;
        static UNIFORM_COLORADD: number;
        static UNIFORM_TEXRANGE: number;
        static __init__(): void;
        static initSprite2DCommandEncoder(): void;
    }
    class SkinMeshBuffer {
        ib: IndexBuffer2D;
        vb: VertexBuffer2D;
        static instance: SkinMeshBuffer;
        constructor();
        static getInstance(): SkinMeshBuffer;
        addSkinMesh(skinMesh: any): void;
        reset(): void;
    }
    class PrimitiveSV extends Value2D {
        constructor();
    }
    class TextureSV extends Value2D {
        strength: number;
        private _blurInfo;
        get blurInfo(): Vector2;
        set blurInfo(value: Vector2);
        private _u_blurInfo1;
        get u_blurInfo1(): Vector4;
        set u_blurInfo1(value: Vector4);
        private _u_blurInfo2;
        get u_blurInfo2(): Vector4;
        set u_blurInfo2(value: Vector4);
        private _u_TexRange;
        get u_TexRange(): Vector4;
        set u_TexRange(value: Vector4);
        private _colorMat;
        get colorMat(): Matrix4x4;
        set colorMat(value: Matrix4x4);
        private _colorAlpha;
        get colorAlpha(): Vector4;
        set colorAlpha(value: Vector4);
        private _strength_sig2_2sig2_gauss1;
        get strength_sig2_2sig2_gauss1(): Vector4;
        set strength_sig2_2sig2_gauss1(value: Vector4);
        constructor();
        /**
         * @override
         */
        clear(): void;
    }
    enum RenderSpriteData {
        Zero = 0,
        Texture2D = 1,
        Primitive = 2
    }
    class Value2D {
        static globalShaderData: ShaderData;
        protected static _cache: any[];
        protected static _typeClass: any;
        static _initone(type: number, classT: any): void;
        static TEMPMAT4_ARRAY: any[];
        static _compileDefine: DefineDatas;
        /**
         * 对象池概念
         * @param mainType
         * @returns
         */
        static create(mainType: RenderSpriteData): Value2D;
        defines: ShaderData;
        _defaultShader: Shader3D;
        alpha: number;
        ALPHA: number;
        mainID: RenderSpriteData;
        ref: number;
        private _inClassCache;
        private _cacheID;
        get size(): Vector2;
        filters: any[];
        get u_MvpMatrix(): Matrix4x4;
        texture: any;
        private _textureHost;
        get textureHost(): Texture | RenderTexture2D | TextTexture;
        set textureHost(value: Texture | RenderTexture2D | TextTexture);
        _color: Vector4;
        set color(value: Vector4);
        get color(): Vector4;
        _colorAdd: Vector4;
        set colorAdd(value: Vector4);
        get colorAdd(): Vector4;
        private _clipMatDir;
        set clipMatDir(value: Vector4);
        get clipMatDir(): Vector4;
        private _clipMatpos;
        set clipMatPos(value: Vector2);
        get clipMatPos(): Vector2;
        _clipOff: Vector2;
        set clipOff(value: Vector2);
        get clipOff(): Vector2;
        constructor(mainID: RenderSpriteData);
        /**
         * 组织Define宏数据
         */
        updateShaderData(): void;
        upload(material?: Material): void;
        setFilters(value: any[]): void;
        clear(): void;
        release(): void;
    }
    class BasePoly {
        private static tempData;
        private static vec2;
        private static tempIndexs;
        private static _checkMinAngle;
        /**
         * 构造线的三角形数据。根据一个位置数组生成vb和ib
         * @param	p
         * @param	indices
         * @param	lineWidth
         * @param	indexBase				顶点开始的值，ib中的索引会加上这个
         * @param	outVertex
         * @return
         */
        static createLine2(p: any[], indices: any[], lineWidth: number, indexBase: number, outVertex: any[], loop: boolean): any[];
        private static _setMiddleVertexs;
        static getNormal(x1: number, y1: number, x2: number, y2: number, w: number, out?: Vector2): Vector2;
        /**
         * 相邻的两段线，边界会相交，这些交点可以作为三角形的顶点。有两种可选，一种是采用左左,右右交点，一种是采用 左右，左右交点。当两段线夹角很小的时候，如果采用
         * 左左，右右会产生很长很长的交点，这时候就要采用左右左右交点，相当于把尖角截断。
         * 当采用左左右右交点的时候，直接用切线的垂线。采用左右左右的时候，用切线
         * 切线直接采用两个方向的平均值。不能用3-1的方式，那样垂线和下一段可能都在同一方向（例如都在右方）
         * 注意把重合的点去掉
         * @param	path
         * @param	color
         * @param	width
         * @param	loop
         * @param	outvb
         * @param	vbstride  顶点占用几个float,(bytelength/4)
         * @param	outib
         * test:
         * 横线
         * [100,100, 400,100]
         * 竖线
         * [100,100, 100,400]
         * 直角
         * [100,100, 400,100, 400,400]
         * 重合点
         * [100,100,100,100,400,100]
         * 同一直线上的点
         * [100,100,100,200,100,3000]
         * 像老式电视的左边不封闭的图形
         * [98,176,  163,178, 95,66, 175,177, 198,178, 252,56, 209,178,  248,175,  248,266,  209,266, 227,277, 203,280, 188,271,  150,271, 140,283, 122,283, 131,268, 99,268]
         *
         */
        static createLineTriangle(path: any[], color: number, width: number, loop: boolean, outvb: Float32Array, vbstride: number, outib: Uint16Array): void;
    }
    class Earcut {
        static earcut(data: any, holeIndices: any, dim: any): any;
        static linkedList(data: any, start: any, end: any, dim: any, clockwise: any): any;
        static filterPoints(start: any, end: any): any;
        static earcutLinked(ear: any, triangles: any, dim: any, minX: any, minY: any, invSize: any, pass?: any): any;
        static isEar(ear: any): any;
        static isEarHashed(ear: any, minX: any, minY: any, invSize: any): boolean;
        static cureLocalIntersections(start: any, triangles: any, dim: any): any;
        static splitEarcut(start: any, triangles: any, dim: any, minX: any, minY: any, invSize: any): void;
        static eliminateHoles(data: any, holeIndices: any, outerNode: any, dim: any): any;
        static compareX(a: any, b: any): any;
        static eliminateHole(hole: any, outerNode: any): void;
        static findHoleBridge(hole: any, outerNode: any): any;
        static indexCurve(start: any, minX: any, minY: any, invSize: any): void;
        static sortLinked(list: any): any;
        static zOrder(x: any, y: any, minX: any, minY: any, invSize: any): any;
        static getLeftmost(start: any): any;
        static pointInTriangle(ax: any, ay: any, bx: any, by: any, cx: any, cy: any, px: any, py: any): boolean;
        static isValidDiagonal(a: any, b: any): boolean;
        static area(p: any, q: any, r: any): any;
        static equals(p1: any, p2: any): boolean;
        static intersects(p1: any, q1: any, p2: any, q2: any): boolean;
        static intersectsPolygon(a: any, b: any): boolean;
        static locallyInside(a: any, b: any): boolean;
        static middleInside(a: any, b: any): boolean;
        static splitPolygon(a: any, b: any): any;
        static insertNode(i: any, x: any, y: any, last: any): any;
        static removeNode(p: any): void;
        static signedArea(data: any, start: any, end: any, dim: any): any;
    }
    class EarcutNode {
        i: any;
        x: any;
        y: any;
        prev: any;
        next: any;
        z: any;
        prevZ: any;
        nextZ: any;
        steiner: any;
        constructor(i: any, x: any, y: any);
    }
    interface ISubmit {
        renderSubmit(): number;
        getRenderType(): number;
        releaseRender(): void;
    }
    class Submit extends SubmitBase {
        protected static _poolSize: number;
        protected static POOL: Submit[];
        material: Material;
        constructor(renderType?: number);
        /**
         * @override
         */
        renderSubmit(): number;
        /**
         * @override
         */
        releaseRender(): void;
        /**
         * create方法只传对submit设置的值
         */
        static create(context: Context, mesh: Mesh2D, sv: Value2D): Submit;
        /**
         * 创建一个矢量submit
         * @param	ctx
         * @param	mesh
         * @param	numEle		对应drawElement的第二个参数:count
         * @param	offset		drawElement的时候的ib的偏移。
         * @param	sv			Value2D
         * @return
         */
        static createShape(ctx: Context, mesh: Mesh2D, numEle: number, sv: Value2D): Submit;
    }
    class SubmitBase implements ISubmit {
        static TYPE_2D: number;
        static TYPE_CANVAS: number;
        static TYPE_CMDSETRT: number;
        static TYPE_CUSTOM: number;
        static TYPE_BLURRT: number;
        static TYPE_CMDDESTORYPRERT: number;
        static TYPE_DISABLESTENCIL: number;
        static TYPE_OTHERIBVB: number;
        static TYPE_PRIMITIVE: number;
        static TYPE_RT: number;
        static TYPE_BLUR_RT: number;
        static TYPE_TARGET: number;
        static TYPE_CHANGE_VALUE: number;
        static TYPE_SHAPE: number;
        static TYPE_TEXTURE: number;
        static TYPE_FILLTEXTURE: number;
        static KEY_ONCE: number;
        static KEY_FILLRECT: number;
        static KEY_DRAWTEXTURE: number;
        static KEY_VG: number;
        static KEY_TRIANGLES: number;
        static RENDERBASE: SubmitBase;
        static ID: number;
        static preRender: ISubmit;
        clipInfoID: number;
        protected _id: number;
        shaderValue: Value2D;
        static __init__(): void;
        constructor(renderType?: number);
        getID(): number;
        getRenderType(): number;
        toString(): string;
        renderSubmit(): number;
        releaseRender(): void;
    }
    /**
     * cache as normal 模式下的生成的canvas的渲染。
     */
    class SubmitCanvas extends SubmitBase {
        canv: Context;
        static POOL: SubmitCanvas[];
        static create(canvas: any, alpha: number, filters: any[]): SubmitCanvas;
        constructor();
        /**
         * @override
         */
        renderSubmit(): number;
        /**
         * @override
         */
        releaseRender(): void;
        /**
         * @override
         */
        getRenderType(): number;
    }
    class SubmitCMD implements ISubmit {
        static POOL: SubmitCMD[];
        fun: Function;
        args: any[];
        constructor();
        renderSubmit(): number;
        getRenderType(): number;
        releaseRender(): void;
        static create(args: any[], fun: Function, thisobj: any): SubmitCMD;
    }
    /**
         * ...
         * @author xie
         */
    class SubmitKey {
        blendShader: number;
        submitType: number;
        other: number;
        constructor();
        clear(): void;
        copyFrom(src: SubmitKey): void;
        copyFrom2(src: SubmitKey, submitType: number, other: number): void;
        equal3_2(next: SubmitKey, submitType: number, other: number): boolean;
        equal4_2(next: SubmitKey, submitType: number, other: number): boolean;
        equal_3(next: SubmitKey): boolean;
        equal(next: SubmitKey): boolean;
    }
    class SubmitTarget implements ISubmit {
        shaderValue: Value2D;
        blendType: number;
        srcRT: RenderTexture2D;
        constructor();
        static POOL: SubmitTarget[];
        renderSubmit(): number;
        blend(): void;
        getRenderType(): number;
        releaseRender(): void;
        static create(context: Context, mesh: Mesh2D, sv: Value2D, rt: RenderTexture2D): SubmitTarget;
    }
    class SubmitTexture extends SubmitBase {
        private static _poolSize;
        private static POOL;
        material: Material;
        constructor(renderType?: number);
        /**
         * @override
         */
        releaseRender(): void;
        renderSubmit(): number;
        static create(context: Context, mesh: Mesh2D, sv: Value2D): SubmitTexture;
    }
    /**
     * 阿拉伯文的转码。把unicode的阿拉伯文字母编码转成他们的老的能描述不同写法的编码。
     *  这个是从GitHub上 Javascript-Arabic-Reshaper 项目转来的
     * https://github.com/louy/Javascript-Arabic-Reshaper/blob/master/src/index.js
     */
    /**
         * Javascript Arabic Reshaper by Louy Alakkad
         * https://github.com/louy/Javascript-Arabic-Reshaper
         * Based on (http://git.io/vsnAd)
         */
    class ArabicReshaper {
        private static charsMap;
        private static combCharsMap;
        private static transChars;
        characterMapContains(c: number): boolean;
        getCharRep(c: number): boolean;
        getCombCharRep(c1: number, c2: number): boolean;
        isTransparent(c: number): boolean;
        getOriginalCharsFromCode(code: number): string;
        /**
         * 转换函数。从normal转到presentB
         * 这个返回的字符串可以直接按照从左到右的顺序渲染。
         * 例如
         * graphics.fillText(convertArabic('سلام'),....)
         *
        */
        convertArabic(normal: any): string;
        convertArabicBack(apfb: any): string;
    }
    class AtlasGrid {
        atlasID: number;
        private _width;
        private _height;
        private _texCount;
        private _rowInfo;
        private _cells;
        _used: number;
        constructor(width?: number, height?: number, id?: number);
        addRect(type: number, width: number, height: number, pt: Point): boolean;
        private _release;
        private _init;
        private _get;
        private _fill;
        private _check;
        private _clear;
    }
    class CharRender_Canvas extends ICharRender {
        private static canvas;
        private ctx;
        private lastScaleX;
        private lastScaleY;
        private maxTexW;
        private maxTexH;
        private scaleFontSize;
        private showDbgInfo;
        private supportImageData;
        constructor(maxw: number, maxh: number, scalefont?: boolean, useImageData?: boolean, showdbg?: boolean);
        /**
         * @override
         */
        get canvasWidth(): number;
        /**
         * @override
         */
        set canvasWidth(w: number);
        /**
         *
         * @param font
         * @param str
         * @override
         */
        getWidth(font: string, str: string): number;
        /**
         *
         * @param sx
         * @param sy
         * @override
         */
        scale(sx: number, sy: number): void;
        /**
         *TODO stroke
         * @param	char
         * @param	font
         * @param	cri  修改里面的width。
         * @return
         * @override
         */
        getCharBmp(char: string, font: string, lineWidth: number, colStr: string, strokeColStr: string, cri: CharRenderInfo, margin_left: number, margin_top: number, margin_right: number, margin_bottom: number, rect?: any[] | null): ImageData | null;
        getCharCanvas(char: string, font: string, lineWidth: number, colStr: string, strokeColStr: string, cri: CharRenderInfo, margin_left: number, margin_top: number, margin_right: number, margin_bottom: number): ImageData;
    }
    /**
     * TODO如果占用内存较大,这个结构有很多成员可以临时计算
     */
    class CharRenderInfo {
        char: string;
        tex: any;
        deleted: boolean;
        uv: any[];
        pos: number;
        width: number;
        height: number;
        bmpWidth: number;
        bmpHeight: number;
        orix: number;
        oriy: number;
        touchTick: number;
        isSpace: boolean;
        touch(): void;
    }
    /**
     * ...
     * @author laoxie
     */
    class CharSubmitCache {
        private static __posPool;
        private static __nPosPool;
        private _data;
        private _ndata;
        private _tex;
        private _imgId;
        private _clipid;
        private _clipMatrix;
        constructor();
        clear(): void;
        destroy(): void;
        add(ctx: Context, tex: Texture, imgid: number, pos: any[], uv: ArrayLike<number>, color: number): void;
        getPos(): any[];
        enable(value: boolean, ctx: Context): void;
        submit(ctx: Context): void;
    }
    class ICharRender {
        fontsz: number;
        getWidth(font: string, str: string): number;
        scale(sx: number, sy: number): void;
        get canvasWidth(): number;
        set canvasWidth(w: number);
        /**
         *TODO stroke
         * @param	char
         * @param	font
         * @param	size  返回宽高
         * @return
         */
        getCharBmp(char: string, font: string, lineWidth: number, colStr: string, strokeColStr: string, size: CharRenderInfo, margin_left: number, margin_top: number, margin_right: number, margin_bottom: number, rect?: any[] | null): ImageData | null;
    }
    /**
     *  文字贴图的大图集。
     */
    class TextAtlas {
        texWidth: number;
        texHeight: number;
        private atlasgrid;
        texture: TextTexture | null;
        charMaps: any;
        static atlasGridW: number;
        constructor();
        setProtecteDist(d: number): void;
        /**
         * 如果返回null，则表示无法加入了
         * 分配的时候优先选择最接近自己高度的节点
         * @param	w
         * @param	h
         * @return
         */
        getAEmpty(w: number, h: number, pt: Point): boolean;
        /**
         * 大图集格子单元的占用率，老的也算上了。只是表示这个大图集还能插入多少东西。
         */
        get usedRate(): number;
        destroy(): void;
        printDebugInfo(): void;
    }
    class TextRender {
        static useOldCharBook: boolean;
        static atlasWidth: number;
        static noAtlas: boolean;
        static forceSplitRender: boolean;
        static forceWholeRender: boolean;
        static scaleFontWithCtx: boolean;
        static maxFontScale: number;
        static standardFontSize: number;
        static destroyAtlasDt: number;
        static checkCleanTextureDt: number;
        static destroyUnusedTextureDt: number;
        static cleanMem: number;
        static isWan1Wan: boolean;
        static showLog: boolean;
        static debugUV: boolean;
        /**
         * fontSizeInfo
         * 记录每种字体的像素的大小。标准是32px的字体。由4个byte组成，分别表示[xdist,ydist,w,h]。
         * xdist,ydist 是像素起点到排版原点的距离，都是正的，表示实际数据往左和上偏多少，如果实际往右和下偏，则算作0，毕竟这个只是一个大概
         * 例如 [Arial]=0x00002020, 表示宽高都是32
         */
        private fontSizeInfo;
        static atlasWidth2: number;
        private charRender;
        private static tmpRI;
        private static pixelBBX;
        private mapFont;
        private fontID;
        private fontScaleX;
        private fontScaleY;
        private _curStrPos;
        static textRenderInst: TextRender;
        textAtlases: TextAtlas[];
        private isoTextures;
        private bmpData32;
        private static imgdtRect;
        private lastFont;
        private fontSizeW;
        private fontSizeH;
        private fontSizeOffX;
        private fontSizeOffY;
        private renderPerChar;
        private tmpAtlasPos;
        private textureMem;
        private fontStr;
        static simClean: boolean;
        constructor();
        /**
         * 设置当前字体，获得字体的大小信息。
         * @param	font
         */
        setFont(font: FontInfo): void;
        /**
         * 从string中取出一个完整的char，例如emoji的话要多个
         * 会修改 _curStrPos
         * TODO 由于各种文字中的组合写法，这个需要能扩展，以便支持泰文等
         * @param	str
         * @param	start	开始位置
         */
        getNextChar(str: string): string | null;
        filltext(ctx: Context, data: string | WordText, x: number, y: number, fontStr: string, color: string, strokeColor: string, lineWidth: number, textAlign: string): void;
        _fast_filltext(ctx: Context, data: string | WordText | null, x: number, y: number, font: FontInfo, color: string, strokeColor: string | null, lineWidth: number, textAlign: number): void;
        /**
         * 画出重新按照贴图顺序分组的文字。
         * @param	samePagesData
         * @param  startx 保存的数据是相对位置，所以需要加上这个偏移。用相对位置更灵活一些。
         * @param y {int} 因为这个只能画在一行上所以没有必要保存y。所以这里再把y传进来
         */
        protected _drawResortedWords(ctx: Context, startx: number, starty: number, samePagesData: any[]): void;
        /**
         * 检查 txts数组中有没有被释放的资源
         * @param	txts {{ri:CharRenderInfo,...}[][]}
         * @param	startid
         * @return
         */
        hasFreedText(txts: any[]): boolean;
        getCharRenderInfo(str: string, font: FontInfo, color: string, strokeColor: string | null, lineWidth: number, isoTexture?: boolean): CharRenderInfo;
        /**
         * 添加数据到大图集
         * @param	w
         * @param	h
         * @return
         */
        addBmpData(data: ImageData, ri: CharRenderInfo): TextAtlas;
        /**
         * 清理利用率低的大图集
         */
        GC(): void;
        /**
         * 尝试清理大图集
         */
        cleanAtlases(): void;
        getCharBmp(c: string): any;
        /**
         * 检查当前线是否存在数据
         * @param	data
         * @param	l
         * @param	sx
         * @param	ex
         * @return
         */
        private checkBmpLine;
        /**
         * 根据bmp数据和当前的包围盒，更新包围盒
         * 由于选择的文字是连续的，所以可以用二分法
         * @param	data
         * @param	curbbx 	[l,t,r,b]
         * @param   onlyH 不检查左右
         */
        private updateBbx;
        getFontSizeInfo(font: string): number;
        printDbgInfo(): void;
        showAtlas(n: number, bgcolor: string, x: number, y: number, w: number, h: number): Sprite;
        filltext_native(ctx: Context, data: string | WordText, x: number, y: number, fontStr: string, color: string, strokeColor: string, lineWidth: number, textAlign: string): void;
    }
    class TextTexture extends Resource {
        private static pool;
        private static poolLen;
        private static cleanTm;
        private _render2DContext;
        genID: number;
        bitmap: any;
        curUsedCovRate: number;
        curUsedCovRateAtlas: number;
        lastTouchTm: number;
        ri: CharRenderInfo;
        get gammaCorrection(): number;
        constructor(textureW: number, textureH: number);
        recreateResource(): void;
        /**
         *
         * @param	data
         * @param	x			拷贝位置。
         * @param	y
         * @param  uv
         * @return uv数组  如果uv不为空就返回传入的uv，否则new一个数组
         */
        addChar(data: ImageData, x: number, y: number, uv?: any[]): any[];
        /**
         * 玩一玩不支持 getImageData
         * @param	canv
         * @param	x
         * @param	y
         */
        addCharCanvas(canv: any, x: number, y: number, uv?: any[]): any[];
        /**
         * 填充白色。调试用。
         */
        fillWhite(): void;
        discard(): void;
        static getTextTexture(w: number, h: number): TextTexture;
        /**
         * @override
         */
        protected _disposeResource(): void;
        /**
         * 定期清理
         * 为了简单，只有发生 getAPage 或者 discardPage的时候才检测是否需要清理
         */
        static clean(): void;
        touchRect(ri: CharRenderInfo, curloop: number): void;
        get texture(): any;
        drawOnScreen(x: number, y: number): void;
    }
    class Buffer2D {
        static FLOAT32: number;
        static SHORT: number;
        protected _maxsize: number;
        _upload: boolean;
        protected _uploadSize: number;
        protected _bufferSize: number;
        protected _u8Array: Uint8Array;
        _floatArray32: Float32Array;
        _uint32Array: Uint32Array;
        _uint16Array: Uint16Array;
        private constBuffer;
        get bufferLength(): number;
        set byteLength(value: number);
        setByteLength(value: number): void;
        /**
         * 在当前的基础上需要多大空间，单位是byte
         * @param	sz
         * @return  增加大小之前的写位置。单位是byte
         */
        needSize(sz: number): number;
        constructor(buffer: Buffer);
        getFloat32Array(): Float32Array;
        protected _bufferData(): void;
        protected _bufferSubData(offset?: number, dataStart?: number, dataLength?: number): void;
        /**
         * buffer重新分配了，继承类根据需要做相应的处理。
         */
        protected _checkArrayUse(): void;
        _bind_upload(): boolean;
        _bind_subUpload(offset?: number, dataStart?: number, dataLength?: number): boolean;
        /**
         * 重新分配buffer大小，如果nsz比原来的小则什么都不做。
         * @param	nsz		buffer大小，单位是byte。
         * @param	copy	是否拷贝原来的buffer的数据。
         * @return
         */
        _resizeBuffer(nsz: number, copy: boolean): Buffer2D;
        append(data: any): void;
        /**
         * 附加Uint16Array的数据。数据长度是len。byte的话要*2
         * @param	data
         * @param	len
         */
        appendU16Array(data: Uint16Array, len: number): void;
        getBuffer(): ArrayBuffer;
        setNeedUpload(): void;
        subUpload(offset?: number, dataStart?: number, dataLength?: number): boolean;
        _disposeResource(): void;
        /**
         * 清理数据。保留ArrayBuffer
         */
        clear(): void;
    }
    /**
     * <code>BufferState</code> 类用于实现渲染所需的Buffer状态集合。
     */
    class BufferState {
        static _curBindedBufferState: BufferState;
        /**@private [只读]*/
        protected _nativeVertexArrayObject: IRenderVertexState;
        /**
         * 创建一个 <code>BufferState</code> 实例。
         */
        constructor();
        protected applyVertexBuffers(): void;
        protected applyIndexBuffers(): void;
        applyState(vertexBuffers: VertexBuffer[], indexBuffer: IndexBuffer | null): void;
        /**
         * @private
         */
        bind(): void;
        /**
         * @private
         */
        unBind(): void;
        isbind(): boolean;
        static clearbindBufferState(): void;
        /**
         * @private
         */
        destroy(): void;
    }
    class IncludeFile {
        static splitToWords(str: string, block: ShaderNode): any[];
        script: string;
        codes: any;
        funs: any;
        curUseID: number;
        funnames: string;
        constructor(txt: string);
        getWith(name?: string | null): string;
        getFunsScript(funsdef: string): string;
    }
    class IndexBuffer2D extends IndexBuffer {
        static create: Function;
        protected _uint16Array: Uint16Array;
        buffer2D: Buffer2D;
        constructor(bufferUsage?: number);
        /**
         * @override
         */
        /**
         * @inheritDoc
         * @override
         */
        _bindForVAO(): void;
        destory(): void;
        disposeResource(): void;
    }
    class MatirxArray {
        /**
         * 4*4矩阵数组相乘。
         * o=a*b;
         * @param	a 4*4矩阵数组。
         * @param	b 4*4矩阵数组。
         * @param	o 4*4矩阵数组。
         */
        static ArrayMul(a: any[], b: any[], o: any[]): void;
        static copyArray(f: any[], t: any[]): void;
    }
    /**
     * Mesh2d只是保存数据。描述attribute用的。本身不具有渲染功能。
     */
    class Mesh2D {
        _stride: number;
        vertNum: number;
        indexNum: number;
        protected _applied: boolean;
        _vb: VertexBuffer2D;
        _ib: IndexBuffer2D;
        private _vao;
        private static _gvaoid;
        private _attribInfo;
        protected _quadNum: number;
        canReuse: boolean;
        /**
         * @param	stride
         * @param	vballoc  vb预分配的大小。主要是用来提高效率。防止不断的resizebfufer
         * @param	iballoc
         */
        constructor(stride: number, vballoc: number, iballoc: number);
        /**
         * 直接创建一个固定的ib。按照固定四边形的索引。
         * @param	var QuadNum
         */
        createQuadIB(QuadNum: number): void;
        /**
         * 设置mesh的属性。每3个一组，对应的location分别是0,1,2...
         * 含义是：type,size,offset
         * 不允许多流。因此stride是固定的，offset只是在一个vertex之内。
         * @param	attribs
         */
        setAttributes(attribs: any[]): void;
        /**
         * 初始化VAO的配置，只需要执行一次。以后使用的时候直接bind就行
         * @param	gl
         */
        private configVAO;
        /**
         * 应用这个mesh
         * @param	gl
         */
        useMesh(): void;
        /**
         * 子类实现。用来把自己放到对应的回收池中，以便复用。
         */
        releaseMesh(): void;
        /**
         * 释放资源。
         */
        destroy(): void;
        /**
         * 清理vb数据
         */
        clearVB(): void;
    }
    /**
     * drawImage，fillRect等会用到的简单的mesh。每次添加必然是一个四边形。
     */
    class MeshParticle2D extends Mesh2D {
        static const_stride: number;
        private static _fixattriInfo;
        private static _POOL;
        static vertexDeclaration: VertexDeclaration;
        static __init__(): void;
        constructor(maxNum: number);
        setMaxParticleNum(maxNum: number): void;
        /**
         *
         */
        static getAMesh(maxNum: number): MeshParticle2D;
        /**
         * 把本对象放到回收池中，以便getMesh能用。
         * @override
         */
        releaseMesh(): void;
        /**
         * @override
         */
        destroy(): void;
    }
    /**
     * drawImage，fillRect等会用到的简单的mesh。每次添加必然是一个四边形。
     */
    class MeshQuadTexture extends Mesh2D {
        static const_stride: number;
        private static _fixib;
        private static _maxIB;
        private static _fixattriInfo;
        private static _POOL;
        static VertexDeclarition: VertexDeclaration;
        static __int__(): void;
        constructor();
        /**
         *
         */
        static getAMesh(mainctx: boolean): MeshQuadTexture;
        /**
         * 把本对象放到回收池中，以便getMesh能用。
         * @override
         */
        releaseMesh(): void;
        /**
         * @override
         */
        destroy(): void;
        /**
         *
         * @param pos 顶点坐标
         * @param uv 纹理坐标
         * @param color 顶点颜色
         * @param useTex 是否使用贴图。false的话是给fillRect用的
         */
        addQuad(pos: ArrayLike<number>, uv: ArrayLike<number>, color: number, useTex: boolean): void;
    }
    /**
     * 与MeshQuadTexture基本相同。不过index不是固定的
     */
    class MeshTexture extends Mesh2D {
        static const_stride: number;
        private static _fixattriInfo;
        private static _POOL;
        static VertexDeclarition: VertexDeclaration;
        static __init__(): void;
        constructor();
        /**
         *
         */
        static getAMesh(mainctx: boolean): MeshTexture;
        /**
         * 增加四个顶点
         * @param vertices
         * @param uvs
         * @param idx
         * @param matrix
         * @param rgba
         */
        addData(vertices: Float32Array, uvs: Float32Array, idx: Uint16Array, matrix: Matrix, rgba: number): void;
        /**
         * 把本对象放到回收池中，以便getMesh能用。
         * @override
         */
        releaseMesh(): void;
        /**
         * @override
         */
        destroy(): void;
    }
    /**
     * 用来画矢量的mesh。顶点格式固定为 x,y,rgba
     */
    class MeshVG extends Mesh2D {
        static const_stride: number;
        private static _fixattriInfo;
        private static _POOL;
        static vertexDeclaration: VertexDeclaration;
        static __init__(): void;
        constructor();
        static getAMesh(mainctx: boolean): MeshVG;
        /**
         * 往矢量mesh中添加顶点和index。会把rgba和points在mesh中合并。
         * @param	points	顶点数组，只包含x,y。[x,y,x,y...]
         * @param	rgba	rgba颜色
         * @param	ib		index数组。
         */
        addVertAndIBToMesh(ctx: Context, points: any[], rgba: number, ib: any[]): void;
        /**
         * 把本对象放到回收池中，以便getMesh能用。
         * @override
         */
        releaseMesh(): void;
        /**
         * @override
         */
        destroy(): void;
    }
    class RenderState2D {
        static _MAXSIZE: number;
        /**@private 一个初始化的 <code>Matrix</code> 对象，不允许修改此对象内容。*/
        static EMPTYMAT4_ARRAY: number[];
        static TEMPMAT4_ARRAY: number[];
        static worldMatrix4: number[];
        static worldMatrix: Matrix;
        static matWVP: any;
        static worldAlpha: number;
        static worldScissorTest: boolean;
        static worldShaderDefines: ShaderDefines2D;
        static worldFilters: any[];
        static width: number;
        static height: number;
        static InvertY: boolean;
        static mat2MatArray(mat: Matrix, matArray: any[]): any[];
        static restoreTempArray(): void;
        static clear(): void;
    }
    interface IShaderCompiledObj {
        vsNode: ShaderNode;
        psNode: ShaderNode;
        includeNames: Set<string>;
        defs: Set<string>;
    }
    /**
     * @private
     * <code>ShaderCompile</code> 类用于实现Shader编译。
     */
    class ShaderCompile {
        static IFDEF_NO: number;
        static IFDEF_YES: number;
        static IFDEF_ELSE: number;
        static IFDEF_PARENT: number;
        static includes: Record<string, IncludeFile>;
        static loadIncludeFileSync: (fileName: string) => void;
        static addInclude(fileName: string, txt: string, allowReplace?: boolean): IncludeFile;
        static compile(vs: string, ps: string, basePath?: string): IShaderCompiledObj;
        static compileAsync(vs: string, ps: string, basePath: string): Promise<IShaderCompiledObj>;
        private static _loadIncludesDeep;
        /**
         * @private
         */
        private static _compileToTree;
        static getRenderState(obj: Record<string, string | boolean | number | string[]>, renderState: RenderState): void;
    }
    class ShaderProcessInfo {
        defineString: string[];
        vs: ShaderNode;
        ps: ShaderNode;
        attributeMap: {
            [name: string]: [
                number,
                ShaderDataType
            ];
        };
        uniformMap: UniformMapType;
        is2D: boolean;
    }
    class ShaderCompileDefineBase {
        nodeCommonMap: Array<string>;
        constructor(owner: any, name: string, compiledObj: IShaderCompiledObj);
    }
    class ShaderNode {
        private static __id;
        private static __noCompileEnable;
        childs: any[];
        text: string;
        parent: ShaderNode;
        name: string;
        noCompile: boolean;
        includefiles: any[];
        condition: any;
        conditionType: number;
        useFuns: string;
        z: number;
        src: string;
        constructor(includefiles: any[]);
        setParent(parent: ShaderNode): void;
        setCondition(condition: string, type: number): void;
        toscript(def: any, out: any[]): any[];
        private _toscript;
    }
    class VertexBuffer2D extends VertexBuffer {
        static create: Function;
        buffer2D: Buffer2D;
        private _vertexStride;
        get vertexStride(): number;
        constructor(vertexStride: number, bufferUsage: number);
        getFloat32Array(): Float32Array;
        get _floatArray32(): Float32Array;
        get _uint32Array(): Uint32Array;
        /**
         * 在当前位置插入float数组。
         * @param	data
         * @param	pos
         */
        appendArray(data: any[]): void;
        deleteBuffer(): void;
        /**
         * @inheritDoc
         * @override
         */
        _bindForVAO(): void;
        /**
         * @override
         * override
         */
        destroy(): void;
    }
    /**
     * @private
     */
    class WebGL {
        static isNativeRender_enable: boolean;
        static _nativeRender_enable(): void;
        static enable(): boolean;
        static onStageResize(width: number, height: number): void;
    }
    class LayaEnv {
        static version: string;
        static isPlaying: boolean;
        static isPreview: boolean;
        static isConch: boolean;
        /** @deprecated Uses Laya.addBeforeInitCallback */
        static beforeInit: (stageConfig: IStageConfig) => void;
        /** @deprecated Use Laya.addAfterInitCallback */
        static afterInit: () => void;
    }
    interface IStageConfig {
        designWidth?: number;
        designHeight?: number;
        scaleMode?: string;
        screenMode?: string;
        alignV?: string;
        alignH?: string;
        backgroundColor?: string;
    }
    /**全局配置*/
    class UIConfig {
        /**是否开启触摸滚动（针对滚动条）*/
        static touchScrollEnable: boolean;
        /**是否开启滑轮滚动（针对滚动条）*/
        static mouseWheelEnable: boolean;
        /**是否显示滚动条按钮*/
        static showButtons: boolean;
        /**弹出框背景颜色*/
        static popupBgColor: string;
        /**弹出框背景透明度*/
        static popupBgAlpha: number;
        /**模式窗口点击边缘，是否关闭窗口，默认是关闭的*/
        static closeDialogOnSide: boolean;
    }
}
